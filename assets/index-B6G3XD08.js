var gE=Object.defineProperty;var _E=(e,t,r)=>t in e?gE(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var Ee=(e,t,r)=>_E(e,typeof t!="symbol"?t+"":t,r);function yE(e,t){for(var r=0;r<t.length;r++){const o=t[r];if(typeof o!="string"&&!Array.isArray(o)){for(const a in o)if(a!=="default"&&!(a in e)){const l=Object.getOwnPropertyDescriptor(o,a);l&&Object.defineProperty(e,a,l.get?l:{enumerable:!0,get:()=>o[a]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))o(a);new MutationObserver(a=>{for(const l of a)if(l.type==="childList")for(const p of l.addedNodes)p.tagName==="LINK"&&p.rel==="modulepreload"&&o(p)}).observe(document,{childList:!0,subtree:!0});function r(a){const l={};return a.integrity&&(l.integrity=a.integrity),a.referrerPolicy&&(l.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?l.credentials="include":a.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function o(a){if(a.ep)return;a.ep=!0;const l=r(a);fetch(a.href,l)}})();function wE(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var zM={exports:{}},Ag={},LM={exports:{}},On={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var mh=Symbol.for("react.element"),vE=Symbol.for("react.portal"),bE=Symbol.for("react.fragment"),ME=Symbol.for("react.strict_mode"),xE=Symbol.for("react.profiler"),TE=Symbol.for("react.provider"),SE=Symbol.for("react.context"),EE=Symbol.for("react.forward_ref"),kE=Symbol.for("react.suspense"),CE=Symbol.for("react.memo"),PE=Symbol.for("react.lazy"),sb=Symbol.iterator;function $E(e){return e===null||typeof e!="object"?null:(e=sb&&e[sb]||e["@@iterator"],typeof e=="function"?e:null)}var RM={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},BM=Object.assign,NM={};function rc(e,t,r){this.props=e,this.context=t,this.refs=NM,this.updater=r||RM}rc.prototype.isReactComponent={};rc.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};rc.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function UM(){}UM.prototype=rc.prototype;function U0(e,t,r){this.props=e,this.context=t,this.refs=NM,this.updater=r||RM}var j0=U0.prototype=new UM;j0.constructor=U0;BM(j0,rc.prototype);j0.isPureReactComponent=!0;var ab=Array.isArray,jM=Object.prototype.hasOwnProperty,V0={current:null},VM={key:!0,ref:!0,__self:!0,__source:!0};function WM(e,t,r){var o,a={},l=null,p=null;if(t!=null)for(o in t.ref!==void 0&&(p=t.ref),t.key!==void 0&&(l=""+t.key),t)jM.call(t,o)&&!VM.hasOwnProperty(o)&&(a[o]=t[o]);var w=arguments.length-2;if(w===1)a.children=r;else if(1<w){for(var _=Array(w),y=0;y<w;y++)_[y]=arguments[y+2];a.children=_}if(e&&e.defaultProps)for(o in w=e.defaultProps,w)a[o]===void 0&&(a[o]=w[o]);return{$$typeof:mh,type:e,key:l,ref:p,props:a,_owner:V0.current}}function AE(e,t){return{$$typeof:mh,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function W0(e){return typeof e=="object"&&e!==null&&e.$$typeof===mh}function FE(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(r){return t[r]})}var lb=/\/+/g;function H_(e,t){return typeof e=="object"&&e!==null&&e.key!=null?FE(""+e.key):t.toString(36)}function Nm(e,t,r,o,a){var l=typeof e;(l==="undefined"||l==="boolean")&&(e=null);var p=!1;if(e===null)p=!0;else switch(l){case"string":case"number":p=!0;break;case"object":switch(e.$$typeof){case mh:case vE:p=!0}}if(p)return p=e,a=a(p),e=o===""?"."+H_(p,0):o,ab(a)?(r="",e!=null&&(r=e.replace(lb,"$&/")+"/"),Nm(a,t,r,"",function(y){return y})):a!=null&&(W0(a)&&(a=AE(a,r+(!a.key||p&&p.key===a.key?"":(""+a.key).replace(lb,"$&/")+"/")+e)),t.push(a)),1;if(p=0,o=o===""?".":o+":",ab(e))for(var w=0;w<e.length;w++){l=e[w];var _=o+H_(l,w);p+=Nm(l,t,r,_,a)}else if(_=$E(e),typeof _=="function")for(e=_.call(e),w=0;!(l=e.next()).done;)l=l.value,_=o+H_(l,w++),p+=Nm(l,t,r,_,a);else if(l==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return p}function Mm(e,t,r){if(e==null)return e;var o=[],a=0;return Nm(e,o,"","",function(l){return t.call(r,l,a++)}),o}function IE(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(r){(e._status===0||e._status===-1)&&(e._status=1,e._result=r)},function(r){(e._status===0||e._status===-1)&&(e._status=2,e._result=r)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var pi={current:null},Um={transition:null},OE={ReactCurrentDispatcher:pi,ReactCurrentBatchConfig:Um,ReactCurrentOwner:V0};On.Children={map:Mm,forEach:function(e,t,r){Mm(e,function(){t.apply(this,arguments)},r)},count:function(e){var t=0;return Mm(e,function(){t++}),t},toArray:function(e){return Mm(e,function(t){return t})||[]},only:function(e){if(!W0(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};On.Component=rc;On.Fragment=bE;On.Profiler=xE;On.PureComponent=U0;On.StrictMode=ME;On.Suspense=kE;On.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=OE;On.cloneElement=function(e,t,r){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var o=BM({},e.props),a=e.key,l=e.ref,p=e._owner;if(t!=null){if(t.ref!==void 0&&(l=t.ref,p=V0.current),t.key!==void 0&&(a=""+t.key),e.type&&e.type.defaultProps)var w=e.type.defaultProps;for(_ in t)jM.call(t,_)&&!VM.hasOwnProperty(_)&&(o[_]=t[_]===void 0&&w!==void 0?w[_]:t[_])}var _=arguments.length-2;if(_===1)o.children=r;else if(1<_){w=Array(_);for(var y=0;y<_;y++)w[y]=arguments[y+2];o.children=w}return{$$typeof:mh,type:e.type,key:a,ref:l,props:o,_owner:p}};On.createContext=function(e){return e={$$typeof:SE,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:TE,_context:e},e.Consumer=e};On.createElement=WM;On.createFactory=function(e){var t=WM.bind(null,e);return t.type=e,t};On.createRef=function(){return{current:null}};On.forwardRef=function(e){return{$$typeof:EE,render:e}};On.isValidElement=W0;On.lazy=function(e){return{$$typeof:PE,_payload:{_status:-1,_result:e},_init:IE}};On.memo=function(e,t){return{$$typeof:CE,type:e,compare:t===void 0?null:t}};On.startTransition=function(e){var t=Um.transition;Um.transition={};try{e()}finally{Um.transition=t}};On.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};On.useCallback=function(e,t){return pi.current.useCallback(e,t)};On.useContext=function(e){return pi.current.useContext(e)};On.useDebugValue=function(){};On.useDeferredValue=function(e){return pi.current.useDeferredValue(e)};On.useEffect=function(e,t){return pi.current.useEffect(e,t)};On.useId=function(){return pi.current.useId()};On.useImperativeHandle=function(e,t,r){return pi.current.useImperativeHandle(e,t,r)};On.useInsertionEffect=function(e,t){return pi.current.useInsertionEffect(e,t)};On.useLayoutEffect=function(e,t){return pi.current.useLayoutEffect(e,t)};On.useMemo=function(e,t){return pi.current.useMemo(e,t)};On.useReducer=function(e,t,r){return pi.current.useReducer(e,t,r)};On.useRef=function(e){return pi.current.useRef(e)};On.useState=function(e){return pi.current.useState(e)};On.useSyncExternalStore=function(e,t,r){return pi.current.useSyncExternalStore(e,t,r)};On.useTransition=function(){return pi.current.useTransition()};On.version="18.2.0";LM.exports=On;var Le=LM.exports;const qn=wE(Le),zy=yE({__proto__:null,default:qn},[Le]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var DE=Le,zE=Symbol.for("react.element"),LE=Symbol.for("react.fragment"),RE=Object.prototype.hasOwnProperty,BE=DE.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,NE={key:!0,ref:!0,__self:!0,__source:!0};function GM(e,t,r){var o,a={},l=null,p=null;r!==void 0&&(l=""+r),t.key!==void 0&&(l=""+t.key),t.ref!==void 0&&(p=t.ref);for(o in t)RE.call(t,o)&&!NE.hasOwnProperty(o)&&(a[o]=t[o]);if(e&&e.defaultProps)for(o in t=e.defaultProps,t)a[o]===void 0&&(a[o]=t[o]);return{$$typeof:zE,type:e,key:l,ref:p,props:a,_owner:BE.current}}Ag.Fragment=LE;Ag.jsx=GM;Ag.jsxs=GM;zM.exports=Ag;var G0=zM.exports;const Io=G0.Fragment,wt=G0.jsx,tr=G0.jsxs;var Ly={},qM={exports:{}},Ii={},HM={exports:{}},KM={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(Q,ae){var ye=Q.length;Q.push(ae);e:for(;0<ye;){var Pe=ye-1>>>1,Ze=Q[Pe];if(0<a(Ze,ae))Q[Pe]=ae,Q[ye]=Ze,ye=Pe;else break e}}function r(Q){return Q.length===0?null:Q[0]}function o(Q){if(Q.length===0)return null;var ae=Q[0],ye=Q.pop();if(ye!==ae){Q[0]=ye;e:for(var Pe=0,Ze=Q.length,me=Ze>>>1;Pe<me;){var Qe=2*(Pe+1)-1,et=Q[Qe],Ie=Qe+1,rt=Q[Ie];if(0>a(et,ye))Ie<Ze&&0>a(rt,et)?(Q[Pe]=rt,Q[Ie]=ye,Pe=Ie):(Q[Pe]=et,Q[Qe]=ye,Pe=Qe);else if(Ie<Ze&&0>a(rt,ye))Q[Pe]=rt,Q[Ie]=ye,Pe=Ie;else break e}}return ae}function a(Q,ae){var ye=Q.sortIndex-ae.sortIndex;return ye!==0?ye:Q.id-ae.id}if(typeof performance=="object"&&typeof performance.now=="function"){var l=performance;e.unstable_now=function(){return l.now()}}else{var p=Date,w=p.now();e.unstable_now=function(){return p.now()-w}}var _=[],y=[],T=1,E=null,A=3,H=!1,W=!1,Y=!1,B=typeof setTimeout=="function"?setTimeout:null,F=typeof clearTimeout=="function"?clearTimeout:null,O=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function P(Q){for(var ae=r(y);ae!==null;){if(ae.callback===null)o(y);else if(ae.startTime<=Q)o(y),ae.sortIndex=ae.expirationTime,t(_,ae);else break;ae=r(y)}}function j(Q){if(Y=!1,P(Q),!W)if(r(_)!==null)W=!0,it(V);else{var ae=r(y);ae!==null&&be(j,ae.startTime-Q)}}function V(Q,ae){W=!1,Y&&(Y=!1,F(L),L=-1),H=!0;var ye=A;try{for(P(ae),E=r(_);E!==null&&(!(E.expirationTime>ae)||Q&&!xe());){var Pe=E.callback;if(typeof Pe=="function"){E.callback=null,A=E.priorityLevel;var Ze=Pe(E.expirationTime<=ae);ae=e.unstable_now(),typeof Ze=="function"?E.callback=Ze:E===r(_)&&o(_),P(ae)}else o(_);E=r(_)}if(E!==null)var me=!0;else{var Qe=r(y);Qe!==null&&be(j,Qe.startTime-ae),me=!1}return me}finally{E=null,A=ye,H=!1}}var z=!1,q=null,L=-1,pe=5,fe=-1;function xe(){return!(e.unstable_now()-fe<pe)}function $e(){if(q!==null){var Q=e.unstable_now();fe=Q;var ae=!0;try{ae=q(!0,Q)}finally{ae?Ce():(z=!1,q=null)}}else z=!1}var Ce;if(typeof O=="function")Ce=function(){O($e)};else if(typeof MessageChannel<"u"){var tt=new MessageChannel,Je=tt.port2;tt.port1.onmessage=$e,Ce=function(){Je.postMessage(null)}}else Ce=function(){B($e,0)};function it(Q){q=Q,z||(z=!0,Ce())}function be(Q,ae){L=B(function(){Q(e.unstable_now())},ae)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(Q){Q.callback=null},e.unstable_continueExecution=function(){W||H||(W=!0,it(V))},e.unstable_forceFrameRate=function(Q){0>Q||125<Q?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):pe=0<Q?Math.floor(1e3/Q):5},e.unstable_getCurrentPriorityLevel=function(){return A},e.unstable_getFirstCallbackNode=function(){return r(_)},e.unstable_next=function(Q){switch(A){case 1:case 2:case 3:var ae=3;break;default:ae=A}var ye=A;A=ae;try{return Q()}finally{A=ye}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(Q,ae){switch(Q){case 1:case 2:case 3:case 4:case 5:break;default:Q=3}var ye=A;A=Q;try{return ae()}finally{A=ye}},e.unstable_scheduleCallback=function(Q,ae,ye){var Pe=e.unstable_now();switch(typeof ye=="object"&&ye!==null?(ye=ye.delay,ye=typeof ye=="number"&&0<ye?Pe+ye:Pe):ye=Pe,Q){case 1:var Ze=-1;break;case 2:Ze=250;break;case 5:Ze=1073741823;break;case 4:Ze=1e4;break;default:Ze=5e3}return Ze=ye+Ze,Q={id:T++,callback:ae,priorityLevel:Q,startTime:ye,expirationTime:Ze,sortIndex:-1},ye>Pe?(Q.sortIndex=ye,t(y,Q),r(_)===null&&Q===r(y)&&(Y?(F(L),L=-1):Y=!0,be(j,ye-Pe))):(Q.sortIndex=Ze,t(_,Q),W||H||(W=!0,it(V))),Q},e.unstable_shouldYield=xe,e.unstable_wrapCallback=function(Q){var ae=A;return function(){var ye=A;A=ae;try{return Q.apply(this,arguments)}finally{A=ye}}}})(KM);HM.exports=KM;var UE=HM.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var XM=Le,Fi=UE;function Et(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,r=1;r<arguments.length;r++)t+="&args[]="+encodeURIComponent(arguments[r]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var QM=new Set,Yf={};function Wa(e,t){Xu(e,t),Xu(e+"Capture",t)}function Xu(e,t){for(Yf[e]=t,e=0;e<t.length;e++)QM.add(t[e])}var os=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Ry=Object.prototype.hasOwnProperty,jE=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,ub={},cb={};function VE(e){return Ry.call(cb,e)?!0:Ry.call(ub,e)?!1:jE.test(e)?cb[e]=!0:(ub[e]=!0,!1)}function WE(e,t,r,o){if(r!==null&&r.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return o?!1:r!==null?!r.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function GE(e,t,r,o){if(t===null||typeof t>"u"||WE(e,t,r,o))return!0;if(o)return!1;if(r!==null)switch(r.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function fi(e,t,r,o,a,l,p){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=o,this.attributeNamespace=a,this.mustUseProperty=r,this.propertyName=e,this.type=t,this.sanitizeURL=l,this.removeEmptyString=p}var Jr={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Jr[e]=new fi(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Jr[t]=new fi(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Jr[e]=new fi(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Jr[e]=new fi(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Jr[e]=new fi(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Jr[e]=new fi(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Jr[e]=new fi(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Jr[e]=new fi(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Jr[e]=new fi(e,5,!1,e.toLowerCase(),null,!1,!1)});var q0=/[\-:]([a-z])/g;function H0(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(q0,H0);Jr[t]=new fi(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(q0,H0);Jr[t]=new fi(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(q0,H0);Jr[t]=new fi(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Jr[e]=new fi(e,1,!1,e.toLowerCase(),null,!1,!1)});Jr.xlinkHref=new fi("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Jr[e]=new fi(e,1,!1,e.toLowerCase(),null,!0,!0)});function K0(e,t,r,o){var a=Jr.hasOwnProperty(t)?Jr[t]:null;(a!==null?a.type!==0:o||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(GE(t,r,a,o)&&(r=null),o||a===null?VE(t)&&(r===null?e.removeAttribute(t):e.setAttribute(t,""+r)):a.mustUseProperty?e[a.propertyName]=r===null?a.type===3?!1:"":r:(t=a.attributeName,o=a.attributeNamespace,r===null?e.removeAttribute(t):(a=a.type,r=a===3||a===4&&r===!0?"":""+r,o?e.setAttributeNS(o,t,r):e.setAttribute(t,r))))}var us=XM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,xm=Symbol.for("react.element"),Au=Symbol.for("react.portal"),Fu=Symbol.for("react.fragment"),X0=Symbol.for("react.strict_mode"),By=Symbol.for("react.profiler"),YM=Symbol.for("react.provider"),JM=Symbol.for("react.context"),Q0=Symbol.for("react.forward_ref"),Ny=Symbol.for("react.suspense"),Uy=Symbol.for("react.suspense_list"),Y0=Symbol.for("react.memo"),zs=Symbol.for("react.lazy"),ZM=Symbol.for("react.offscreen"),db=Symbol.iterator;function Tf(e){return e===null||typeof e!="object"?null:(e=db&&e[db]||e["@@iterator"],typeof e=="function"?e:null)}var br=Object.assign,K_;function zf(e){if(K_===void 0)try{throw Error()}catch(r){var t=r.stack.trim().match(/\n( *(at )?)/);K_=t&&t[1]||""}return`
`+K_+e}var X_=!1;function Q_(e,t){if(!e||X_)return"";X_=!0;var r=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(y){var o=y}Reflect.construct(e,[],t)}else{try{t.call()}catch(y){o=y}e.call(t.prototype)}else{try{throw Error()}catch(y){o=y}e()}}catch(y){if(y&&o&&typeof y.stack=="string"){for(var a=y.stack.split(`
`),l=o.stack.split(`
`),p=a.length-1,w=l.length-1;1<=p&&0<=w&&a[p]!==l[w];)w--;for(;1<=p&&0<=w;p--,w--)if(a[p]!==l[w]){if(p!==1||w!==1)do if(p--,w--,0>w||a[p]!==l[w]){var _=`
`+a[p].replace(" at new "," at ");return e.displayName&&_.includes("<anonymous>")&&(_=_.replace("<anonymous>",e.displayName)),_}while(1<=p&&0<=w);break}}}finally{X_=!1,Error.prepareStackTrace=r}return(e=e?e.displayName||e.name:"")?zf(e):""}function qE(e){switch(e.tag){case 5:return zf(e.type);case 16:return zf("Lazy");case 13:return zf("Suspense");case 19:return zf("SuspenseList");case 0:case 2:case 15:return e=Q_(e.type,!1),e;case 11:return e=Q_(e.type.render,!1),e;case 1:return e=Q_(e.type,!0),e;default:return""}}function jy(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Fu:return"Fragment";case Au:return"Portal";case By:return"Profiler";case X0:return"StrictMode";case Ny:return"Suspense";case Uy:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case JM:return(e.displayName||"Context")+".Consumer";case YM:return(e._context.displayName||"Context")+".Provider";case Q0:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Y0:return t=e.displayName||null,t!==null?t:jy(e.type)||"Memo";case zs:t=e._payload,e=e._init;try{return jy(e(t))}catch{}}return null}function HE(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return jy(t);case 8:return t===X0?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function Ys(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function ex(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function KE(e){var t=ex(e)?"checked":"value",r=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),o=""+e[t];if(!e.hasOwnProperty(t)&&typeof r<"u"&&typeof r.get=="function"&&typeof r.set=="function"){var a=r.get,l=r.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(p){o=""+p,l.call(this,p)}}),Object.defineProperty(e,t,{enumerable:r.enumerable}),{getValue:function(){return o},setValue:function(p){o=""+p},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Tm(e){e._valueTracker||(e._valueTracker=KE(e))}function tx(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var r=t.getValue(),o="";return e&&(o=ex(e)?e.checked?"true":"false":e.value),e=o,e!==r?(t.setValue(e),!0):!1}function rg(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Vy(e,t){var r=t.checked;return br({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:r??e._wrapperState.initialChecked})}function pb(e,t){var r=t.defaultValue==null?"":t.defaultValue,o=t.checked!=null?t.checked:t.defaultChecked;r=Ys(t.value!=null?t.value:r),e._wrapperState={initialChecked:o,initialValue:r,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function nx(e,t){t=t.checked,t!=null&&K0(e,"checked",t,!1)}function Wy(e,t){nx(e,t);var r=Ys(t.value),o=t.type;if(r!=null)o==="number"?(r===0&&e.value===""||e.value!=r)&&(e.value=""+r):e.value!==""+r&&(e.value=""+r);else if(o==="submit"||o==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?Gy(e,t.type,r):t.hasOwnProperty("defaultValue")&&Gy(e,t.type,Ys(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function fb(e,t,r){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var o=t.type;if(!(o!=="submit"&&o!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,r||t===e.value||(e.value=t),e.defaultValue=t}r=e.name,r!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,r!==""&&(e.name=r)}function Gy(e,t,r){(t!=="number"||rg(e.ownerDocument)!==e)&&(r==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+r&&(e.defaultValue=""+r))}var Lf=Array.isArray;function Vu(e,t,r,o){if(e=e.options,t){t={};for(var a=0;a<r.length;a++)t["$"+r[a]]=!0;for(r=0;r<e.length;r++)a=t.hasOwnProperty("$"+e[r].value),e[r].selected!==a&&(e[r].selected=a),a&&o&&(e[r].defaultSelected=!0)}else{for(r=""+Ys(r),t=null,a=0;a<e.length;a++){if(e[a].value===r){e[a].selected=!0,o&&(e[a].defaultSelected=!0);return}t!==null||e[a].disabled||(t=e[a])}t!==null&&(t.selected=!0)}}function qy(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(Et(91));return br({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function hb(e,t){var r=t.value;if(r==null){if(r=t.children,t=t.defaultValue,r!=null){if(t!=null)throw Error(Et(92));if(Lf(r)){if(1<r.length)throw Error(Et(93));r=r[0]}t=r}t==null&&(t=""),r=t}e._wrapperState={initialValue:Ys(r)}}function rx(e,t){var r=Ys(t.value),o=Ys(t.defaultValue);r!=null&&(r=""+r,r!==e.value&&(e.value=r),t.defaultValue==null&&e.defaultValue!==r&&(e.defaultValue=r)),o!=null&&(e.defaultValue=""+o)}function mb(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function ix(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hy(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?ix(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var Sm,ox=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,r,o,a){MSApp.execUnsafeLocalFunction(function(){return e(t,r,o,a)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(Sm=Sm||document.createElement("div"),Sm.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=Sm.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Jf(e,t){if(t){var r=e.firstChild;if(r&&r===e.lastChild&&r.nodeType===3){r.nodeValue=t;return}}e.textContent=t}var jf={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},XE=["Webkit","ms","Moz","O"];Object.keys(jf).forEach(function(e){XE.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),jf[t]=jf[e]})});function sx(e,t,r){return t==null||typeof t=="boolean"||t===""?"":r||typeof t!="number"||t===0||jf.hasOwnProperty(e)&&jf[e]?(""+t).trim():t+"px"}function ax(e,t){e=e.style;for(var r in t)if(t.hasOwnProperty(r)){var o=r.indexOf("--")===0,a=sx(r,t[r],o);r==="float"&&(r="cssFloat"),o?e.setProperty(r,a):e[r]=a}}var QE=br({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Ky(e,t){if(t){if(QE[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(Et(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(Et(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(Et(61))}if(t.style!=null&&typeof t.style!="object")throw Error(Et(62))}}function Xy(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Qy=null;function J0(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var Yy=null,Wu=null,Gu=null;function gb(e){if(e=yh(e)){if(typeof Yy!="function")throw Error(Et(280));var t=e.stateNode;t&&(t=zg(t),Yy(e.stateNode,e.type,t))}}function lx(e){Wu?Gu?Gu.push(e):Gu=[e]:Wu=e}function ux(){if(Wu){var e=Wu,t=Gu;if(Gu=Wu=null,gb(e),t)for(e=0;e<t.length;e++)gb(t[e])}}function cx(e,t){return e(t)}function dx(){}var Y_=!1;function px(e,t,r){if(Y_)return e(t,r);Y_=!0;try{return cx(e,t,r)}finally{Y_=!1,(Wu!==null||Gu!==null)&&(dx(),ux())}}function Zf(e,t){var r=e.stateNode;if(r===null)return null;var o=zg(r);if(o===null)return null;r=o[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(o=!o.disabled)||(e=e.type,o=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!o;break e;default:e=!1}if(e)return null;if(r&&typeof r!="function")throw Error(Et(231,t,typeof r));return r}var Jy=!1;if(os)try{var Sf={};Object.defineProperty(Sf,"passive",{get:function(){Jy=!0}}),window.addEventListener("test",Sf,Sf),window.removeEventListener("test",Sf,Sf)}catch{Jy=!1}function YE(e,t,r,o,a,l,p,w,_){var y=Array.prototype.slice.call(arguments,3);try{t.apply(r,y)}catch(T){this.onError(T)}}var Vf=!1,ig=null,og=!1,Zy=null,JE={onError:function(e){Vf=!0,ig=e}};function ZE(e,t,r,o,a,l,p,w,_){Vf=!1,ig=null,YE.apply(JE,arguments)}function ek(e,t,r,o,a,l,p,w,_){if(ZE.apply(this,arguments),Vf){if(Vf){var y=ig;Vf=!1,ig=null}else throw Error(Et(198));og||(og=!0,Zy=y)}}function Ga(e){var t=e,r=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(r=t.return),e=t.return;while(e)}return t.tag===3?r:null}function fx(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function _b(e){if(Ga(e)!==e)throw Error(Et(188))}function tk(e){var t=e.alternate;if(!t){if(t=Ga(e),t===null)throw Error(Et(188));return t!==e?null:e}for(var r=e,o=t;;){var a=r.return;if(a===null)break;var l=a.alternate;if(l===null){if(o=a.return,o!==null){r=o;continue}break}if(a.child===l.child){for(l=a.child;l;){if(l===r)return _b(a),e;if(l===o)return _b(a),t;l=l.sibling}throw Error(Et(188))}if(r.return!==o.return)r=a,o=l;else{for(var p=!1,w=a.child;w;){if(w===r){p=!0,r=a,o=l;break}if(w===o){p=!0,o=a,r=l;break}w=w.sibling}if(!p){for(w=l.child;w;){if(w===r){p=!0,r=l,o=a;break}if(w===o){p=!0,o=l,r=a;break}w=w.sibling}if(!p)throw Error(Et(189))}}if(r.alternate!==o)throw Error(Et(190))}if(r.tag!==3)throw Error(Et(188));return r.stateNode.current===r?e:t}function hx(e){return e=tk(e),e!==null?mx(e):null}function mx(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=mx(e);if(t!==null)return t;e=e.sibling}return null}var gx=Fi.unstable_scheduleCallback,yb=Fi.unstable_cancelCallback,nk=Fi.unstable_shouldYield,rk=Fi.unstable_requestPaint,Er=Fi.unstable_now,ik=Fi.unstable_getCurrentPriorityLevel,Z0=Fi.unstable_ImmediatePriority,_x=Fi.unstable_UserBlockingPriority,sg=Fi.unstable_NormalPriority,ok=Fi.unstable_LowPriority,yx=Fi.unstable_IdlePriority,Fg=null,Oo=null;function sk(e){if(Oo&&typeof Oo.onCommitFiberRoot=="function")try{Oo.onCommitFiberRoot(Fg,e,void 0,(e.current.flags&128)===128)}catch{}}var ho=Math.clz32?Math.clz32:uk,ak=Math.log,lk=Math.LN2;function uk(e){return e>>>=0,e===0?32:31-(ak(e)/lk|0)|0}var Em=64,km=4194304;function Rf(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ag(e,t){var r=e.pendingLanes;if(r===0)return 0;var o=0,a=e.suspendedLanes,l=e.pingedLanes,p=r&268435455;if(p!==0){var w=p&~a;w!==0?o=Rf(w):(l&=p,l!==0&&(o=Rf(l)))}else p=r&~a,p!==0?o=Rf(p):l!==0&&(o=Rf(l));if(o===0)return 0;if(t!==0&&t!==o&&!(t&a)&&(a=o&-o,l=t&-t,a>=l||a===16&&(l&4194240)!==0))return t;if(o&4&&(o|=r&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=o;0<t;)r=31-ho(t),a=1<<r,o|=e[r],t&=~a;return o}function ck(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function dk(e,t){for(var r=e.suspendedLanes,o=e.pingedLanes,a=e.expirationTimes,l=e.pendingLanes;0<l;){var p=31-ho(l),w=1<<p,_=a[p];_===-1?(!(w&r)||w&o)&&(a[p]=ck(w,t)):_<=t&&(e.expiredLanes|=w),l&=~w}}function e0(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function wx(){var e=Em;return Em<<=1,!(Em&4194240)&&(Em=64),e}function J_(e){for(var t=[],r=0;31>r;r++)t.push(e);return t}function gh(e,t,r){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-ho(t),e[t]=r}function pk(e,t){var r=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var o=e.eventTimes;for(e=e.expirationTimes;0<r;){var a=31-ho(r),l=1<<a;t[a]=0,o[a]=-1,e[a]=-1,r&=~l}}function ew(e,t){var r=e.entangledLanes|=t;for(e=e.entanglements;r;){var o=31-ho(r),a=1<<o;a&t|e[o]&t&&(e[o]|=t),r&=~a}}var nr=0;function vx(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var bx,tw,Mx,xx,Tx,t0=!1,Cm=[],Vs=null,Ws=null,Gs=null,eh=new Map,th=new Map,Rs=[],fk="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function wb(e,t){switch(e){case"focusin":case"focusout":Vs=null;break;case"dragenter":case"dragleave":Ws=null;break;case"mouseover":case"mouseout":Gs=null;break;case"pointerover":case"pointerout":eh.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":th.delete(t.pointerId)}}function Ef(e,t,r,o,a,l){return e===null||e.nativeEvent!==l?(e={blockedOn:t,domEventName:r,eventSystemFlags:o,nativeEvent:l,targetContainers:[a]},t!==null&&(t=yh(t),t!==null&&tw(t)),e):(e.eventSystemFlags|=o,t=e.targetContainers,a!==null&&t.indexOf(a)===-1&&t.push(a),e)}function hk(e,t,r,o,a){switch(t){case"focusin":return Vs=Ef(Vs,e,t,r,o,a),!0;case"dragenter":return Ws=Ef(Ws,e,t,r,o,a),!0;case"mouseover":return Gs=Ef(Gs,e,t,r,o,a),!0;case"pointerover":var l=a.pointerId;return eh.set(l,Ef(eh.get(l)||null,e,t,r,o,a)),!0;case"gotpointercapture":return l=a.pointerId,th.set(l,Ef(th.get(l)||null,e,t,r,o,a)),!0}return!1}function Sx(e){var t=Aa(e.target);if(t!==null){var r=Ga(t);if(r!==null){if(t=r.tag,t===13){if(t=fx(r),t!==null){e.blockedOn=t,Tx(e.priority,function(){Mx(r)});return}}else if(t===3&&r.stateNode.current.memoizedState.isDehydrated){e.blockedOn=r.tag===3?r.stateNode.containerInfo:null;return}}}e.blockedOn=null}function jm(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var r=n0(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(r===null){r=e.nativeEvent;var o=new r.constructor(r.type,r);Qy=o,r.target.dispatchEvent(o),Qy=null}else return t=yh(r),t!==null&&tw(t),e.blockedOn=r,!1;t.shift()}return!0}function vb(e,t,r){jm(e)&&r.delete(t)}function mk(){t0=!1,Vs!==null&&jm(Vs)&&(Vs=null),Ws!==null&&jm(Ws)&&(Ws=null),Gs!==null&&jm(Gs)&&(Gs=null),eh.forEach(vb),th.forEach(vb)}function kf(e,t){e.blockedOn===t&&(e.blockedOn=null,t0||(t0=!0,Fi.unstable_scheduleCallback(Fi.unstable_NormalPriority,mk)))}function nh(e){function t(a){return kf(a,e)}if(0<Cm.length){kf(Cm[0],e);for(var r=1;r<Cm.length;r++){var o=Cm[r];o.blockedOn===e&&(o.blockedOn=null)}}for(Vs!==null&&kf(Vs,e),Ws!==null&&kf(Ws,e),Gs!==null&&kf(Gs,e),eh.forEach(t),th.forEach(t),r=0;r<Rs.length;r++)o=Rs[r],o.blockedOn===e&&(o.blockedOn=null);for(;0<Rs.length&&(r=Rs[0],r.blockedOn===null);)Sx(r),r.blockedOn===null&&Rs.shift()}var qu=us.ReactCurrentBatchConfig,lg=!0;function gk(e,t,r,o){var a=nr,l=qu.transition;qu.transition=null;try{nr=1,nw(e,t,r,o)}finally{nr=a,qu.transition=l}}function _k(e,t,r,o){var a=nr,l=qu.transition;qu.transition=null;try{nr=4,nw(e,t,r,o)}finally{nr=a,qu.transition=l}}function nw(e,t,r,o){if(lg){var a=n0(e,t,r,o);if(a===null)ly(e,t,o,ug,r),wb(e,o);else if(hk(a,e,t,r,o))o.stopPropagation();else if(wb(e,o),t&4&&-1<fk.indexOf(e)){for(;a!==null;){var l=yh(a);if(l!==null&&bx(l),l=n0(e,t,r,o),l===null&&ly(e,t,o,ug,r),l===a)break;a=l}a!==null&&o.stopPropagation()}else ly(e,t,o,null,r)}}var ug=null;function n0(e,t,r,o){if(ug=null,e=J0(o),e=Aa(e),e!==null)if(t=Ga(e),t===null)e=null;else if(r=t.tag,r===13){if(e=fx(t),e!==null)return e;e=null}else if(r===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return ug=e,null}function Ex(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ik()){case Z0:return 1;case _x:return 4;case sg:case ok:return 16;case yx:return 536870912;default:return 16}default:return 16}}var Us=null,rw=null,Vm=null;function kx(){if(Vm)return Vm;var e,t=rw,r=t.length,o,a="value"in Us?Us.value:Us.textContent,l=a.length;for(e=0;e<r&&t[e]===a[e];e++);var p=r-e;for(o=1;o<=p&&t[r-o]===a[l-o];o++);return Vm=a.slice(e,1<o?1-o:void 0)}function Wm(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Pm(){return!0}function bb(){return!1}function Oi(e){function t(r,o,a,l,p){this._reactName=r,this._targetInst=a,this.type=o,this.nativeEvent=l,this.target=p,this.currentTarget=null;for(var w in e)e.hasOwnProperty(w)&&(r=e[w],this[w]=r?r(l):l[w]);return this.isDefaultPrevented=(l.defaultPrevented!=null?l.defaultPrevented:l.returnValue===!1)?Pm:bb,this.isPropagationStopped=bb,this}return br(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var r=this.nativeEvent;r&&(r.preventDefault?r.preventDefault():typeof r.returnValue!="unknown"&&(r.returnValue=!1),this.isDefaultPrevented=Pm)},stopPropagation:function(){var r=this.nativeEvent;r&&(r.stopPropagation?r.stopPropagation():typeof r.cancelBubble!="unknown"&&(r.cancelBubble=!0),this.isPropagationStopped=Pm)},persist:function(){},isPersistent:Pm}),t}var ic={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},iw=Oi(ic),_h=br({},ic,{view:0,detail:0}),yk=Oi(_h),Z_,ey,Cf,Ig=br({},_h,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ow,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Cf&&(Cf&&e.type==="mousemove"?(Z_=e.screenX-Cf.screenX,ey=e.screenY-Cf.screenY):ey=Z_=0,Cf=e),Z_)},movementY:function(e){return"movementY"in e?e.movementY:ey}}),Mb=Oi(Ig),wk=br({},Ig,{dataTransfer:0}),vk=Oi(wk),bk=br({},_h,{relatedTarget:0}),ty=Oi(bk),Mk=br({},ic,{animationName:0,elapsedTime:0,pseudoElement:0}),xk=Oi(Mk),Tk=br({},ic,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Sk=Oi(Tk),Ek=br({},ic,{data:0}),xb=Oi(Ek),kk={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Ck={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Pk={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function $k(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=Pk[e])?!!t[e]:!1}function ow(){return $k}var Ak=br({},_h,{key:function(e){if(e.key){var t=kk[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Wm(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?Ck[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ow,charCode:function(e){return e.type==="keypress"?Wm(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Wm(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),Fk=Oi(Ak),Ik=br({},Ig,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Tb=Oi(Ik),Ok=br({},_h,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ow}),Dk=Oi(Ok),zk=br({},ic,{propertyName:0,elapsedTime:0,pseudoElement:0}),Lk=Oi(zk),Rk=br({},Ig,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Bk=Oi(Rk),Nk=[9,13,27,32],sw=os&&"CompositionEvent"in window,Wf=null;os&&"documentMode"in document&&(Wf=document.documentMode);var Uk=os&&"TextEvent"in window&&!Wf,Cx=os&&(!sw||Wf&&8<Wf&&11>=Wf),Sb=" ",Eb=!1;function Px(e,t){switch(e){case"keyup":return Nk.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function $x(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Iu=!1;function jk(e,t){switch(e){case"compositionend":return $x(t);case"keypress":return t.which!==32?null:(Eb=!0,Sb);case"textInput":return e=t.data,e===Sb&&Eb?null:e;default:return null}}function Vk(e,t){if(Iu)return e==="compositionend"||!sw&&Px(e,t)?(e=kx(),Vm=rw=Us=null,Iu=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Cx&&t.locale!=="ko"?null:t.data;default:return null}}var Wk={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function kb(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!Wk[e.type]:t==="textarea"}function Ax(e,t,r,o){lx(o),t=cg(t,"onChange"),0<t.length&&(r=new iw("onChange","change",null,r,o),e.push({event:r,listeners:t}))}var Gf=null,rh=null;function Gk(e){jx(e,0)}function Og(e){var t=zu(e);if(tx(t))return e}function qk(e,t){if(e==="change")return t}var Fx=!1;if(os){var ny;if(os){var ry="oninput"in document;if(!ry){var Cb=document.createElement("div");Cb.setAttribute("oninput","return;"),ry=typeof Cb.oninput=="function"}ny=ry}else ny=!1;Fx=ny&&(!document.documentMode||9<document.documentMode)}function Pb(){Gf&&(Gf.detachEvent("onpropertychange",Ix),rh=Gf=null)}function Ix(e){if(e.propertyName==="value"&&Og(rh)){var t=[];Ax(t,rh,e,J0(e)),px(Gk,t)}}function Hk(e,t,r){e==="focusin"?(Pb(),Gf=t,rh=r,Gf.attachEvent("onpropertychange",Ix)):e==="focusout"&&Pb()}function Kk(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return Og(rh)}function Xk(e,t){if(e==="click")return Og(t)}function Qk(e,t){if(e==="input"||e==="change")return Og(t)}function Yk(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var go=typeof Object.is=="function"?Object.is:Yk;function ih(e,t){if(go(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var r=Object.keys(e),o=Object.keys(t);if(r.length!==o.length)return!1;for(o=0;o<r.length;o++){var a=r[o];if(!Ry.call(t,a)||!go(e[a],t[a]))return!1}return!0}function $b(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Ab(e,t){var r=$b(e);e=0;for(var o;r;){if(r.nodeType===3){if(o=e+r.textContent.length,e<=t&&o>=t)return{node:r,offset:t-e};e=o}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=$b(r)}}function Ox(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?Ox(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function Dx(){for(var e=window,t=rg();t instanceof e.HTMLIFrameElement;){try{var r=typeof t.contentWindow.location.href=="string"}catch{r=!1}if(r)e=t.contentWindow;else break;t=rg(e.document)}return t}function aw(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function Jk(e){var t=Dx(),r=e.focusedElem,o=e.selectionRange;if(t!==r&&r&&r.ownerDocument&&Ox(r.ownerDocument.documentElement,r)){if(o!==null&&aw(r)){if(t=o.start,e=o.end,e===void 0&&(e=t),"selectionStart"in r)r.selectionStart=t,r.selectionEnd=Math.min(e,r.value.length);else if(e=(t=r.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var a=r.textContent.length,l=Math.min(o.start,a);o=o.end===void 0?l:Math.min(o.end,a),!e.extend&&l>o&&(a=o,o=l,l=a),a=Ab(r,l);var p=Ab(r,o);a&&p&&(e.rangeCount!==1||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==p.node||e.focusOffset!==p.offset)&&(t=t.createRange(),t.setStart(a.node,a.offset),e.removeAllRanges(),l>o?(e.addRange(t),e.extend(p.node,p.offset)):(t.setEnd(p.node,p.offset),e.addRange(t)))}}for(t=[],e=r;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof r.focus=="function"&&r.focus(),r=0;r<t.length;r++)e=t[r],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Zk=os&&"documentMode"in document&&11>=document.documentMode,Ou=null,r0=null,qf=null,i0=!1;function Fb(e,t,r){var o=r.window===r?r.document:r.nodeType===9?r:r.ownerDocument;i0||Ou==null||Ou!==rg(o)||(o=Ou,"selectionStart"in o&&aw(o)?o={start:o.selectionStart,end:o.selectionEnd}:(o=(o.ownerDocument&&o.ownerDocument.defaultView||window).getSelection(),o={anchorNode:o.anchorNode,anchorOffset:o.anchorOffset,focusNode:o.focusNode,focusOffset:o.focusOffset}),qf&&ih(qf,o)||(qf=o,o=cg(r0,"onSelect"),0<o.length&&(t=new iw("onSelect","select",null,t,r),e.push({event:t,listeners:o}),t.target=Ou)))}function $m(e,t){var r={};return r[e.toLowerCase()]=t.toLowerCase(),r["Webkit"+e]="webkit"+t,r["Moz"+e]="moz"+t,r}var Du={animationend:$m("Animation","AnimationEnd"),animationiteration:$m("Animation","AnimationIteration"),animationstart:$m("Animation","AnimationStart"),transitionend:$m("Transition","TransitionEnd")},iy={},zx={};os&&(zx=document.createElement("div").style,"AnimationEvent"in window||(delete Du.animationend.animation,delete Du.animationiteration.animation,delete Du.animationstart.animation),"TransitionEvent"in window||delete Du.transitionend.transition);function Dg(e){if(iy[e])return iy[e];if(!Du[e])return e;var t=Du[e],r;for(r in t)if(t.hasOwnProperty(r)&&r in zx)return iy[e]=t[r];return e}var Lx=Dg("animationend"),Rx=Dg("animationiteration"),Bx=Dg("animationstart"),Nx=Dg("transitionend"),Ux=new Map,Ib="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Zs(e,t){Ux.set(e,t),Wa(t,[e])}for(var oy=0;oy<Ib.length;oy++){var sy=Ib[oy],eC=sy.toLowerCase(),tC=sy[0].toUpperCase()+sy.slice(1);Zs(eC,"on"+tC)}Zs(Lx,"onAnimationEnd");Zs(Rx,"onAnimationIteration");Zs(Bx,"onAnimationStart");Zs("dblclick","onDoubleClick");Zs("focusin","onFocus");Zs("focusout","onBlur");Zs(Nx,"onTransitionEnd");Xu("onMouseEnter",["mouseout","mouseover"]);Xu("onMouseLeave",["mouseout","mouseover"]);Xu("onPointerEnter",["pointerout","pointerover"]);Xu("onPointerLeave",["pointerout","pointerover"]);Wa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Wa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Wa("onBeforeInput",["compositionend","keypress","textInput","paste"]);Wa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Wa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Wa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Bf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),nC=new Set("cancel close invalid load scroll toggle".split(" ").concat(Bf));function Ob(e,t,r){var o=e.type||"unknown-event";e.currentTarget=r,ek(o,t,void 0,e),e.currentTarget=null}function jx(e,t){t=(t&4)!==0;for(var r=0;r<e.length;r++){var o=e[r],a=o.event;o=o.listeners;e:{var l=void 0;if(t)for(var p=o.length-1;0<=p;p--){var w=o[p],_=w.instance,y=w.currentTarget;if(w=w.listener,_!==l&&a.isPropagationStopped())break e;Ob(a,w,y),l=_}else for(p=0;p<o.length;p++){if(w=o[p],_=w.instance,y=w.currentTarget,w=w.listener,_!==l&&a.isPropagationStopped())break e;Ob(a,w,y),l=_}}}if(og)throw e=Zy,og=!1,Zy=null,e}function cr(e,t){var r=t[u0];r===void 0&&(r=t[u0]=new Set);var o=e+"__bubble";r.has(o)||(Vx(t,e,2,!1),r.add(o))}function ay(e,t,r){var o=0;t&&(o|=4),Vx(r,e,o,t)}var Am="_reactListening"+Math.random().toString(36).slice(2);function oh(e){if(!e[Am]){e[Am]=!0,QM.forEach(function(r){r!=="selectionchange"&&(nC.has(r)||ay(r,!1,e),ay(r,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Am]||(t[Am]=!0,ay("selectionchange",!1,t))}}function Vx(e,t,r,o){switch(Ex(t)){case 1:var a=gk;break;case 4:a=_k;break;default:a=nw}r=a.bind(null,t,r,e),a=void 0,!Jy||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(a=!0),o?a!==void 0?e.addEventListener(t,r,{capture:!0,passive:a}):e.addEventListener(t,r,!0):a!==void 0?e.addEventListener(t,r,{passive:a}):e.addEventListener(t,r,!1)}function ly(e,t,r,o,a){var l=o;if(!(t&1)&&!(t&2)&&o!==null)e:for(;;){if(o===null)return;var p=o.tag;if(p===3||p===4){var w=o.stateNode.containerInfo;if(w===a||w.nodeType===8&&w.parentNode===a)break;if(p===4)for(p=o.return;p!==null;){var _=p.tag;if((_===3||_===4)&&(_=p.stateNode.containerInfo,_===a||_.nodeType===8&&_.parentNode===a))return;p=p.return}for(;w!==null;){if(p=Aa(w),p===null)return;if(_=p.tag,_===5||_===6){o=l=p;continue e}w=w.parentNode}}o=o.return}px(function(){var y=l,T=J0(r),E=[];e:{var A=Ux.get(e);if(A!==void 0){var H=iw,W=e;switch(e){case"keypress":if(Wm(r)===0)break e;case"keydown":case"keyup":H=Fk;break;case"focusin":W="focus",H=ty;break;case"focusout":W="blur",H=ty;break;case"beforeblur":case"afterblur":H=ty;break;case"click":if(r.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":H=Mb;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":H=vk;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":H=Dk;break;case Lx:case Rx:case Bx:H=xk;break;case Nx:H=Lk;break;case"scroll":H=yk;break;case"wheel":H=Bk;break;case"copy":case"cut":case"paste":H=Sk;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":H=Tb}var Y=(t&4)!==0,B=!Y&&e==="scroll",F=Y?A!==null?A+"Capture":null:A;Y=[];for(var O=y,P;O!==null;){P=O;var j=P.stateNode;if(P.tag===5&&j!==null&&(P=j,F!==null&&(j=Zf(O,F),j!=null&&Y.push(sh(O,j,P)))),B)break;O=O.return}0<Y.length&&(A=new H(A,W,null,r,T),E.push({event:A,listeners:Y}))}}if(!(t&7)){e:{if(A=e==="mouseover"||e==="pointerover",H=e==="mouseout"||e==="pointerout",A&&r!==Qy&&(W=r.relatedTarget||r.fromElement)&&(Aa(W)||W[ss]))break e;if((H||A)&&(A=T.window===T?T:(A=T.ownerDocument)?A.defaultView||A.parentWindow:window,H?(W=r.relatedTarget||r.toElement,H=y,W=W?Aa(W):null,W!==null&&(B=Ga(W),W!==B||W.tag!==5&&W.tag!==6)&&(W=null)):(H=null,W=y),H!==W)){if(Y=Mb,j="onMouseLeave",F="onMouseEnter",O="mouse",(e==="pointerout"||e==="pointerover")&&(Y=Tb,j="onPointerLeave",F="onPointerEnter",O="pointer"),B=H==null?A:zu(H),P=W==null?A:zu(W),A=new Y(j,O+"leave",H,r,T),A.target=B,A.relatedTarget=P,j=null,Aa(T)===y&&(Y=new Y(F,O+"enter",W,r,T),Y.target=P,Y.relatedTarget=B,j=Y),B=j,H&&W)t:{for(Y=H,F=W,O=0,P=Y;P;P=Pu(P))O++;for(P=0,j=F;j;j=Pu(j))P++;for(;0<O-P;)Y=Pu(Y),O--;for(;0<P-O;)F=Pu(F),P--;for(;O--;){if(Y===F||F!==null&&Y===F.alternate)break t;Y=Pu(Y),F=Pu(F)}Y=null}else Y=null;H!==null&&Db(E,A,H,Y,!1),W!==null&&B!==null&&Db(E,B,W,Y,!0)}}e:{if(A=y?zu(y):window,H=A.nodeName&&A.nodeName.toLowerCase(),H==="select"||H==="input"&&A.type==="file")var V=qk;else if(kb(A))if(Fx)V=Qk;else{V=Kk;var z=Hk}else(H=A.nodeName)&&H.toLowerCase()==="input"&&(A.type==="checkbox"||A.type==="radio")&&(V=Xk);if(V&&(V=V(e,y))){Ax(E,V,r,T);break e}z&&z(e,A,y),e==="focusout"&&(z=A._wrapperState)&&z.controlled&&A.type==="number"&&Gy(A,"number",A.value)}switch(z=y?zu(y):window,e){case"focusin":(kb(z)||z.contentEditable==="true")&&(Ou=z,r0=y,qf=null);break;case"focusout":qf=r0=Ou=null;break;case"mousedown":i0=!0;break;case"contextmenu":case"mouseup":case"dragend":i0=!1,Fb(E,r,T);break;case"selectionchange":if(Zk)break;case"keydown":case"keyup":Fb(E,r,T)}var q;if(sw)e:{switch(e){case"compositionstart":var L="onCompositionStart";break e;case"compositionend":L="onCompositionEnd";break e;case"compositionupdate":L="onCompositionUpdate";break e}L=void 0}else Iu?Px(e,r)&&(L="onCompositionEnd"):e==="keydown"&&r.keyCode===229&&(L="onCompositionStart");L&&(Cx&&r.locale!=="ko"&&(Iu||L!=="onCompositionStart"?L==="onCompositionEnd"&&Iu&&(q=kx()):(Us=T,rw="value"in Us?Us.value:Us.textContent,Iu=!0)),z=cg(y,L),0<z.length&&(L=new xb(L,e,null,r,T),E.push({event:L,listeners:z}),q?L.data=q:(q=$x(r),q!==null&&(L.data=q)))),(q=Uk?jk(e,r):Vk(e,r))&&(y=cg(y,"onBeforeInput"),0<y.length&&(T=new xb("onBeforeInput","beforeinput",null,r,T),E.push({event:T,listeners:y}),T.data=q))}jx(E,t)})}function sh(e,t,r){return{instance:e,listener:t,currentTarget:r}}function cg(e,t){for(var r=t+"Capture",o=[];e!==null;){var a=e,l=a.stateNode;a.tag===5&&l!==null&&(a=l,l=Zf(e,r),l!=null&&o.unshift(sh(e,l,a)),l=Zf(e,t),l!=null&&o.push(sh(e,l,a))),e=e.return}return o}function Pu(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function Db(e,t,r,o,a){for(var l=t._reactName,p=[];r!==null&&r!==o;){var w=r,_=w.alternate,y=w.stateNode;if(_!==null&&_===o)break;w.tag===5&&y!==null&&(w=y,a?(_=Zf(r,l),_!=null&&p.unshift(sh(r,_,w))):a||(_=Zf(r,l),_!=null&&p.push(sh(r,_,w)))),r=r.return}p.length!==0&&e.push({event:t,listeners:p})}var rC=/\r\n?/g,iC=/\u0000|\uFFFD/g;function zb(e){return(typeof e=="string"?e:""+e).replace(rC,`
`).replace(iC,"")}function Fm(e,t,r){if(t=zb(t),zb(e)!==t&&r)throw Error(Et(425))}function dg(){}var o0=null,s0=null;function a0(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var l0=typeof setTimeout=="function"?setTimeout:void 0,oC=typeof clearTimeout=="function"?clearTimeout:void 0,Lb=typeof Promise=="function"?Promise:void 0,sC=typeof queueMicrotask=="function"?queueMicrotask:typeof Lb<"u"?function(e){return Lb.resolve(null).then(e).catch(aC)}:l0;function aC(e){setTimeout(function(){throw e})}function uy(e,t){var r=t,o=0;do{var a=r.nextSibling;if(e.removeChild(r),a&&a.nodeType===8)if(r=a.data,r==="/$"){if(o===0){e.removeChild(a),nh(t);return}o--}else r!=="$"&&r!=="$?"&&r!=="$!"||o++;r=a}while(r);nh(t)}function qs(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function Rb(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var r=e.data;if(r==="$"||r==="$!"||r==="$?"){if(t===0)return e;t--}else r==="/$"&&t++}e=e.previousSibling}return null}var oc=Math.random().toString(36).slice(2),Ao="__reactFiber$"+oc,ah="__reactProps$"+oc,ss="__reactContainer$"+oc,u0="__reactEvents$"+oc,lC="__reactListeners$"+oc,uC="__reactHandles$"+oc;function Aa(e){var t=e[Ao];if(t)return t;for(var r=e.parentNode;r;){if(t=r[ss]||r[Ao]){if(r=t.alternate,t.child!==null||r!==null&&r.child!==null)for(e=Rb(e);e!==null;){if(r=e[Ao])return r;e=Rb(e)}return t}e=r,r=e.parentNode}return null}function yh(e){return e=e[Ao]||e[ss],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function zu(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(Et(33))}function zg(e){return e[ah]||null}var c0=[],Lu=-1;function ea(e){return{current:e}}function dr(e){0>Lu||(e.current=c0[Lu],c0[Lu]=null,Lu--)}function sr(e,t){Lu++,c0[Lu]=e.current,e.current=t}var Js={},oi=ea(Js),xi=ea(!1),Ba=Js;function Qu(e,t){var r=e.type.contextTypes;if(!r)return Js;var o=e.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===t)return o.__reactInternalMemoizedMaskedChildContext;var a={},l;for(l in r)a[l]=t[l];return o&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function Ti(e){return e=e.childContextTypes,e!=null}function pg(){dr(xi),dr(oi)}function Bb(e,t,r){if(oi.current!==Js)throw Error(Et(168));sr(oi,t),sr(xi,r)}function Wx(e,t,r){var o=e.stateNode;if(t=t.childContextTypes,typeof o.getChildContext!="function")return r;o=o.getChildContext();for(var a in o)if(!(a in t))throw Error(Et(108,HE(e)||"Unknown",a));return br({},r,o)}function fg(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Js,Ba=oi.current,sr(oi,e),sr(xi,xi.current),!0}function Nb(e,t,r){var o=e.stateNode;if(!o)throw Error(Et(169));r?(e=Wx(e,t,Ba),o.__reactInternalMemoizedMergedChildContext=e,dr(xi),dr(oi),sr(oi,e)):dr(xi),sr(xi,r)}var Jo=null,Lg=!1,cy=!1;function Gx(e){Jo===null?Jo=[e]:Jo.push(e)}function cC(e){Lg=!0,Gx(e)}function ta(){if(!cy&&Jo!==null){cy=!0;var e=0,t=nr;try{var r=Jo;for(nr=1;e<r.length;e++){var o=r[e];do o=o(!0);while(o!==null)}Jo=null,Lg=!1}catch(a){throw Jo!==null&&(Jo=Jo.slice(e+1)),gx(Z0,ta),a}finally{nr=t,cy=!1}}return null}var Ru=[],Bu=0,hg=null,mg=0,Vi=[],Wi=0,Na=null,Zo=1,es="";function Ca(e,t){Ru[Bu++]=mg,Ru[Bu++]=hg,hg=e,mg=t}function qx(e,t,r){Vi[Wi++]=Zo,Vi[Wi++]=es,Vi[Wi++]=Na,Na=e;var o=Zo;e=es;var a=32-ho(o)-1;o&=~(1<<a),r+=1;var l=32-ho(t)+a;if(30<l){var p=a-a%5;l=(o&(1<<p)-1).toString(32),o>>=p,a-=p,Zo=1<<32-ho(t)+a|r<<a|o,es=l+e}else Zo=1<<l|r<<a|o,es=e}function lw(e){e.return!==null&&(Ca(e,1),qx(e,1,0))}function uw(e){for(;e===hg;)hg=Ru[--Bu],Ru[Bu]=null,mg=Ru[--Bu],Ru[Bu]=null;for(;e===Na;)Na=Vi[--Wi],Vi[Wi]=null,es=Vi[--Wi],Vi[Wi]=null,Zo=Vi[--Wi],Vi[Wi]=null}var Ai=null,$i=null,hr=!1,po=null;function Hx(e,t){var r=Gi(5,null,null,0);r.elementType="DELETED",r.stateNode=t,r.return=e,t=e.deletions,t===null?(e.deletions=[r],e.flags|=16):t.push(r)}function Ub(e,t){switch(e.tag){case 5:var r=e.type;return t=t.nodeType!==1||r.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,Ai=e,$i=qs(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,Ai=e,$i=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(r=Na!==null?{id:Zo,overflow:es}:null,e.memoizedState={dehydrated:t,treeContext:r,retryLane:1073741824},r=Gi(18,null,null,0),r.stateNode=t,r.return=e,e.child=r,Ai=e,$i=null,!0):!1;default:return!1}}function d0(e){return(e.mode&1)!==0&&(e.flags&128)===0}function p0(e){if(hr){var t=$i;if(t){var r=t;if(!Ub(e,t)){if(d0(e))throw Error(Et(418));t=qs(r.nextSibling);var o=Ai;t&&Ub(e,t)?Hx(o,r):(e.flags=e.flags&-4097|2,hr=!1,Ai=e)}}else{if(d0(e))throw Error(Et(418));e.flags=e.flags&-4097|2,hr=!1,Ai=e}}}function jb(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Ai=e}function Im(e){if(e!==Ai)return!1;if(!hr)return jb(e),hr=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!a0(e.type,e.memoizedProps)),t&&(t=$i)){if(d0(e))throw Kx(),Error(Et(418));for(;t;)Hx(e,t),t=qs(t.nextSibling)}if(jb(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(Et(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var r=e.data;if(r==="/$"){if(t===0){$i=qs(e.nextSibling);break e}t--}else r!=="$"&&r!=="$!"&&r!=="$?"||t++}e=e.nextSibling}$i=null}}else $i=Ai?qs(e.stateNode.nextSibling):null;return!0}function Kx(){for(var e=$i;e;)e=qs(e.nextSibling)}function Yu(){$i=Ai=null,hr=!1}function cw(e){po===null?po=[e]:po.push(e)}var dC=us.ReactCurrentBatchConfig;function uo(e,t){if(e&&e.defaultProps){t=br({},t),e=e.defaultProps;for(var r in e)t[r]===void 0&&(t[r]=e[r]);return t}return t}var gg=ea(null),_g=null,Nu=null,dw=null;function pw(){dw=Nu=_g=null}function fw(e){var t=gg.current;dr(gg),e._currentValue=t}function f0(e,t,r){for(;e!==null;){var o=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,o!==null&&(o.childLanes|=t)):o!==null&&(o.childLanes&t)!==t&&(o.childLanes|=t),e===r)break;e=e.return}}function Hu(e,t){_g=e,dw=Nu=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(Mi=!0),e.firstContext=null)}function Xi(e){var t=e._currentValue;if(dw!==e)if(e={context:e,memoizedValue:t,next:null},Nu===null){if(_g===null)throw Error(Et(308));Nu=e,_g.dependencies={lanes:0,firstContext:e}}else Nu=Nu.next=e;return t}var Fa=null;function hw(e){Fa===null?Fa=[e]:Fa.push(e)}function Xx(e,t,r,o){var a=t.interleaved;return a===null?(r.next=r,hw(t)):(r.next=a.next,a.next=r),t.interleaved=r,as(e,o)}function as(e,t){e.lanes|=t;var r=e.alternate;for(r!==null&&(r.lanes|=t),r=e,e=e.return;e!==null;)e.childLanes|=t,r=e.alternate,r!==null&&(r.childLanes|=t),r=e,e=e.return;return r.tag===3?r.stateNode:null}var Ls=!1;function mw(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Qx(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function ns(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Hs(e,t,r){var o=e.updateQueue;if(o===null)return null;if(o=o.shared,Kn&2){var a=o.pending;return a===null?t.next=t:(t.next=a.next,a.next=t),o.pending=t,as(e,r)}return a=o.interleaved,a===null?(t.next=t,hw(o)):(t.next=a.next,a.next=t),o.interleaved=t,as(e,r)}function Gm(e,t,r){if(t=t.updateQueue,t!==null&&(t=t.shared,(r&4194240)!==0)){var o=t.lanes;o&=e.pendingLanes,r|=o,t.lanes=r,ew(e,r)}}function Vb(e,t){var r=e.updateQueue,o=e.alternate;if(o!==null&&(o=o.updateQueue,r===o)){var a=null,l=null;if(r=r.firstBaseUpdate,r!==null){do{var p={eventTime:r.eventTime,lane:r.lane,tag:r.tag,payload:r.payload,callback:r.callback,next:null};l===null?a=l=p:l=l.next=p,r=r.next}while(r!==null);l===null?a=l=t:l=l.next=t}else a=l=t;r={baseState:o.baseState,firstBaseUpdate:a,lastBaseUpdate:l,shared:o.shared,effects:o.effects},e.updateQueue=r;return}e=r.lastBaseUpdate,e===null?r.firstBaseUpdate=t:e.next=t,r.lastBaseUpdate=t}function yg(e,t,r,o){var a=e.updateQueue;Ls=!1;var l=a.firstBaseUpdate,p=a.lastBaseUpdate,w=a.shared.pending;if(w!==null){a.shared.pending=null;var _=w,y=_.next;_.next=null,p===null?l=y:p.next=y,p=_;var T=e.alternate;T!==null&&(T=T.updateQueue,w=T.lastBaseUpdate,w!==p&&(w===null?T.firstBaseUpdate=y:w.next=y,T.lastBaseUpdate=_))}if(l!==null){var E=a.baseState;p=0,T=y=_=null,w=l;do{var A=w.lane,H=w.eventTime;if((o&A)===A){T!==null&&(T=T.next={eventTime:H,lane:0,tag:w.tag,payload:w.payload,callback:w.callback,next:null});e:{var W=e,Y=w;switch(A=t,H=r,Y.tag){case 1:if(W=Y.payload,typeof W=="function"){E=W.call(H,E,A);break e}E=W;break e;case 3:W.flags=W.flags&-65537|128;case 0:if(W=Y.payload,A=typeof W=="function"?W.call(H,E,A):W,A==null)break e;E=br({},E,A);break e;case 2:Ls=!0}}w.callback!==null&&w.lane!==0&&(e.flags|=64,A=a.effects,A===null?a.effects=[w]:A.push(w))}else H={eventTime:H,lane:A,tag:w.tag,payload:w.payload,callback:w.callback,next:null},T===null?(y=T=H,_=E):T=T.next=H,p|=A;if(w=w.next,w===null){if(w=a.shared.pending,w===null)break;A=w,w=A.next,A.next=null,a.lastBaseUpdate=A,a.shared.pending=null}}while(!0);if(T===null&&(_=E),a.baseState=_,a.firstBaseUpdate=y,a.lastBaseUpdate=T,t=a.shared.interleaved,t!==null){a=t;do p|=a.lane,a=a.next;while(a!==t)}else l===null&&(a.shared.lanes=0);ja|=p,e.lanes=p,e.memoizedState=E}}function Wb(e,t,r){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var o=e[t],a=o.callback;if(a!==null){if(o.callback=null,o=r,typeof a!="function")throw Error(Et(191,a));a.call(o)}}}var Yx=new XM.Component().refs;function h0(e,t,r,o){t=e.memoizedState,r=r(o,t),r=r==null?t:br({},t,r),e.memoizedState=r,e.lanes===0&&(e.updateQueue.baseState=r)}var Rg={isMounted:function(e){return(e=e._reactInternals)?Ga(e)===e:!1},enqueueSetState:function(e,t,r){e=e._reactInternals;var o=di(),a=Xs(e),l=ns(o,a);l.payload=t,r!=null&&(l.callback=r),t=Hs(e,l,a),t!==null&&(mo(t,e,a,o),Gm(t,e,a))},enqueueReplaceState:function(e,t,r){e=e._reactInternals;var o=di(),a=Xs(e),l=ns(o,a);l.tag=1,l.payload=t,r!=null&&(l.callback=r),t=Hs(e,l,a),t!==null&&(mo(t,e,a,o),Gm(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var r=di(),o=Xs(e),a=ns(r,o);a.tag=2,t!=null&&(a.callback=t),t=Hs(e,a,o),t!==null&&(mo(t,e,o,r),Gm(t,e,o))}};function Gb(e,t,r,o,a,l,p){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(o,l,p):t.prototype&&t.prototype.isPureReactComponent?!ih(r,o)||!ih(a,l):!0}function Jx(e,t,r){var o=!1,a=Js,l=t.contextType;return typeof l=="object"&&l!==null?l=Xi(l):(a=Ti(t)?Ba:oi.current,o=t.contextTypes,l=(o=o!=null)?Qu(e,a):Js),t=new t(r,l),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=Rg,e.stateNode=t,t._reactInternals=e,o&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=l),t}function qb(e,t,r,o){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(r,o),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(r,o),t.state!==e&&Rg.enqueueReplaceState(t,t.state,null)}function m0(e,t,r,o){var a=e.stateNode;a.props=r,a.state=e.memoizedState,a.refs=Yx,mw(e);var l=t.contextType;typeof l=="object"&&l!==null?a.context=Xi(l):(l=Ti(t)?Ba:oi.current,a.context=Qu(e,l)),a.state=e.memoizedState,l=t.getDerivedStateFromProps,typeof l=="function"&&(h0(e,t,l,r),a.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof a.getSnapshotBeforeUpdate=="function"||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(t=a.state,typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount(),t!==a.state&&Rg.enqueueReplaceState(a,a.state,null),yg(e,r,a,o),a.state=e.memoizedState),typeof a.componentDidMount=="function"&&(e.flags|=4194308)}function Pf(e,t,r){if(e=r.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(r._owner){if(r=r._owner,r){if(r.tag!==1)throw Error(Et(309));var o=r.stateNode}if(!o)throw Error(Et(147,e));var a=o,l=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===l?t.ref:(t=function(p){var w=a.refs;w===Yx&&(w=a.refs={}),p===null?delete w[l]:w[l]=p},t._stringRef=l,t)}if(typeof e!="string")throw Error(Et(284));if(!r._owner)throw Error(Et(290,e))}return e}function Om(e,t){throw e=Object.prototype.toString.call(t),Error(Et(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Hb(e){var t=e._init;return t(e._payload)}function Zx(e){function t(F,O){if(e){var P=F.deletions;P===null?(F.deletions=[O],F.flags|=16):P.push(O)}}function r(F,O){if(!e)return null;for(;O!==null;)t(F,O),O=O.sibling;return null}function o(F,O){for(F=new Map;O!==null;)O.key!==null?F.set(O.key,O):F.set(O.index,O),O=O.sibling;return F}function a(F,O){return F=Qs(F,O),F.index=0,F.sibling=null,F}function l(F,O,P){return F.index=P,e?(P=F.alternate,P!==null?(P=P.index,P<O?(F.flags|=2,O):P):(F.flags|=2,O)):(F.flags|=1048576,O)}function p(F){return e&&F.alternate===null&&(F.flags|=2),F}function w(F,O,P,j){return O===null||O.tag!==6?(O=_y(P,F.mode,j),O.return=F,O):(O=a(O,P),O.return=F,O)}function _(F,O,P,j){var V=P.type;return V===Fu?T(F,O,P.props.children,j,P.key):O!==null&&(O.elementType===V||typeof V=="object"&&V!==null&&V.$$typeof===zs&&Hb(V)===O.type)?(j=a(O,P.props),j.ref=Pf(F,O,P),j.return=F,j):(j=Ym(P.type,P.key,P.props,null,F.mode,j),j.ref=Pf(F,O,P),j.return=F,j)}function y(F,O,P,j){return O===null||O.tag!==4||O.stateNode.containerInfo!==P.containerInfo||O.stateNode.implementation!==P.implementation?(O=yy(P,F.mode,j),O.return=F,O):(O=a(O,P.children||[]),O.return=F,O)}function T(F,O,P,j,V){return O===null||O.tag!==7?(O=za(P,F.mode,j,V),O.return=F,O):(O=a(O,P),O.return=F,O)}function E(F,O,P){if(typeof O=="string"&&O!==""||typeof O=="number")return O=_y(""+O,F.mode,P),O.return=F,O;if(typeof O=="object"&&O!==null){switch(O.$$typeof){case xm:return P=Ym(O.type,O.key,O.props,null,F.mode,P),P.ref=Pf(F,null,O),P.return=F,P;case Au:return O=yy(O,F.mode,P),O.return=F,O;case zs:var j=O._init;return E(F,j(O._payload),P)}if(Lf(O)||Tf(O))return O=za(O,F.mode,P,null),O.return=F,O;Om(F,O)}return null}function A(F,O,P,j){var V=O!==null?O.key:null;if(typeof P=="string"&&P!==""||typeof P=="number")return V!==null?null:w(F,O,""+P,j);if(typeof P=="object"&&P!==null){switch(P.$$typeof){case xm:return P.key===V?_(F,O,P,j):null;case Au:return P.key===V?y(F,O,P,j):null;case zs:return V=P._init,A(F,O,V(P._payload),j)}if(Lf(P)||Tf(P))return V!==null?null:T(F,O,P,j,null);Om(F,P)}return null}function H(F,O,P,j,V){if(typeof j=="string"&&j!==""||typeof j=="number")return F=F.get(P)||null,w(O,F,""+j,V);if(typeof j=="object"&&j!==null){switch(j.$$typeof){case xm:return F=F.get(j.key===null?P:j.key)||null,_(O,F,j,V);case Au:return F=F.get(j.key===null?P:j.key)||null,y(O,F,j,V);case zs:var z=j._init;return H(F,O,P,z(j._payload),V)}if(Lf(j)||Tf(j))return F=F.get(P)||null,T(O,F,j,V,null);Om(O,j)}return null}function W(F,O,P,j){for(var V=null,z=null,q=O,L=O=0,pe=null;q!==null&&L<P.length;L++){q.index>L?(pe=q,q=null):pe=q.sibling;var fe=A(F,q,P[L],j);if(fe===null){q===null&&(q=pe);break}e&&q&&fe.alternate===null&&t(F,q),O=l(fe,O,L),z===null?V=fe:z.sibling=fe,z=fe,q=pe}if(L===P.length)return r(F,q),hr&&Ca(F,L),V;if(q===null){for(;L<P.length;L++)q=E(F,P[L],j),q!==null&&(O=l(q,O,L),z===null?V=q:z.sibling=q,z=q);return hr&&Ca(F,L),V}for(q=o(F,q);L<P.length;L++)pe=H(q,F,L,P[L],j),pe!==null&&(e&&pe.alternate!==null&&q.delete(pe.key===null?L:pe.key),O=l(pe,O,L),z===null?V=pe:z.sibling=pe,z=pe);return e&&q.forEach(function(xe){return t(F,xe)}),hr&&Ca(F,L),V}function Y(F,O,P,j){var V=Tf(P);if(typeof V!="function")throw Error(Et(150));if(P=V.call(P),P==null)throw Error(Et(151));for(var z=V=null,q=O,L=O=0,pe=null,fe=P.next();q!==null&&!fe.done;L++,fe=P.next()){q.index>L?(pe=q,q=null):pe=q.sibling;var xe=A(F,q,fe.value,j);if(xe===null){q===null&&(q=pe);break}e&&q&&xe.alternate===null&&t(F,q),O=l(xe,O,L),z===null?V=xe:z.sibling=xe,z=xe,q=pe}if(fe.done)return r(F,q),hr&&Ca(F,L),V;if(q===null){for(;!fe.done;L++,fe=P.next())fe=E(F,fe.value,j),fe!==null&&(O=l(fe,O,L),z===null?V=fe:z.sibling=fe,z=fe);return hr&&Ca(F,L),V}for(q=o(F,q);!fe.done;L++,fe=P.next())fe=H(q,F,L,fe.value,j),fe!==null&&(e&&fe.alternate!==null&&q.delete(fe.key===null?L:fe.key),O=l(fe,O,L),z===null?V=fe:z.sibling=fe,z=fe);return e&&q.forEach(function($e){return t(F,$e)}),hr&&Ca(F,L),V}function B(F,O,P,j){if(typeof P=="object"&&P!==null&&P.type===Fu&&P.key===null&&(P=P.props.children),typeof P=="object"&&P!==null){switch(P.$$typeof){case xm:e:{for(var V=P.key,z=O;z!==null;){if(z.key===V){if(V=P.type,V===Fu){if(z.tag===7){r(F,z.sibling),O=a(z,P.props.children),O.return=F,F=O;break e}}else if(z.elementType===V||typeof V=="object"&&V!==null&&V.$$typeof===zs&&Hb(V)===z.type){r(F,z.sibling),O=a(z,P.props),O.ref=Pf(F,z,P),O.return=F,F=O;break e}r(F,z);break}else t(F,z);z=z.sibling}P.type===Fu?(O=za(P.props.children,F.mode,j,P.key),O.return=F,F=O):(j=Ym(P.type,P.key,P.props,null,F.mode,j),j.ref=Pf(F,O,P),j.return=F,F=j)}return p(F);case Au:e:{for(z=P.key;O!==null;){if(O.key===z)if(O.tag===4&&O.stateNode.containerInfo===P.containerInfo&&O.stateNode.implementation===P.implementation){r(F,O.sibling),O=a(O,P.children||[]),O.return=F,F=O;break e}else{r(F,O);break}else t(F,O);O=O.sibling}O=yy(P,F.mode,j),O.return=F,F=O}return p(F);case zs:return z=P._init,B(F,O,z(P._payload),j)}if(Lf(P))return W(F,O,P,j);if(Tf(P))return Y(F,O,P,j);Om(F,P)}return typeof P=="string"&&P!==""||typeof P=="number"?(P=""+P,O!==null&&O.tag===6?(r(F,O.sibling),O=a(O,P),O.return=F,F=O):(r(F,O),O=_y(P,F.mode,j),O.return=F,F=O),p(F)):r(F,O)}return B}var Ju=Zx(!0),eT=Zx(!1),wh={},Do=ea(wh),lh=ea(wh),uh=ea(wh);function Ia(e){if(e===wh)throw Error(Et(174));return e}function gw(e,t){switch(sr(uh,t),sr(lh,e),sr(Do,wh),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:Hy(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=Hy(t,e)}dr(Do),sr(Do,t)}function Zu(){dr(Do),dr(lh),dr(uh)}function tT(e){Ia(uh.current);var t=Ia(Do.current),r=Hy(t,e.type);t!==r&&(sr(lh,e),sr(Do,r))}function _w(e){lh.current===e&&(dr(Do),dr(lh))}var wr=ea(0);function wg(e){for(var t=e;t!==null;){if(t.tag===13){var r=t.memoizedState;if(r!==null&&(r=r.dehydrated,r===null||r.data==="$?"||r.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var dy=[];function yw(){for(var e=0;e<dy.length;e++)dy[e]._workInProgressVersionPrimary=null;dy.length=0}var qm=us.ReactCurrentDispatcher,py=us.ReactCurrentBatchConfig,Ua=0,vr=null,Lr=null,Wr=null,vg=!1,Hf=!1,ch=0,pC=0;function ti(){throw Error(Et(321))}function ww(e,t){if(t===null)return!1;for(var r=0;r<t.length&&r<e.length;r++)if(!go(e[r],t[r]))return!1;return!0}function vw(e,t,r,o,a,l){if(Ua=l,vr=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,qm.current=e===null||e.memoizedState===null?gC:_C,e=r(o,a),Hf){l=0;do{if(Hf=!1,ch=0,25<=l)throw Error(Et(301));l+=1,Wr=Lr=null,t.updateQueue=null,qm.current=yC,e=r(o,a)}while(Hf)}if(qm.current=bg,t=Lr!==null&&Lr.next!==null,Ua=0,Wr=Lr=vr=null,vg=!1,t)throw Error(Et(300));return e}function bw(){var e=ch!==0;return ch=0,e}function $o(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Wr===null?vr.memoizedState=Wr=e:Wr=Wr.next=e,Wr}function Qi(){if(Lr===null){var e=vr.alternate;e=e!==null?e.memoizedState:null}else e=Lr.next;var t=Wr===null?vr.memoizedState:Wr.next;if(t!==null)Wr=t,Lr=e;else{if(e===null)throw Error(Et(310));Lr=e,e={memoizedState:Lr.memoizedState,baseState:Lr.baseState,baseQueue:Lr.baseQueue,queue:Lr.queue,next:null},Wr===null?vr.memoizedState=Wr=e:Wr=Wr.next=e}return Wr}function dh(e,t){return typeof t=="function"?t(e):t}function fy(e){var t=Qi(),r=t.queue;if(r===null)throw Error(Et(311));r.lastRenderedReducer=e;var o=Lr,a=o.baseQueue,l=r.pending;if(l!==null){if(a!==null){var p=a.next;a.next=l.next,l.next=p}o.baseQueue=a=l,r.pending=null}if(a!==null){l=a.next,o=o.baseState;var w=p=null,_=null,y=l;do{var T=y.lane;if((Ua&T)===T)_!==null&&(_=_.next={lane:0,action:y.action,hasEagerState:y.hasEagerState,eagerState:y.eagerState,next:null}),o=y.hasEagerState?y.eagerState:e(o,y.action);else{var E={lane:T,action:y.action,hasEagerState:y.hasEagerState,eagerState:y.eagerState,next:null};_===null?(w=_=E,p=o):_=_.next=E,vr.lanes|=T,ja|=T}y=y.next}while(y!==null&&y!==l);_===null?p=o:_.next=w,go(o,t.memoizedState)||(Mi=!0),t.memoizedState=o,t.baseState=p,t.baseQueue=_,r.lastRenderedState=o}if(e=r.interleaved,e!==null){a=e;do l=a.lane,vr.lanes|=l,ja|=l,a=a.next;while(a!==e)}else a===null&&(r.lanes=0);return[t.memoizedState,r.dispatch]}function hy(e){var t=Qi(),r=t.queue;if(r===null)throw Error(Et(311));r.lastRenderedReducer=e;var o=r.dispatch,a=r.pending,l=t.memoizedState;if(a!==null){r.pending=null;var p=a=a.next;do l=e(l,p.action),p=p.next;while(p!==a);go(l,t.memoizedState)||(Mi=!0),t.memoizedState=l,t.baseQueue===null&&(t.baseState=l),r.lastRenderedState=l}return[l,o]}function nT(){}function rT(e,t){var r=vr,o=Qi(),a=t(),l=!go(o.memoizedState,a);if(l&&(o.memoizedState=a,Mi=!0),o=o.queue,Mw(sT.bind(null,r,o,e),[e]),o.getSnapshot!==t||l||Wr!==null&&Wr.memoizedState.tag&1){if(r.flags|=2048,ph(9,oT.bind(null,r,o,a,t),void 0,null),qr===null)throw Error(Et(349));Ua&30||iT(r,t,a)}return a}function iT(e,t,r){e.flags|=16384,e={getSnapshot:t,value:r},t=vr.updateQueue,t===null?(t={lastEffect:null,stores:null},vr.updateQueue=t,t.stores=[e]):(r=t.stores,r===null?t.stores=[e]:r.push(e))}function oT(e,t,r,o){t.value=r,t.getSnapshot=o,aT(t)&&lT(e)}function sT(e,t,r){return r(function(){aT(t)&&lT(e)})}function aT(e){var t=e.getSnapshot;e=e.value;try{var r=t();return!go(e,r)}catch{return!0}}function lT(e){var t=as(e,1);t!==null&&mo(t,e,1,-1)}function Kb(e){var t=$o();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:dh,lastRenderedState:e},t.queue=e,e=e.dispatch=mC.bind(null,vr,e),[t.memoizedState,e]}function ph(e,t,r,o){return e={tag:e,create:t,destroy:r,deps:o,next:null},t=vr.updateQueue,t===null?(t={lastEffect:null,stores:null},vr.updateQueue=t,t.lastEffect=e.next=e):(r=t.lastEffect,r===null?t.lastEffect=e.next=e:(o=r.next,r.next=e,e.next=o,t.lastEffect=e)),e}function uT(){return Qi().memoizedState}function Hm(e,t,r,o){var a=$o();vr.flags|=e,a.memoizedState=ph(1|t,r,void 0,o===void 0?null:o)}function Bg(e,t,r,o){var a=Qi();o=o===void 0?null:o;var l=void 0;if(Lr!==null){var p=Lr.memoizedState;if(l=p.destroy,o!==null&&ww(o,p.deps)){a.memoizedState=ph(t,r,l,o);return}}vr.flags|=e,a.memoizedState=ph(1|t,r,l,o)}function Xb(e,t){return Hm(8390656,8,e,t)}function Mw(e,t){return Bg(2048,8,e,t)}function cT(e,t){return Bg(4,2,e,t)}function dT(e,t){return Bg(4,4,e,t)}function pT(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function fT(e,t,r){return r=r!=null?r.concat([e]):null,Bg(4,4,pT.bind(null,t,e),r)}function xw(){}function hT(e,t){var r=Qi();t=t===void 0?null:t;var o=r.memoizedState;return o!==null&&t!==null&&ww(t,o[1])?o[0]:(r.memoizedState=[e,t],e)}function mT(e,t){var r=Qi();t=t===void 0?null:t;var o=r.memoizedState;return o!==null&&t!==null&&ww(t,o[1])?o[0]:(e=e(),r.memoizedState=[e,t],e)}function gT(e,t,r){return Ua&21?(go(r,t)||(r=wx(),vr.lanes|=r,ja|=r,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,Mi=!0),e.memoizedState=r)}function fC(e,t){var r=nr;nr=r!==0&&4>r?r:4,e(!0);var o=py.transition;py.transition={};try{e(!1),t()}finally{nr=r,py.transition=o}}function _T(){return Qi().memoizedState}function hC(e,t,r){var o=Xs(e);if(r={lane:o,action:r,hasEagerState:!1,eagerState:null,next:null},yT(e))wT(t,r);else if(r=Xx(e,t,r,o),r!==null){var a=di();mo(r,e,o,a),vT(r,t,o)}}function mC(e,t,r){var o=Xs(e),a={lane:o,action:r,hasEagerState:!1,eagerState:null,next:null};if(yT(e))wT(t,a);else{var l=e.alternate;if(e.lanes===0&&(l===null||l.lanes===0)&&(l=t.lastRenderedReducer,l!==null))try{var p=t.lastRenderedState,w=l(p,r);if(a.hasEagerState=!0,a.eagerState=w,go(w,p)){var _=t.interleaved;_===null?(a.next=a,hw(t)):(a.next=_.next,_.next=a),t.interleaved=a;return}}catch{}finally{}r=Xx(e,t,a,o),r!==null&&(a=di(),mo(r,e,o,a),vT(r,t,o))}}function yT(e){var t=e.alternate;return e===vr||t!==null&&t===vr}function wT(e,t){Hf=vg=!0;var r=e.pending;r===null?t.next=t:(t.next=r.next,r.next=t),e.pending=t}function vT(e,t,r){if(r&4194240){var o=t.lanes;o&=e.pendingLanes,r|=o,t.lanes=r,ew(e,r)}}var bg={readContext:Xi,useCallback:ti,useContext:ti,useEffect:ti,useImperativeHandle:ti,useInsertionEffect:ti,useLayoutEffect:ti,useMemo:ti,useReducer:ti,useRef:ti,useState:ti,useDebugValue:ti,useDeferredValue:ti,useTransition:ti,useMutableSource:ti,useSyncExternalStore:ti,useId:ti,unstable_isNewReconciler:!1},gC={readContext:Xi,useCallback:function(e,t){return $o().memoizedState=[e,t===void 0?null:t],e},useContext:Xi,useEffect:Xb,useImperativeHandle:function(e,t,r){return r=r!=null?r.concat([e]):null,Hm(4194308,4,pT.bind(null,t,e),r)},useLayoutEffect:function(e,t){return Hm(4194308,4,e,t)},useInsertionEffect:function(e,t){return Hm(4,2,e,t)},useMemo:function(e,t){var r=$o();return t=t===void 0?null:t,e=e(),r.memoizedState=[e,t],e},useReducer:function(e,t,r){var o=$o();return t=r!==void 0?r(t):t,o.memoizedState=o.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},o.queue=e,e=e.dispatch=hC.bind(null,vr,e),[o.memoizedState,e]},useRef:function(e){var t=$o();return e={current:e},t.memoizedState=e},useState:Kb,useDebugValue:xw,useDeferredValue:function(e){return $o().memoizedState=e},useTransition:function(){var e=Kb(!1),t=e[0];return e=fC.bind(null,e[1]),$o().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,r){var o=vr,a=$o();if(hr){if(r===void 0)throw Error(Et(407));r=r()}else{if(r=t(),qr===null)throw Error(Et(349));Ua&30||iT(o,t,r)}a.memoizedState=r;var l={value:r,getSnapshot:t};return a.queue=l,Xb(sT.bind(null,o,l,e),[e]),o.flags|=2048,ph(9,oT.bind(null,o,l,r,t),void 0,null),r},useId:function(){var e=$o(),t=qr.identifierPrefix;if(hr){var r=es,o=Zo;r=(o&~(1<<32-ho(o)-1)).toString(32)+r,t=":"+t+"R"+r,r=ch++,0<r&&(t+="H"+r.toString(32)),t+=":"}else r=pC++,t=":"+t+"r"+r.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},_C={readContext:Xi,useCallback:hT,useContext:Xi,useEffect:Mw,useImperativeHandle:fT,useInsertionEffect:cT,useLayoutEffect:dT,useMemo:mT,useReducer:fy,useRef:uT,useState:function(){return fy(dh)},useDebugValue:xw,useDeferredValue:function(e){var t=Qi();return gT(t,Lr.memoizedState,e)},useTransition:function(){var e=fy(dh)[0],t=Qi().memoizedState;return[e,t]},useMutableSource:nT,useSyncExternalStore:rT,useId:_T,unstable_isNewReconciler:!1},yC={readContext:Xi,useCallback:hT,useContext:Xi,useEffect:Mw,useImperativeHandle:fT,useInsertionEffect:cT,useLayoutEffect:dT,useMemo:mT,useReducer:hy,useRef:uT,useState:function(){return hy(dh)},useDebugValue:xw,useDeferredValue:function(e){var t=Qi();return Lr===null?t.memoizedState=e:gT(t,Lr.memoizedState,e)},useTransition:function(){var e=hy(dh)[0],t=Qi().memoizedState;return[e,t]},useMutableSource:nT,useSyncExternalStore:rT,useId:_T,unstable_isNewReconciler:!1};function ec(e,t){try{var r="",o=t;do r+=qE(o),o=o.return;while(o);var a=r}catch(l){a=`
Error generating stack: `+l.message+`
`+l.stack}return{value:e,source:t,stack:a,digest:null}}function my(e,t,r){return{value:e,source:null,stack:r??null,digest:t??null}}function g0(e,t){try{console.error(t.value)}catch(r){setTimeout(function(){throw r})}}var wC=typeof WeakMap=="function"?WeakMap:Map;function bT(e,t,r){r=ns(-1,r),r.tag=3,r.payload={element:null};var o=t.value;return r.callback=function(){xg||(xg=!0,E0=o),g0(e,t)},r}function MT(e,t,r){r=ns(-1,r),r.tag=3;var o=e.type.getDerivedStateFromError;if(typeof o=="function"){var a=t.value;r.payload=function(){return o(a)},r.callback=function(){g0(e,t)}}var l=e.stateNode;return l!==null&&typeof l.componentDidCatch=="function"&&(r.callback=function(){g0(e,t),typeof o!="function"&&(Ks===null?Ks=new Set([this]):Ks.add(this));var p=t.stack;this.componentDidCatch(t.value,{componentStack:p!==null?p:""})}),r}function Qb(e,t,r){var o=e.pingCache;if(o===null){o=e.pingCache=new wC;var a=new Set;o.set(t,a)}else a=o.get(t),a===void 0&&(a=new Set,o.set(t,a));a.has(r)||(a.add(r),e=IC.bind(null,e,t,r),t.then(e,e))}function Yb(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function Jb(e,t,r,o,a){return e.mode&1?(e.flags|=65536,e.lanes=a,e):(e===t?e.flags|=65536:(e.flags|=128,r.flags|=131072,r.flags&=-52805,r.tag===1&&(r.alternate===null?r.tag=17:(t=ns(-1,1),t.tag=2,Hs(r,t,1))),r.lanes|=1),e)}var vC=us.ReactCurrentOwner,Mi=!1;function ci(e,t,r,o){t.child=e===null?eT(t,null,r,o):Ju(t,e.child,r,o)}function Zb(e,t,r,o,a){r=r.render;var l=t.ref;return Hu(t,a),o=vw(e,t,r,o,l,a),r=bw(),e!==null&&!Mi?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,ls(e,t,a)):(hr&&r&&lw(t),t.flags|=1,ci(e,t,o,a),t.child)}function eM(e,t,r,o,a){if(e===null){var l=r.type;return typeof l=="function"&&!Aw(l)&&l.defaultProps===void 0&&r.compare===null&&r.defaultProps===void 0?(t.tag=15,t.type=l,xT(e,t,l,o,a)):(e=Ym(r.type,null,o,t,t.mode,a),e.ref=t.ref,e.return=t,t.child=e)}if(l=e.child,!(e.lanes&a)){var p=l.memoizedProps;if(r=r.compare,r=r!==null?r:ih,r(p,o)&&e.ref===t.ref)return ls(e,t,a)}return t.flags|=1,e=Qs(l,o),e.ref=t.ref,e.return=t,t.child=e}function xT(e,t,r,o,a){if(e!==null){var l=e.memoizedProps;if(ih(l,o)&&e.ref===t.ref)if(Mi=!1,t.pendingProps=o=l,(e.lanes&a)!==0)e.flags&131072&&(Mi=!0);else return t.lanes=e.lanes,ls(e,t,a)}return _0(e,t,r,o,a)}function TT(e,t,r){var o=t.pendingProps,a=o.children,l=e!==null?e.memoizedState:null;if(o.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},sr(ju,Ci),Ci|=r;else{if(!(r&1073741824))return e=l!==null?l.baseLanes|r:r,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,sr(ju,Ci),Ci|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},o=l!==null?l.baseLanes:r,sr(ju,Ci),Ci|=o}else l!==null?(o=l.baseLanes|r,t.memoizedState=null):o=r,sr(ju,Ci),Ci|=o;return ci(e,t,a,r),t.child}function ST(e,t){var r=t.ref;(e===null&&r!==null||e!==null&&e.ref!==r)&&(t.flags|=512,t.flags|=2097152)}function _0(e,t,r,o,a){var l=Ti(r)?Ba:oi.current;return l=Qu(t,l),Hu(t,a),r=vw(e,t,r,o,l,a),o=bw(),e!==null&&!Mi?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,ls(e,t,a)):(hr&&o&&lw(t),t.flags|=1,ci(e,t,r,a),t.child)}function tM(e,t,r,o,a){if(Ti(r)){var l=!0;fg(t)}else l=!1;if(Hu(t,a),t.stateNode===null)Km(e,t),Jx(t,r,o),m0(t,r,o,a),o=!0;else if(e===null){var p=t.stateNode,w=t.memoizedProps;p.props=w;var _=p.context,y=r.contextType;typeof y=="object"&&y!==null?y=Xi(y):(y=Ti(r)?Ba:oi.current,y=Qu(t,y));var T=r.getDerivedStateFromProps,E=typeof T=="function"||typeof p.getSnapshotBeforeUpdate=="function";E||typeof p.UNSAFE_componentWillReceiveProps!="function"&&typeof p.componentWillReceiveProps!="function"||(w!==o||_!==y)&&qb(t,p,o,y),Ls=!1;var A=t.memoizedState;p.state=A,yg(t,o,p,a),_=t.memoizedState,w!==o||A!==_||xi.current||Ls?(typeof T=="function"&&(h0(t,r,T,o),_=t.memoizedState),(w=Ls||Gb(t,r,w,o,A,_,y))?(E||typeof p.UNSAFE_componentWillMount!="function"&&typeof p.componentWillMount!="function"||(typeof p.componentWillMount=="function"&&p.componentWillMount(),typeof p.UNSAFE_componentWillMount=="function"&&p.UNSAFE_componentWillMount()),typeof p.componentDidMount=="function"&&(t.flags|=4194308)):(typeof p.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=o,t.memoizedState=_),p.props=o,p.state=_,p.context=y,o=w):(typeof p.componentDidMount=="function"&&(t.flags|=4194308),o=!1)}else{p=t.stateNode,Qx(e,t),w=t.memoizedProps,y=t.type===t.elementType?w:uo(t.type,w),p.props=y,E=t.pendingProps,A=p.context,_=r.contextType,typeof _=="object"&&_!==null?_=Xi(_):(_=Ti(r)?Ba:oi.current,_=Qu(t,_));var H=r.getDerivedStateFromProps;(T=typeof H=="function"||typeof p.getSnapshotBeforeUpdate=="function")||typeof p.UNSAFE_componentWillReceiveProps!="function"&&typeof p.componentWillReceiveProps!="function"||(w!==E||A!==_)&&qb(t,p,o,_),Ls=!1,A=t.memoizedState,p.state=A,yg(t,o,p,a);var W=t.memoizedState;w!==E||A!==W||xi.current||Ls?(typeof H=="function"&&(h0(t,r,H,o),W=t.memoizedState),(y=Ls||Gb(t,r,y,o,A,W,_)||!1)?(T||typeof p.UNSAFE_componentWillUpdate!="function"&&typeof p.componentWillUpdate!="function"||(typeof p.componentWillUpdate=="function"&&p.componentWillUpdate(o,W,_),typeof p.UNSAFE_componentWillUpdate=="function"&&p.UNSAFE_componentWillUpdate(o,W,_)),typeof p.componentDidUpdate=="function"&&(t.flags|=4),typeof p.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof p.componentDidUpdate!="function"||w===e.memoizedProps&&A===e.memoizedState||(t.flags|=4),typeof p.getSnapshotBeforeUpdate!="function"||w===e.memoizedProps&&A===e.memoizedState||(t.flags|=1024),t.memoizedProps=o,t.memoizedState=W),p.props=o,p.state=W,p.context=_,o=y):(typeof p.componentDidUpdate!="function"||w===e.memoizedProps&&A===e.memoizedState||(t.flags|=4),typeof p.getSnapshotBeforeUpdate!="function"||w===e.memoizedProps&&A===e.memoizedState||(t.flags|=1024),o=!1)}return y0(e,t,r,o,l,a)}function y0(e,t,r,o,a,l){ST(e,t);var p=(t.flags&128)!==0;if(!o&&!p)return a&&Nb(t,r,!1),ls(e,t,l);o=t.stateNode,vC.current=t;var w=p&&typeof r.getDerivedStateFromError!="function"?null:o.render();return t.flags|=1,e!==null&&p?(t.child=Ju(t,e.child,null,l),t.child=Ju(t,null,w,l)):ci(e,t,w,l),t.memoizedState=o.state,a&&Nb(t,r,!0),t.child}function ET(e){var t=e.stateNode;t.pendingContext?Bb(e,t.pendingContext,t.pendingContext!==t.context):t.context&&Bb(e,t.context,!1),gw(e,t.containerInfo)}function nM(e,t,r,o,a){return Yu(),cw(a),t.flags|=256,ci(e,t,r,o),t.child}var w0={dehydrated:null,treeContext:null,retryLane:0};function v0(e){return{baseLanes:e,cachePool:null,transitions:null}}function kT(e,t,r){var o=t.pendingProps,a=wr.current,l=!1,p=(t.flags&128)!==0,w;if((w=p)||(w=e!==null&&e.memoizedState===null?!1:(a&2)!==0),w?(l=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(a|=1),sr(wr,a&1),e===null)return p0(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(p=o.children,e=o.fallback,l?(o=t.mode,l=t.child,p={mode:"hidden",children:p},!(o&1)&&l!==null?(l.childLanes=0,l.pendingProps=p):l=jg(p,o,0,null),e=za(e,o,r,null),l.return=t,e.return=t,l.sibling=e,t.child=l,t.child.memoizedState=v0(r),t.memoizedState=w0,e):Tw(t,p));if(a=e.memoizedState,a!==null&&(w=a.dehydrated,w!==null))return bC(e,t,p,o,w,a,r);if(l){l=o.fallback,p=t.mode,a=e.child,w=a.sibling;var _={mode:"hidden",children:o.children};return!(p&1)&&t.child!==a?(o=t.child,o.childLanes=0,o.pendingProps=_,t.deletions=null):(o=Qs(a,_),o.subtreeFlags=a.subtreeFlags&14680064),w!==null?l=Qs(w,l):(l=za(l,p,r,null),l.flags|=2),l.return=t,o.return=t,o.sibling=l,t.child=o,o=l,l=t.child,p=e.child.memoizedState,p=p===null?v0(r):{baseLanes:p.baseLanes|r,cachePool:null,transitions:p.transitions},l.memoizedState=p,l.childLanes=e.childLanes&~r,t.memoizedState=w0,o}return l=e.child,e=l.sibling,o=Qs(l,{mode:"visible",children:o.children}),!(t.mode&1)&&(o.lanes=r),o.return=t,o.sibling=null,e!==null&&(r=t.deletions,r===null?(t.deletions=[e],t.flags|=16):r.push(e)),t.child=o,t.memoizedState=null,o}function Tw(e,t){return t=jg({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function Dm(e,t,r,o){return o!==null&&cw(o),Ju(t,e.child,null,r),e=Tw(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function bC(e,t,r,o,a,l,p){if(r)return t.flags&256?(t.flags&=-257,o=my(Error(Et(422))),Dm(e,t,p,o)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(l=o.fallback,a=t.mode,o=jg({mode:"visible",children:o.children},a,0,null),l=za(l,a,p,null),l.flags|=2,o.return=t,l.return=t,o.sibling=l,t.child=o,t.mode&1&&Ju(t,e.child,null,p),t.child.memoizedState=v0(p),t.memoizedState=w0,l);if(!(t.mode&1))return Dm(e,t,p,null);if(a.data==="$!"){if(o=a.nextSibling&&a.nextSibling.dataset,o)var w=o.dgst;return o=w,l=Error(Et(419)),o=my(l,o,void 0),Dm(e,t,p,o)}if(w=(p&e.childLanes)!==0,Mi||w){if(o=qr,o!==null){switch(p&-p){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}a=a&(o.suspendedLanes|p)?0:a,a!==0&&a!==l.retryLane&&(l.retryLane=a,as(e,a),mo(o,e,a,-1))}return $w(),o=my(Error(Et(421))),Dm(e,t,p,o)}return a.data==="$?"?(t.flags|=128,t.child=e.child,t=OC.bind(null,e),a._reactRetry=t,null):(e=l.treeContext,$i=qs(a.nextSibling),Ai=t,hr=!0,po=null,e!==null&&(Vi[Wi++]=Zo,Vi[Wi++]=es,Vi[Wi++]=Na,Zo=e.id,es=e.overflow,Na=t),t=Tw(t,o.children),t.flags|=4096,t)}function rM(e,t,r){e.lanes|=t;var o=e.alternate;o!==null&&(o.lanes|=t),f0(e.return,t,r)}function gy(e,t,r,o,a){var l=e.memoizedState;l===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:o,tail:r,tailMode:a}:(l.isBackwards=t,l.rendering=null,l.renderingStartTime=0,l.last=o,l.tail=r,l.tailMode=a)}function CT(e,t,r){var o=t.pendingProps,a=o.revealOrder,l=o.tail;if(ci(e,t,o.children,r),o=wr.current,o&2)o=o&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&rM(e,r,t);else if(e.tag===19)rM(e,r,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}o&=1}if(sr(wr,o),!(t.mode&1))t.memoizedState=null;else switch(a){case"forwards":for(r=t.child,a=null;r!==null;)e=r.alternate,e!==null&&wg(e)===null&&(a=r),r=r.sibling;r=a,r===null?(a=t.child,t.child=null):(a=r.sibling,r.sibling=null),gy(t,!1,a,r,l);break;case"backwards":for(r=null,a=t.child,t.child=null;a!==null;){if(e=a.alternate,e!==null&&wg(e)===null){t.child=a;break}e=a.sibling,a.sibling=r,r=a,a=e}gy(t,!0,r,null,l);break;case"together":gy(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Km(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function ls(e,t,r){if(e!==null&&(t.dependencies=e.dependencies),ja|=t.lanes,!(r&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(Et(153));if(t.child!==null){for(e=t.child,r=Qs(e,e.pendingProps),t.child=r,r.return=t;e.sibling!==null;)e=e.sibling,r=r.sibling=Qs(e,e.pendingProps),r.return=t;r.sibling=null}return t.child}function MC(e,t,r){switch(t.tag){case 3:ET(t),Yu();break;case 5:tT(t);break;case 1:Ti(t.type)&&fg(t);break;case 4:gw(t,t.stateNode.containerInfo);break;case 10:var o=t.type._context,a=t.memoizedProps.value;sr(gg,o._currentValue),o._currentValue=a;break;case 13:if(o=t.memoizedState,o!==null)return o.dehydrated!==null?(sr(wr,wr.current&1),t.flags|=128,null):r&t.child.childLanes?kT(e,t,r):(sr(wr,wr.current&1),e=ls(e,t,r),e!==null?e.sibling:null);sr(wr,wr.current&1);break;case 19:if(o=(r&t.childLanes)!==0,e.flags&128){if(o)return CT(e,t,r);t.flags|=128}if(a=t.memoizedState,a!==null&&(a.rendering=null,a.tail=null,a.lastEffect=null),sr(wr,wr.current),o)break;return null;case 22:case 23:return t.lanes=0,TT(e,t,r)}return ls(e,t,r)}var PT,b0,$T,AT;PT=function(e,t){for(var r=t.child;r!==null;){if(r.tag===5||r.tag===6)e.appendChild(r.stateNode);else if(r.tag!==4&&r.child!==null){r.child.return=r,r=r.child;continue}if(r===t)break;for(;r.sibling===null;){if(r.return===null||r.return===t)return;r=r.return}r.sibling.return=r.return,r=r.sibling}};b0=function(){};$T=function(e,t,r,o){var a=e.memoizedProps;if(a!==o){e=t.stateNode,Ia(Do.current);var l=null;switch(r){case"input":a=Vy(e,a),o=Vy(e,o),l=[];break;case"select":a=br({},a,{value:void 0}),o=br({},o,{value:void 0}),l=[];break;case"textarea":a=qy(e,a),o=qy(e,o),l=[];break;default:typeof a.onClick!="function"&&typeof o.onClick=="function"&&(e.onclick=dg)}Ky(r,o);var p;r=null;for(y in a)if(!o.hasOwnProperty(y)&&a.hasOwnProperty(y)&&a[y]!=null)if(y==="style"){var w=a[y];for(p in w)w.hasOwnProperty(p)&&(r||(r={}),r[p]="")}else y!=="dangerouslySetInnerHTML"&&y!=="children"&&y!=="suppressContentEditableWarning"&&y!=="suppressHydrationWarning"&&y!=="autoFocus"&&(Yf.hasOwnProperty(y)?l||(l=[]):(l=l||[]).push(y,null));for(y in o){var _=o[y];if(w=a!=null?a[y]:void 0,o.hasOwnProperty(y)&&_!==w&&(_!=null||w!=null))if(y==="style")if(w){for(p in w)!w.hasOwnProperty(p)||_&&_.hasOwnProperty(p)||(r||(r={}),r[p]="");for(p in _)_.hasOwnProperty(p)&&w[p]!==_[p]&&(r||(r={}),r[p]=_[p])}else r||(l||(l=[]),l.push(y,r)),r=_;else y==="dangerouslySetInnerHTML"?(_=_?_.__html:void 0,w=w?w.__html:void 0,_!=null&&w!==_&&(l=l||[]).push(y,_)):y==="children"?typeof _!="string"&&typeof _!="number"||(l=l||[]).push(y,""+_):y!=="suppressContentEditableWarning"&&y!=="suppressHydrationWarning"&&(Yf.hasOwnProperty(y)?(_!=null&&y==="onScroll"&&cr("scroll",e),l||w===_||(l=[])):(l=l||[]).push(y,_))}r&&(l=l||[]).push("style",r);var y=l;(t.updateQueue=y)&&(t.flags|=4)}};AT=function(e,t,r,o){r!==o&&(t.flags|=4)};function $f(e,t){if(!hr)switch(e.tailMode){case"hidden":t=e.tail;for(var r=null;t!==null;)t.alternate!==null&&(r=t),t=t.sibling;r===null?e.tail=null:r.sibling=null;break;case"collapsed":r=e.tail;for(var o=null;r!==null;)r.alternate!==null&&(o=r),r=r.sibling;o===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:o.sibling=null}}function ni(e){var t=e.alternate!==null&&e.alternate.child===e.child,r=0,o=0;if(t)for(var a=e.child;a!==null;)r|=a.lanes|a.childLanes,o|=a.subtreeFlags&14680064,o|=a.flags&14680064,a.return=e,a=a.sibling;else for(a=e.child;a!==null;)r|=a.lanes|a.childLanes,o|=a.subtreeFlags,o|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=o,e.childLanes=r,t}function xC(e,t,r){var o=t.pendingProps;switch(uw(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ni(t),null;case 1:return Ti(t.type)&&pg(),ni(t),null;case 3:return o=t.stateNode,Zu(),dr(xi),dr(oi),yw(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),(e===null||e.child===null)&&(Im(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,po!==null&&(P0(po),po=null))),b0(e,t),ni(t),null;case 5:_w(t);var a=Ia(uh.current);if(r=t.type,e!==null&&t.stateNode!=null)$T(e,t,r,o,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!o){if(t.stateNode===null)throw Error(Et(166));return ni(t),null}if(e=Ia(Do.current),Im(t)){o=t.stateNode,r=t.type;var l=t.memoizedProps;switch(o[Ao]=t,o[ah]=l,e=(t.mode&1)!==0,r){case"dialog":cr("cancel",o),cr("close",o);break;case"iframe":case"object":case"embed":cr("load",o);break;case"video":case"audio":for(a=0;a<Bf.length;a++)cr(Bf[a],o);break;case"source":cr("error",o);break;case"img":case"image":case"link":cr("error",o),cr("load",o);break;case"details":cr("toggle",o);break;case"input":pb(o,l),cr("invalid",o);break;case"select":o._wrapperState={wasMultiple:!!l.multiple},cr("invalid",o);break;case"textarea":hb(o,l),cr("invalid",o)}Ky(r,l),a=null;for(var p in l)if(l.hasOwnProperty(p)){var w=l[p];p==="children"?typeof w=="string"?o.textContent!==w&&(l.suppressHydrationWarning!==!0&&Fm(o.textContent,w,e),a=["children",w]):typeof w=="number"&&o.textContent!==""+w&&(l.suppressHydrationWarning!==!0&&Fm(o.textContent,w,e),a=["children",""+w]):Yf.hasOwnProperty(p)&&w!=null&&p==="onScroll"&&cr("scroll",o)}switch(r){case"input":Tm(o),fb(o,l,!0);break;case"textarea":Tm(o),mb(o);break;case"select":case"option":break;default:typeof l.onClick=="function"&&(o.onclick=dg)}o=a,t.updateQueue=o,o!==null&&(t.flags|=4)}else{p=a.nodeType===9?a:a.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=ix(r)),e==="http://www.w3.org/1999/xhtml"?r==="script"?(e=p.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof o.is=="string"?e=p.createElement(r,{is:o.is}):(e=p.createElement(r),r==="select"&&(p=e,o.multiple?p.multiple=!0:o.size&&(p.size=o.size))):e=p.createElementNS(e,r),e[Ao]=t,e[ah]=o,PT(e,t,!1,!1),t.stateNode=e;e:{switch(p=Xy(r,o),r){case"dialog":cr("cancel",e),cr("close",e),a=o;break;case"iframe":case"object":case"embed":cr("load",e),a=o;break;case"video":case"audio":for(a=0;a<Bf.length;a++)cr(Bf[a],e);a=o;break;case"source":cr("error",e),a=o;break;case"img":case"image":case"link":cr("error",e),cr("load",e),a=o;break;case"details":cr("toggle",e),a=o;break;case"input":pb(e,o),a=Vy(e,o),cr("invalid",e);break;case"option":a=o;break;case"select":e._wrapperState={wasMultiple:!!o.multiple},a=br({},o,{value:void 0}),cr("invalid",e);break;case"textarea":hb(e,o),a=qy(e,o),cr("invalid",e);break;default:a=o}Ky(r,a),w=a;for(l in w)if(w.hasOwnProperty(l)){var _=w[l];l==="style"?ax(e,_):l==="dangerouslySetInnerHTML"?(_=_?_.__html:void 0,_!=null&&ox(e,_)):l==="children"?typeof _=="string"?(r!=="textarea"||_!=="")&&Jf(e,_):typeof _=="number"&&Jf(e,""+_):l!=="suppressContentEditableWarning"&&l!=="suppressHydrationWarning"&&l!=="autoFocus"&&(Yf.hasOwnProperty(l)?_!=null&&l==="onScroll"&&cr("scroll",e):_!=null&&K0(e,l,_,p))}switch(r){case"input":Tm(e),fb(e,o,!1);break;case"textarea":Tm(e),mb(e);break;case"option":o.value!=null&&e.setAttribute("value",""+Ys(o.value));break;case"select":e.multiple=!!o.multiple,l=o.value,l!=null?Vu(e,!!o.multiple,l,!1):o.defaultValue!=null&&Vu(e,!!o.multiple,o.defaultValue,!0);break;default:typeof a.onClick=="function"&&(e.onclick=dg)}switch(r){case"button":case"input":case"select":case"textarea":o=!!o.autoFocus;break e;case"img":o=!0;break e;default:o=!1}}o&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return ni(t),null;case 6:if(e&&t.stateNode!=null)AT(e,t,e.memoizedProps,o);else{if(typeof o!="string"&&t.stateNode===null)throw Error(Et(166));if(r=Ia(uh.current),Ia(Do.current),Im(t)){if(o=t.stateNode,r=t.memoizedProps,o[Ao]=t,(l=o.nodeValue!==r)&&(e=Ai,e!==null))switch(e.tag){case 3:Fm(o.nodeValue,r,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&Fm(o.nodeValue,r,(e.mode&1)!==0)}l&&(t.flags|=4)}else o=(r.nodeType===9?r:r.ownerDocument).createTextNode(o),o[Ao]=t,t.stateNode=o}return ni(t),null;case 13:if(dr(wr),o=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(hr&&$i!==null&&t.mode&1&&!(t.flags&128))Kx(),Yu(),t.flags|=98560,l=!1;else if(l=Im(t),o!==null&&o.dehydrated!==null){if(e===null){if(!l)throw Error(Et(318));if(l=t.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(Et(317));l[Ao]=t}else Yu(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;ni(t),l=!1}else po!==null&&(P0(po),po=null),l=!0;if(!l)return t.flags&65536?t:null}return t.flags&128?(t.lanes=r,t):(o=o!==null,o!==(e!==null&&e.memoizedState!==null)&&o&&(t.child.flags|=8192,t.mode&1&&(e===null||wr.current&1?Rr===0&&(Rr=3):$w())),t.updateQueue!==null&&(t.flags|=4),ni(t),null);case 4:return Zu(),b0(e,t),e===null&&oh(t.stateNode.containerInfo),ni(t),null;case 10:return fw(t.type._context),ni(t),null;case 17:return Ti(t.type)&&pg(),ni(t),null;case 19:if(dr(wr),l=t.memoizedState,l===null)return ni(t),null;if(o=(t.flags&128)!==0,p=l.rendering,p===null)if(o)$f(l,!1);else{if(Rr!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(p=wg(e),p!==null){for(t.flags|=128,$f(l,!1),o=p.updateQueue,o!==null&&(t.updateQueue=o,t.flags|=4),t.subtreeFlags=0,o=r,r=t.child;r!==null;)l=r,e=o,l.flags&=14680066,p=l.alternate,p===null?(l.childLanes=0,l.lanes=e,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=p.childLanes,l.lanes=p.lanes,l.child=p.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=p.memoizedProps,l.memoizedState=p.memoizedState,l.updateQueue=p.updateQueue,l.type=p.type,e=p.dependencies,l.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),r=r.sibling;return sr(wr,wr.current&1|2),t.child}e=e.sibling}l.tail!==null&&Er()>tc&&(t.flags|=128,o=!0,$f(l,!1),t.lanes=4194304)}else{if(!o)if(e=wg(p),e!==null){if(t.flags|=128,o=!0,r=e.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),$f(l,!0),l.tail===null&&l.tailMode==="hidden"&&!p.alternate&&!hr)return ni(t),null}else 2*Er()-l.renderingStartTime>tc&&r!==1073741824&&(t.flags|=128,o=!0,$f(l,!1),t.lanes=4194304);l.isBackwards?(p.sibling=t.child,t.child=p):(r=l.last,r!==null?r.sibling=p:t.child=p,l.last=p)}return l.tail!==null?(t=l.tail,l.rendering=t,l.tail=t.sibling,l.renderingStartTime=Er(),t.sibling=null,r=wr.current,sr(wr,o?r&1|2:r&1),t):(ni(t),null);case 22:case 23:return Pw(),o=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==o&&(t.flags|=8192),o&&t.mode&1?Ci&1073741824&&(ni(t),t.subtreeFlags&6&&(t.flags|=8192)):ni(t),null;case 24:return null;case 25:return null}throw Error(Et(156,t.tag))}function TC(e,t){switch(uw(t),t.tag){case 1:return Ti(t.type)&&pg(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return Zu(),dr(xi),dr(oi),yw(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return _w(t),null;case 13:if(dr(wr),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(Et(340));Yu()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return dr(wr),null;case 4:return Zu(),null;case 10:return fw(t.type._context),null;case 22:case 23:return Pw(),null;case 24:return null;default:return null}}var zm=!1,ri=!1,SC=typeof WeakSet=="function"?WeakSet:Set,Xt=null;function Uu(e,t){var r=e.ref;if(r!==null)if(typeof r=="function")try{r(null)}catch(o){Tr(e,t,o)}else r.current=null}function M0(e,t,r){try{r()}catch(o){Tr(e,t,o)}}var iM=!1;function EC(e,t){if(o0=lg,e=Dx(),aw(e)){if("selectionStart"in e)var r={start:e.selectionStart,end:e.selectionEnd};else e:{r=(r=e.ownerDocument)&&r.defaultView||window;var o=r.getSelection&&r.getSelection();if(o&&o.rangeCount!==0){r=o.anchorNode;var a=o.anchorOffset,l=o.focusNode;o=o.focusOffset;try{r.nodeType,l.nodeType}catch{r=null;break e}var p=0,w=-1,_=-1,y=0,T=0,E=e,A=null;t:for(;;){for(var H;E!==r||a!==0&&E.nodeType!==3||(w=p+a),E!==l||o!==0&&E.nodeType!==3||(_=p+o),E.nodeType===3&&(p+=E.nodeValue.length),(H=E.firstChild)!==null;)A=E,E=H;for(;;){if(E===e)break t;if(A===r&&++y===a&&(w=p),A===l&&++T===o&&(_=p),(H=E.nextSibling)!==null)break;E=A,A=E.parentNode}E=H}r=w===-1||_===-1?null:{start:w,end:_}}else r=null}r=r||{start:0,end:0}}else r=null;for(s0={focusedElem:e,selectionRange:r},lg=!1,Xt=t;Xt!==null;)if(t=Xt,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Xt=e;else for(;Xt!==null;){t=Xt;try{var W=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(W!==null){var Y=W.memoizedProps,B=W.memoizedState,F=t.stateNode,O=F.getSnapshotBeforeUpdate(t.elementType===t.type?Y:uo(t.type,Y),B);F.__reactInternalSnapshotBeforeUpdate=O}break;case 3:var P=t.stateNode.containerInfo;P.nodeType===1?P.textContent="":P.nodeType===9&&P.documentElement&&P.removeChild(P.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(Et(163))}}catch(j){Tr(t,t.return,j)}if(e=t.sibling,e!==null){e.return=t.return,Xt=e;break}Xt=t.return}return W=iM,iM=!1,W}function Kf(e,t,r){var o=t.updateQueue;if(o=o!==null?o.lastEffect:null,o!==null){var a=o=o.next;do{if((a.tag&e)===e){var l=a.destroy;a.destroy=void 0,l!==void 0&&M0(t,r,l)}a=a.next}while(a!==o)}}function Ng(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var r=t=t.next;do{if((r.tag&e)===e){var o=r.create;r.destroy=o()}r=r.next}while(r!==t)}}function x0(e){var t=e.ref;if(t!==null){var r=e.stateNode;switch(e.tag){case 5:e=r;break;default:e=r}typeof t=="function"?t(e):t.current=e}}function FT(e){var t=e.alternate;t!==null&&(e.alternate=null,FT(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[Ao],delete t[ah],delete t[u0],delete t[lC],delete t[uC])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function IT(e){return e.tag===5||e.tag===3||e.tag===4}function oM(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||IT(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function T0(e,t,r){var o=e.tag;if(o===5||o===6)e=e.stateNode,t?r.nodeType===8?r.parentNode.insertBefore(e,t):r.insertBefore(e,t):(r.nodeType===8?(t=r.parentNode,t.insertBefore(e,r)):(t=r,t.appendChild(e)),r=r._reactRootContainer,r!=null||t.onclick!==null||(t.onclick=dg));else if(o!==4&&(e=e.child,e!==null))for(T0(e,t,r),e=e.sibling;e!==null;)T0(e,t,r),e=e.sibling}function S0(e,t,r){var o=e.tag;if(o===5||o===6)e=e.stateNode,t?r.insertBefore(e,t):r.appendChild(e);else if(o!==4&&(e=e.child,e!==null))for(S0(e,t,r),e=e.sibling;e!==null;)S0(e,t,r),e=e.sibling}var Qr=null,co=!1;function Os(e,t,r){for(r=r.child;r!==null;)OT(e,t,r),r=r.sibling}function OT(e,t,r){if(Oo&&typeof Oo.onCommitFiberUnmount=="function")try{Oo.onCommitFiberUnmount(Fg,r)}catch{}switch(r.tag){case 5:ri||Uu(r,t);case 6:var o=Qr,a=co;Qr=null,Os(e,t,r),Qr=o,co=a,Qr!==null&&(co?(e=Qr,r=r.stateNode,e.nodeType===8?e.parentNode.removeChild(r):e.removeChild(r)):Qr.removeChild(r.stateNode));break;case 18:Qr!==null&&(co?(e=Qr,r=r.stateNode,e.nodeType===8?uy(e.parentNode,r):e.nodeType===1&&uy(e,r),nh(e)):uy(Qr,r.stateNode));break;case 4:o=Qr,a=co,Qr=r.stateNode.containerInfo,co=!0,Os(e,t,r),Qr=o,co=a;break;case 0:case 11:case 14:case 15:if(!ri&&(o=r.updateQueue,o!==null&&(o=o.lastEffect,o!==null))){a=o=o.next;do{var l=a,p=l.destroy;l=l.tag,p!==void 0&&(l&2||l&4)&&M0(r,t,p),a=a.next}while(a!==o)}Os(e,t,r);break;case 1:if(!ri&&(Uu(r,t),o=r.stateNode,typeof o.componentWillUnmount=="function"))try{o.props=r.memoizedProps,o.state=r.memoizedState,o.componentWillUnmount()}catch(w){Tr(r,t,w)}Os(e,t,r);break;case 21:Os(e,t,r);break;case 22:r.mode&1?(ri=(o=ri)||r.memoizedState!==null,Os(e,t,r),ri=o):Os(e,t,r);break;default:Os(e,t,r)}}function sM(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var r=e.stateNode;r===null&&(r=e.stateNode=new SC),t.forEach(function(o){var a=DC.bind(null,e,o);r.has(o)||(r.add(o),o.then(a,a))})}}function lo(e,t){var r=t.deletions;if(r!==null)for(var o=0;o<r.length;o++){var a=r[o];try{var l=e,p=t,w=p;e:for(;w!==null;){switch(w.tag){case 5:Qr=w.stateNode,co=!1;break e;case 3:Qr=w.stateNode.containerInfo,co=!0;break e;case 4:Qr=w.stateNode.containerInfo,co=!0;break e}w=w.return}if(Qr===null)throw Error(Et(160));OT(l,p,a),Qr=null,co=!1;var _=a.alternate;_!==null&&(_.return=null),a.return=null}catch(y){Tr(a,t,y)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)DT(t,e),t=t.sibling}function DT(e,t){var r=e.alternate,o=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(lo(t,e),Po(e),o&4){try{Kf(3,e,e.return),Ng(3,e)}catch(Y){Tr(e,e.return,Y)}try{Kf(5,e,e.return)}catch(Y){Tr(e,e.return,Y)}}break;case 1:lo(t,e),Po(e),o&512&&r!==null&&Uu(r,r.return);break;case 5:if(lo(t,e),Po(e),o&512&&r!==null&&Uu(r,r.return),e.flags&32){var a=e.stateNode;try{Jf(a,"")}catch(Y){Tr(e,e.return,Y)}}if(o&4&&(a=e.stateNode,a!=null)){var l=e.memoizedProps,p=r!==null?r.memoizedProps:l,w=e.type,_=e.updateQueue;if(e.updateQueue=null,_!==null)try{w==="input"&&l.type==="radio"&&l.name!=null&&nx(a,l),Xy(w,p);var y=Xy(w,l);for(p=0;p<_.length;p+=2){var T=_[p],E=_[p+1];T==="style"?ax(a,E):T==="dangerouslySetInnerHTML"?ox(a,E):T==="children"?Jf(a,E):K0(a,T,E,y)}switch(w){case"input":Wy(a,l);break;case"textarea":rx(a,l);break;case"select":var A=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!l.multiple;var H=l.value;H!=null?Vu(a,!!l.multiple,H,!1):A!==!!l.multiple&&(l.defaultValue!=null?Vu(a,!!l.multiple,l.defaultValue,!0):Vu(a,!!l.multiple,l.multiple?[]:"",!1))}a[ah]=l}catch(Y){Tr(e,e.return,Y)}}break;case 6:if(lo(t,e),Po(e),o&4){if(e.stateNode===null)throw Error(Et(162));a=e.stateNode,l=e.memoizedProps;try{a.nodeValue=l}catch(Y){Tr(e,e.return,Y)}}break;case 3:if(lo(t,e),Po(e),o&4&&r!==null&&r.memoizedState.isDehydrated)try{nh(t.containerInfo)}catch(Y){Tr(e,e.return,Y)}break;case 4:lo(t,e),Po(e);break;case 13:lo(t,e),Po(e),a=e.child,a.flags&8192&&(l=a.memoizedState!==null,a.stateNode.isHidden=l,!l||a.alternate!==null&&a.alternate.memoizedState!==null||(kw=Er())),o&4&&sM(e);break;case 22:if(T=r!==null&&r.memoizedState!==null,e.mode&1?(ri=(y=ri)||T,lo(t,e),ri=y):lo(t,e),Po(e),o&8192){if(y=e.memoizedState!==null,(e.stateNode.isHidden=y)&&!T&&e.mode&1)for(Xt=e,T=e.child;T!==null;){for(E=Xt=T;Xt!==null;){switch(A=Xt,H=A.child,A.tag){case 0:case 11:case 14:case 15:Kf(4,A,A.return);break;case 1:Uu(A,A.return);var W=A.stateNode;if(typeof W.componentWillUnmount=="function"){o=A,r=A.return;try{t=o,W.props=t.memoizedProps,W.state=t.memoizedState,W.componentWillUnmount()}catch(Y){Tr(o,r,Y)}}break;case 5:Uu(A,A.return);break;case 22:if(A.memoizedState!==null){lM(E);continue}}H!==null?(H.return=A,Xt=H):lM(E)}T=T.sibling}e:for(T=null,E=e;;){if(E.tag===5){if(T===null){T=E;try{a=E.stateNode,y?(l=a.style,typeof l.setProperty=="function"?l.setProperty("display","none","important"):l.display="none"):(w=E.stateNode,_=E.memoizedProps.style,p=_!=null&&_.hasOwnProperty("display")?_.display:null,w.style.display=sx("display",p))}catch(Y){Tr(e,e.return,Y)}}}else if(E.tag===6){if(T===null)try{E.stateNode.nodeValue=y?"":E.memoizedProps}catch(Y){Tr(e,e.return,Y)}}else if((E.tag!==22&&E.tag!==23||E.memoizedState===null||E===e)&&E.child!==null){E.child.return=E,E=E.child;continue}if(E===e)break e;for(;E.sibling===null;){if(E.return===null||E.return===e)break e;T===E&&(T=null),E=E.return}T===E&&(T=null),E.sibling.return=E.return,E=E.sibling}}break;case 19:lo(t,e),Po(e),o&4&&sM(e);break;case 21:break;default:lo(t,e),Po(e)}}function Po(e){var t=e.flags;if(t&2){try{e:{for(var r=e.return;r!==null;){if(IT(r)){var o=r;break e}r=r.return}throw Error(Et(160))}switch(o.tag){case 5:var a=o.stateNode;o.flags&32&&(Jf(a,""),o.flags&=-33);var l=oM(e);S0(e,l,a);break;case 3:case 4:var p=o.stateNode.containerInfo,w=oM(e);T0(e,w,p);break;default:throw Error(Et(161))}}catch(_){Tr(e,e.return,_)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function kC(e,t,r){Xt=e,zT(e)}function zT(e,t,r){for(var o=(e.mode&1)!==0;Xt!==null;){var a=Xt,l=a.child;if(a.tag===22&&o){var p=a.memoizedState!==null||zm;if(!p){var w=a.alternate,_=w!==null&&w.memoizedState!==null||ri;w=zm;var y=ri;if(zm=p,(ri=_)&&!y)for(Xt=a;Xt!==null;)p=Xt,_=p.child,p.tag===22&&p.memoizedState!==null?uM(a):_!==null?(_.return=p,Xt=_):uM(a);for(;l!==null;)Xt=l,zT(l),l=l.sibling;Xt=a,zm=w,ri=y}aM(e)}else a.subtreeFlags&8772&&l!==null?(l.return=a,Xt=l):aM(e)}}function aM(e){for(;Xt!==null;){var t=Xt;if(t.flags&8772){var r=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:ri||Ng(5,t);break;case 1:var o=t.stateNode;if(t.flags&4&&!ri)if(r===null)o.componentDidMount();else{var a=t.elementType===t.type?r.memoizedProps:uo(t.type,r.memoizedProps);o.componentDidUpdate(a,r.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var l=t.updateQueue;l!==null&&Wb(t,l,o);break;case 3:var p=t.updateQueue;if(p!==null){if(r=null,t.child!==null)switch(t.child.tag){case 5:r=t.child.stateNode;break;case 1:r=t.child.stateNode}Wb(t,p,r)}break;case 5:var w=t.stateNode;if(r===null&&t.flags&4){r=w;var _=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":_.autoFocus&&r.focus();break;case"img":_.src&&(r.src=_.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var y=t.alternate;if(y!==null){var T=y.memoizedState;if(T!==null){var E=T.dehydrated;E!==null&&nh(E)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(Et(163))}ri||t.flags&512&&x0(t)}catch(A){Tr(t,t.return,A)}}if(t===e){Xt=null;break}if(r=t.sibling,r!==null){r.return=t.return,Xt=r;break}Xt=t.return}}function lM(e){for(;Xt!==null;){var t=Xt;if(t===e){Xt=null;break}var r=t.sibling;if(r!==null){r.return=t.return,Xt=r;break}Xt=t.return}}function uM(e){for(;Xt!==null;){var t=Xt;try{switch(t.tag){case 0:case 11:case 15:var r=t.return;try{Ng(4,t)}catch(_){Tr(t,r,_)}break;case 1:var o=t.stateNode;if(typeof o.componentDidMount=="function"){var a=t.return;try{o.componentDidMount()}catch(_){Tr(t,a,_)}}var l=t.return;try{x0(t)}catch(_){Tr(t,l,_)}break;case 5:var p=t.return;try{x0(t)}catch(_){Tr(t,p,_)}}}catch(_){Tr(t,t.return,_)}if(t===e){Xt=null;break}var w=t.sibling;if(w!==null){w.return=t.return,Xt=w;break}Xt=t.return}}var CC=Math.ceil,Mg=us.ReactCurrentDispatcher,Sw=us.ReactCurrentOwner,qi=us.ReactCurrentBatchConfig,Kn=0,qr=null,Fr=null,Yr=0,Ci=0,ju=ea(0),Rr=0,fh=null,ja=0,Ug=0,Ew=0,Xf=null,bi=null,kw=0,tc=1/0,Yo=null,xg=!1,E0=null,Ks=null,Lm=!1,js=null,Tg=0,Qf=0,k0=null,Xm=-1,Qm=0;function di(){return Kn&6?Er():Xm!==-1?Xm:Xm=Er()}function Xs(e){return e.mode&1?Kn&2&&Yr!==0?Yr&-Yr:dC.transition!==null?(Qm===0&&(Qm=wx()),Qm):(e=nr,e!==0||(e=window.event,e=e===void 0?16:Ex(e.type)),e):1}function mo(e,t,r,o){if(50<Qf)throw Qf=0,k0=null,Error(Et(185));gh(e,r,o),(!(Kn&2)||e!==qr)&&(e===qr&&(!(Kn&2)&&(Ug|=r),Rr===4&&Bs(e,Yr)),Si(e,o),r===1&&Kn===0&&!(t.mode&1)&&(tc=Er()+500,Lg&&ta()))}function Si(e,t){var r=e.callbackNode;dk(e,t);var o=ag(e,e===qr?Yr:0);if(o===0)r!==null&&yb(r),e.callbackNode=null,e.callbackPriority=0;else if(t=o&-o,e.callbackPriority!==t){if(r!=null&&yb(r),t===1)e.tag===0?cC(cM.bind(null,e)):Gx(cM.bind(null,e)),sC(function(){!(Kn&6)&&ta()}),r=null;else{switch(vx(o)){case 1:r=Z0;break;case 4:r=_x;break;case 16:r=sg;break;case 536870912:r=yx;break;default:r=sg}r=WT(r,LT.bind(null,e))}e.callbackPriority=t,e.callbackNode=r}}function LT(e,t){if(Xm=-1,Qm=0,Kn&6)throw Error(Et(327));var r=e.callbackNode;if(Ku()&&e.callbackNode!==r)return null;var o=ag(e,e===qr?Yr:0);if(o===0)return null;if(o&30||o&e.expiredLanes||t)t=Sg(e,o);else{t=o;var a=Kn;Kn|=2;var l=BT();(qr!==e||Yr!==t)&&(Yo=null,tc=Er()+500,Da(e,t));do try{AC();break}catch(w){RT(e,w)}while(!0);pw(),Mg.current=l,Kn=a,Fr!==null?t=0:(qr=null,Yr=0,t=Rr)}if(t!==0){if(t===2&&(a=e0(e),a!==0&&(o=a,t=C0(e,a))),t===1)throw r=fh,Da(e,0),Bs(e,o),Si(e,Er()),r;if(t===6)Bs(e,o);else{if(a=e.current.alternate,!(o&30)&&!PC(a)&&(t=Sg(e,o),t===2&&(l=e0(e),l!==0&&(o=l,t=C0(e,l))),t===1))throw r=fh,Da(e,0),Bs(e,o),Si(e,Er()),r;switch(e.finishedWork=a,e.finishedLanes=o,t){case 0:case 1:throw Error(Et(345));case 2:Pa(e,bi,Yo);break;case 3:if(Bs(e,o),(o&130023424)===o&&(t=kw+500-Er(),10<t)){if(ag(e,0)!==0)break;if(a=e.suspendedLanes,(a&o)!==o){di(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=l0(Pa.bind(null,e,bi,Yo),t);break}Pa(e,bi,Yo);break;case 4:if(Bs(e,o),(o&4194240)===o)break;for(t=e.eventTimes,a=-1;0<o;){var p=31-ho(o);l=1<<p,p=t[p],p>a&&(a=p),o&=~l}if(o=a,o=Er()-o,o=(120>o?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*CC(o/1960))-o,10<o){e.timeoutHandle=l0(Pa.bind(null,e,bi,Yo),o);break}Pa(e,bi,Yo);break;case 5:Pa(e,bi,Yo);break;default:throw Error(Et(329))}}}return Si(e,Er()),e.callbackNode===r?LT.bind(null,e):null}function C0(e,t){var r=Xf;return e.current.memoizedState.isDehydrated&&(Da(e,t).flags|=256),e=Sg(e,t),e!==2&&(t=bi,bi=r,t!==null&&P0(t)),e}function P0(e){bi===null?bi=e:bi.push.apply(bi,e)}function PC(e){for(var t=e;;){if(t.flags&16384){var r=t.updateQueue;if(r!==null&&(r=r.stores,r!==null))for(var o=0;o<r.length;o++){var a=r[o],l=a.getSnapshot;a=a.value;try{if(!go(l(),a))return!1}catch{return!1}}}if(r=t.child,t.subtreeFlags&16384&&r!==null)r.return=t,t=r;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Bs(e,t){for(t&=~Ew,t&=~Ug,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var r=31-ho(t),o=1<<r;e[r]=-1,t&=~o}}function cM(e){if(Kn&6)throw Error(Et(327));Ku();var t=ag(e,0);if(!(t&1))return Si(e,Er()),null;var r=Sg(e,t);if(e.tag!==0&&r===2){var o=e0(e);o!==0&&(t=o,r=C0(e,o))}if(r===1)throw r=fh,Da(e,0),Bs(e,t),Si(e,Er()),r;if(r===6)throw Error(Et(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,Pa(e,bi,Yo),Si(e,Er()),null}function Cw(e,t){var r=Kn;Kn|=1;try{return e(t)}finally{Kn=r,Kn===0&&(tc=Er()+500,Lg&&ta())}}function Va(e){js!==null&&js.tag===0&&!(Kn&6)&&Ku();var t=Kn;Kn|=1;var r=qi.transition,o=nr;try{if(qi.transition=null,nr=1,e)return e()}finally{nr=o,qi.transition=r,Kn=t,!(Kn&6)&&ta()}}function Pw(){Ci=ju.current,dr(ju)}function Da(e,t){e.finishedWork=null,e.finishedLanes=0;var r=e.timeoutHandle;if(r!==-1&&(e.timeoutHandle=-1,oC(r)),Fr!==null)for(r=Fr.return;r!==null;){var o=r;switch(uw(o),o.tag){case 1:o=o.type.childContextTypes,o!=null&&pg();break;case 3:Zu(),dr(xi),dr(oi),yw();break;case 5:_w(o);break;case 4:Zu();break;case 13:dr(wr);break;case 19:dr(wr);break;case 10:fw(o.type._context);break;case 22:case 23:Pw()}r=r.return}if(qr=e,Fr=e=Qs(e.current,null),Yr=Ci=t,Rr=0,fh=null,Ew=Ug=ja=0,bi=Xf=null,Fa!==null){for(t=0;t<Fa.length;t++)if(r=Fa[t],o=r.interleaved,o!==null){r.interleaved=null;var a=o.next,l=r.pending;if(l!==null){var p=l.next;l.next=a,o.next=p}r.pending=o}Fa=null}return e}function RT(e,t){do{var r=Fr;try{if(pw(),qm.current=bg,vg){for(var o=vr.memoizedState;o!==null;){var a=o.queue;a!==null&&(a.pending=null),o=o.next}vg=!1}if(Ua=0,Wr=Lr=vr=null,Hf=!1,ch=0,Sw.current=null,r===null||r.return===null){Rr=1,fh=t,Fr=null;break}e:{var l=e,p=r.return,w=r,_=t;if(t=Yr,w.flags|=32768,_!==null&&typeof _=="object"&&typeof _.then=="function"){var y=_,T=w,E=T.tag;if(!(T.mode&1)&&(E===0||E===11||E===15)){var A=T.alternate;A?(T.updateQueue=A.updateQueue,T.memoizedState=A.memoizedState,T.lanes=A.lanes):(T.updateQueue=null,T.memoizedState=null)}var H=Yb(p);if(H!==null){H.flags&=-257,Jb(H,p,w,l,t),H.mode&1&&Qb(l,y,t),t=H,_=y;var W=t.updateQueue;if(W===null){var Y=new Set;Y.add(_),t.updateQueue=Y}else W.add(_);break e}else{if(!(t&1)){Qb(l,y,t),$w();break e}_=Error(Et(426))}}else if(hr&&w.mode&1){var B=Yb(p);if(B!==null){!(B.flags&65536)&&(B.flags|=256),Jb(B,p,w,l,t),cw(ec(_,w));break e}}l=_=ec(_,w),Rr!==4&&(Rr=2),Xf===null?Xf=[l]:Xf.push(l),l=p;do{switch(l.tag){case 3:l.flags|=65536,t&=-t,l.lanes|=t;var F=bT(l,_,t);Vb(l,F);break e;case 1:w=_;var O=l.type,P=l.stateNode;if(!(l.flags&128)&&(typeof O.getDerivedStateFromError=="function"||P!==null&&typeof P.componentDidCatch=="function"&&(Ks===null||!Ks.has(P)))){l.flags|=65536,t&=-t,l.lanes|=t;var j=MT(l,w,t);Vb(l,j);break e}}l=l.return}while(l!==null)}UT(r)}catch(V){t=V,Fr===r&&r!==null&&(Fr=r=r.return);continue}break}while(!0)}function BT(){var e=Mg.current;return Mg.current=bg,e===null?bg:e}function $w(){(Rr===0||Rr===3||Rr===2)&&(Rr=4),qr===null||!(ja&268435455)&&!(Ug&268435455)||Bs(qr,Yr)}function Sg(e,t){var r=Kn;Kn|=2;var o=BT();(qr!==e||Yr!==t)&&(Yo=null,Da(e,t));do try{$C();break}catch(a){RT(e,a)}while(!0);if(pw(),Kn=r,Mg.current=o,Fr!==null)throw Error(Et(261));return qr=null,Yr=0,Rr}function $C(){for(;Fr!==null;)NT(Fr)}function AC(){for(;Fr!==null&&!nk();)NT(Fr)}function NT(e){var t=VT(e.alternate,e,Ci);e.memoizedProps=e.pendingProps,t===null?UT(e):Fr=t,Sw.current=null}function UT(e){var t=e;do{var r=t.alternate;if(e=t.return,t.flags&32768){if(r=TC(r,t),r!==null){r.flags&=32767,Fr=r;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{Rr=6,Fr=null;return}}else if(r=xC(r,t,Ci),r!==null){Fr=r;return}if(t=t.sibling,t!==null){Fr=t;return}Fr=t=e}while(t!==null);Rr===0&&(Rr=5)}function Pa(e,t,r){var o=nr,a=qi.transition;try{qi.transition=null,nr=1,FC(e,t,r,o)}finally{qi.transition=a,nr=o}return null}function FC(e,t,r,o){do Ku();while(js!==null);if(Kn&6)throw Error(Et(327));r=e.finishedWork;var a=e.finishedLanes;if(r===null)return null;if(e.finishedWork=null,e.finishedLanes=0,r===e.current)throw Error(Et(177));e.callbackNode=null,e.callbackPriority=0;var l=r.lanes|r.childLanes;if(pk(e,l),e===qr&&(Fr=qr=null,Yr=0),!(r.subtreeFlags&2064)&&!(r.flags&2064)||Lm||(Lm=!0,WT(sg,function(){return Ku(),null})),l=(r.flags&15990)!==0,r.subtreeFlags&15990||l){l=qi.transition,qi.transition=null;var p=nr;nr=1;var w=Kn;Kn|=4,Sw.current=null,EC(e,r),DT(r,e),Jk(s0),lg=!!o0,s0=o0=null,e.current=r,kC(r),rk(),Kn=w,nr=p,qi.transition=l}else e.current=r;if(Lm&&(Lm=!1,js=e,Tg=a),l=e.pendingLanes,l===0&&(Ks=null),sk(r.stateNode),Si(e,Er()),t!==null)for(o=e.onRecoverableError,r=0;r<t.length;r++)a=t[r],o(a.value,{componentStack:a.stack,digest:a.digest});if(xg)throw xg=!1,e=E0,E0=null,e;return Tg&1&&e.tag!==0&&Ku(),l=e.pendingLanes,l&1?e===k0?Qf++:(Qf=0,k0=e):Qf=0,ta(),null}function Ku(){if(js!==null){var e=vx(Tg),t=qi.transition,r=nr;try{if(qi.transition=null,nr=16>e?16:e,js===null)var o=!1;else{if(e=js,js=null,Tg=0,Kn&6)throw Error(Et(331));var a=Kn;for(Kn|=4,Xt=e.current;Xt!==null;){var l=Xt,p=l.child;if(Xt.flags&16){var w=l.deletions;if(w!==null){for(var _=0;_<w.length;_++){var y=w[_];for(Xt=y;Xt!==null;){var T=Xt;switch(T.tag){case 0:case 11:case 15:Kf(8,T,l)}var E=T.child;if(E!==null)E.return=T,Xt=E;else for(;Xt!==null;){T=Xt;var A=T.sibling,H=T.return;if(FT(T),T===y){Xt=null;break}if(A!==null){A.return=H,Xt=A;break}Xt=H}}}var W=l.alternate;if(W!==null){var Y=W.child;if(Y!==null){W.child=null;do{var B=Y.sibling;Y.sibling=null,Y=B}while(Y!==null)}}Xt=l}}if(l.subtreeFlags&2064&&p!==null)p.return=l,Xt=p;else e:for(;Xt!==null;){if(l=Xt,l.flags&2048)switch(l.tag){case 0:case 11:case 15:Kf(9,l,l.return)}var F=l.sibling;if(F!==null){F.return=l.return,Xt=F;break e}Xt=l.return}}var O=e.current;for(Xt=O;Xt!==null;){p=Xt;var P=p.child;if(p.subtreeFlags&2064&&P!==null)P.return=p,Xt=P;else e:for(p=O;Xt!==null;){if(w=Xt,w.flags&2048)try{switch(w.tag){case 0:case 11:case 15:Ng(9,w)}}catch(V){Tr(w,w.return,V)}if(w===p){Xt=null;break e}var j=w.sibling;if(j!==null){j.return=w.return,Xt=j;break e}Xt=w.return}}if(Kn=a,ta(),Oo&&typeof Oo.onPostCommitFiberRoot=="function")try{Oo.onPostCommitFiberRoot(Fg,e)}catch{}o=!0}return o}finally{nr=r,qi.transition=t}}return!1}function dM(e,t,r){t=ec(r,t),t=bT(e,t,1),e=Hs(e,t,1),t=di(),e!==null&&(gh(e,1,t),Si(e,t))}function Tr(e,t,r){if(e.tag===3)dM(e,e,r);else for(;t!==null;){if(t.tag===3){dM(t,e,r);break}else if(t.tag===1){var o=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof o.componentDidCatch=="function"&&(Ks===null||!Ks.has(o))){e=ec(r,e),e=MT(t,e,1),t=Hs(t,e,1),e=di(),t!==null&&(gh(t,1,e),Si(t,e));break}}t=t.return}}function IC(e,t,r){var o=e.pingCache;o!==null&&o.delete(t),t=di(),e.pingedLanes|=e.suspendedLanes&r,qr===e&&(Yr&r)===r&&(Rr===4||Rr===3&&(Yr&130023424)===Yr&&500>Er()-kw?Da(e,0):Ew|=r),Si(e,t)}function jT(e,t){t===0&&(e.mode&1?(t=km,km<<=1,!(km&130023424)&&(km=4194304)):t=1);var r=di();e=as(e,t),e!==null&&(gh(e,t,r),Si(e,r))}function OC(e){var t=e.memoizedState,r=0;t!==null&&(r=t.retryLane),jT(e,r)}function DC(e,t){var r=0;switch(e.tag){case 13:var o=e.stateNode,a=e.memoizedState;a!==null&&(r=a.retryLane);break;case 19:o=e.stateNode;break;default:throw Error(Et(314))}o!==null&&o.delete(t),jT(e,r)}var VT;VT=function(e,t,r){if(e!==null)if(e.memoizedProps!==t.pendingProps||xi.current)Mi=!0;else{if(!(e.lanes&r)&&!(t.flags&128))return Mi=!1,MC(e,t,r);Mi=!!(e.flags&131072)}else Mi=!1,hr&&t.flags&1048576&&qx(t,mg,t.index);switch(t.lanes=0,t.tag){case 2:var o=t.type;Km(e,t),e=t.pendingProps;var a=Qu(t,oi.current);Hu(t,r),a=vw(null,t,o,e,a,r);var l=bw();return t.flags|=1,typeof a=="object"&&a!==null&&typeof a.render=="function"&&a.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ti(o)?(l=!0,fg(t)):l=!1,t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,mw(t),a.updater=Rg,t.stateNode=a,a._reactInternals=t,m0(t,o,e,r),t=y0(null,t,o,!0,l,r)):(t.tag=0,hr&&l&&lw(t),ci(null,t,a,r),t=t.child),t;case 16:o=t.elementType;e:{switch(Km(e,t),e=t.pendingProps,a=o._init,o=a(o._payload),t.type=o,a=t.tag=LC(o),e=uo(o,e),a){case 0:t=_0(null,t,o,e,r);break e;case 1:t=tM(null,t,o,e,r);break e;case 11:t=Zb(null,t,o,e,r);break e;case 14:t=eM(null,t,o,uo(o.type,e),r);break e}throw Error(Et(306,o,""))}return t;case 0:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:uo(o,a),_0(e,t,o,a,r);case 1:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:uo(o,a),tM(e,t,o,a,r);case 3:e:{if(ET(t),e===null)throw Error(Et(387));o=t.pendingProps,l=t.memoizedState,a=l.element,Qx(e,t),yg(t,o,null,r);var p=t.memoizedState;if(o=p.element,l.isDehydrated)if(l={element:o,isDehydrated:!1,cache:p.cache,pendingSuspenseBoundaries:p.pendingSuspenseBoundaries,transitions:p.transitions},t.updateQueue.baseState=l,t.memoizedState=l,t.flags&256){a=ec(Error(Et(423)),t),t=nM(e,t,o,r,a);break e}else if(o!==a){a=ec(Error(Et(424)),t),t=nM(e,t,o,r,a);break e}else for($i=qs(t.stateNode.containerInfo.firstChild),Ai=t,hr=!0,po=null,r=eT(t,null,o,r),t.child=r;r;)r.flags=r.flags&-3|4096,r=r.sibling;else{if(Yu(),o===a){t=ls(e,t,r);break e}ci(e,t,o,r)}t=t.child}return t;case 5:return tT(t),e===null&&p0(t),o=t.type,a=t.pendingProps,l=e!==null?e.memoizedProps:null,p=a.children,a0(o,a)?p=null:l!==null&&a0(o,l)&&(t.flags|=32),ST(e,t),ci(e,t,p,r),t.child;case 6:return e===null&&p0(t),null;case 13:return kT(e,t,r);case 4:return gw(t,t.stateNode.containerInfo),o=t.pendingProps,e===null?t.child=Ju(t,null,o,r):ci(e,t,o,r),t.child;case 11:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:uo(o,a),Zb(e,t,o,a,r);case 7:return ci(e,t,t.pendingProps,r),t.child;case 8:return ci(e,t,t.pendingProps.children,r),t.child;case 12:return ci(e,t,t.pendingProps.children,r),t.child;case 10:e:{if(o=t.type._context,a=t.pendingProps,l=t.memoizedProps,p=a.value,sr(gg,o._currentValue),o._currentValue=p,l!==null)if(go(l.value,p)){if(l.children===a.children&&!xi.current){t=ls(e,t,r);break e}}else for(l=t.child,l!==null&&(l.return=t);l!==null;){var w=l.dependencies;if(w!==null){p=l.child;for(var _=w.firstContext;_!==null;){if(_.context===o){if(l.tag===1){_=ns(-1,r&-r),_.tag=2;var y=l.updateQueue;if(y!==null){y=y.shared;var T=y.pending;T===null?_.next=_:(_.next=T.next,T.next=_),y.pending=_}}l.lanes|=r,_=l.alternate,_!==null&&(_.lanes|=r),f0(l.return,r,t),w.lanes|=r;break}_=_.next}}else if(l.tag===10)p=l.type===t.type?null:l.child;else if(l.tag===18){if(p=l.return,p===null)throw Error(Et(341));p.lanes|=r,w=p.alternate,w!==null&&(w.lanes|=r),f0(p,r,t),p=l.sibling}else p=l.child;if(p!==null)p.return=l;else for(p=l;p!==null;){if(p===t){p=null;break}if(l=p.sibling,l!==null){l.return=p.return,p=l;break}p=p.return}l=p}ci(e,t,a.children,r),t=t.child}return t;case 9:return a=t.type,o=t.pendingProps.children,Hu(t,r),a=Xi(a),o=o(a),t.flags|=1,ci(e,t,o,r),t.child;case 14:return o=t.type,a=uo(o,t.pendingProps),a=uo(o.type,a),eM(e,t,o,a,r);case 15:return xT(e,t,t.type,t.pendingProps,r);case 17:return o=t.type,a=t.pendingProps,a=t.elementType===o?a:uo(o,a),Km(e,t),t.tag=1,Ti(o)?(e=!0,fg(t)):e=!1,Hu(t,r),Jx(t,o,a),m0(t,o,a,r),y0(null,t,o,!0,e,r);case 19:return CT(e,t,r);case 22:return TT(e,t,r)}throw Error(Et(156,t.tag))};function WT(e,t){return gx(e,t)}function zC(e,t,r,o){this.tag=e,this.key=r,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Gi(e,t,r,o){return new zC(e,t,r,o)}function Aw(e){return e=e.prototype,!(!e||!e.isReactComponent)}function LC(e){if(typeof e=="function")return Aw(e)?1:0;if(e!=null){if(e=e.$$typeof,e===Q0)return 11;if(e===Y0)return 14}return 2}function Qs(e,t){var r=e.alternate;return r===null?(r=Gi(e.tag,t,e.key,e.mode),r.elementType=e.elementType,r.type=e.type,r.stateNode=e.stateNode,r.alternate=e,e.alternate=r):(r.pendingProps=t,r.type=e.type,r.flags=0,r.subtreeFlags=0,r.deletions=null),r.flags=e.flags&14680064,r.childLanes=e.childLanes,r.lanes=e.lanes,r.child=e.child,r.memoizedProps=e.memoizedProps,r.memoizedState=e.memoizedState,r.updateQueue=e.updateQueue,t=e.dependencies,r.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},r.sibling=e.sibling,r.index=e.index,r.ref=e.ref,r}function Ym(e,t,r,o,a,l){var p=2;if(o=e,typeof e=="function")Aw(e)&&(p=1);else if(typeof e=="string")p=5;else e:switch(e){case Fu:return za(r.children,a,l,t);case X0:p=8,a|=8;break;case By:return e=Gi(12,r,t,a|2),e.elementType=By,e.lanes=l,e;case Ny:return e=Gi(13,r,t,a),e.elementType=Ny,e.lanes=l,e;case Uy:return e=Gi(19,r,t,a),e.elementType=Uy,e.lanes=l,e;case ZM:return jg(r,a,l,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case YM:p=10;break e;case JM:p=9;break e;case Q0:p=11;break e;case Y0:p=14;break e;case zs:p=16,o=null;break e}throw Error(Et(130,e==null?e:typeof e,""))}return t=Gi(p,r,t,a),t.elementType=e,t.type=o,t.lanes=l,t}function za(e,t,r,o){return e=Gi(7,e,o,t),e.lanes=r,e}function jg(e,t,r,o){return e=Gi(22,e,o,t),e.elementType=ZM,e.lanes=r,e.stateNode={isHidden:!1},e}function _y(e,t,r){return e=Gi(6,e,null,t),e.lanes=r,e}function yy(e,t,r){return t=Gi(4,e.children!==null?e.children:[],e.key,t),t.lanes=r,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function RC(e,t,r,o,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=J_(0),this.expirationTimes=J_(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=J_(0),this.identifierPrefix=o,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Fw(e,t,r,o,a,l,p,w,_){return e=new RC(e,t,r,w,_),t===1?(t=1,l===!0&&(t|=8)):t=0,l=Gi(3,null,null,t),e.current=l,l.stateNode=e,l.memoizedState={element:o,isDehydrated:r,cache:null,transitions:null,pendingSuspenseBoundaries:null},mw(l),e}function BC(e,t,r){var o=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Au,key:o==null?null:""+o,children:e,containerInfo:t,implementation:r}}function GT(e){if(!e)return Js;e=e._reactInternals;e:{if(Ga(e)!==e||e.tag!==1)throw Error(Et(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ti(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(Et(171))}if(e.tag===1){var r=e.type;if(Ti(r))return Wx(e,r,t)}return t}function qT(e,t,r,o,a,l,p,w,_){return e=Fw(r,o,!0,e,a,l,p,w,_),e.context=GT(null),r=e.current,o=di(),a=Xs(r),l=ns(o,a),l.callback=t??null,Hs(r,l,a),e.current.lanes=a,gh(e,a,o),Si(e,o),e}function Vg(e,t,r,o){var a=t.current,l=di(),p=Xs(a);return r=GT(r),t.context===null?t.context=r:t.pendingContext=r,t=ns(l,p),t.payload={element:e},o=o===void 0?null:o,o!==null&&(t.callback=o),e=Hs(a,t,p),e!==null&&(mo(e,a,p,l),Gm(e,a,p)),p}function Eg(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function pM(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var r=e.retryLane;e.retryLane=r!==0&&r<t?r:t}}function Iw(e,t){pM(e,t),(e=e.alternate)&&pM(e,t)}function NC(){return null}var HT=typeof reportError=="function"?reportError:function(e){console.error(e)};function Ow(e){this._internalRoot=e}Wg.prototype.render=Ow.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(Et(409));Vg(e,t,null,null)};Wg.prototype.unmount=Ow.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Va(function(){Vg(null,e,null,null)}),t[ss]=null}};function Wg(e){this._internalRoot=e}Wg.prototype.unstable_scheduleHydration=function(e){if(e){var t=xx();e={blockedOn:null,target:e,priority:t};for(var r=0;r<Rs.length&&t!==0&&t<Rs[r].priority;r++);Rs.splice(r,0,e),r===0&&Sx(e)}};function Dw(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Gg(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function fM(){}function UC(e,t,r,o,a){if(a){if(typeof o=="function"){var l=o;o=function(){var y=Eg(p);l.call(y)}}var p=qT(t,o,e,0,null,!1,!1,"",fM);return e._reactRootContainer=p,e[ss]=p.current,oh(e.nodeType===8?e.parentNode:e),Va(),p}for(;a=e.lastChild;)e.removeChild(a);if(typeof o=="function"){var w=o;o=function(){var y=Eg(_);w.call(y)}}var _=Fw(e,0,!1,null,null,!1,!1,"",fM);return e._reactRootContainer=_,e[ss]=_.current,oh(e.nodeType===8?e.parentNode:e),Va(function(){Vg(t,_,r,o)}),_}function qg(e,t,r,o,a){var l=r._reactRootContainer;if(l){var p=l;if(typeof a=="function"){var w=a;a=function(){var _=Eg(p);w.call(_)}}Vg(t,p,e,a)}else p=UC(r,t,e,a,o);return Eg(p)}bx=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var r=Rf(t.pendingLanes);r!==0&&(ew(t,r|1),Si(t,Er()),!(Kn&6)&&(tc=Er()+500,ta()))}break;case 13:Va(function(){var o=as(e,1);if(o!==null){var a=di();mo(o,e,1,a)}}),Iw(e,1)}};tw=function(e){if(e.tag===13){var t=as(e,134217728);if(t!==null){var r=di();mo(t,e,134217728,r)}Iw(e,134217728)}};Mx=function(e){if(e.tag===13){var t=Xs(e),r=as(e,t);if(r!==null){var o=di();mo(r,e,t,o)}Iw(e,t)}};xx=function(){return nr};Tx=function(e,t){var r=nr;try{return nr=e,t()}finally{nr=r}};Yy=function(e,t,r){switch(t){case"input":if(Wy(e,r),t=r.name,r.type==="radio"&&t!=null){for(r=e;r.parentNode;)r=r.parentNode;for(r=r.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<r.length;t++){var o=r[t];if(o!==e&&o.form===e.form){var a=zg(o);if(!a)throw Error(Et(90));tx(o),Wy(o,a)}}}break;case"textarea":rx(e,r);break;case"select":t=r.value,t!=null&&Vu(e,!!r.multiple,t,!1)}};cx=Cw;dx=Va;var jC={usingClientEntryPoint:!1,Events:[yh,zu,zg,lx,ux,Cw]},Af={findFiberByHostInstance:Aa,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},VC={bundleType:Af.bundleType,version:Af.version,rendererPackageName:Af.rendererPackageName,rendererConfig:Af.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:us.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=hx(e),e===null?null:e.stateNode},findFiberByHostInstance:Af.findFiberByHostInstance||NC,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Rm=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Rm.isDisabled&&Rm.supportsFiber)try{Fg=Rm.inject(VC),Oo=Rm}catch{}}Ii.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=jC;Ii.createPortal=function(e,t){var r=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Dw(t))throw Error(Et(200));return BC(e,t,null,r)};Ii.createRoot=function(e,t){if(!Dw(e))throw Error(Et(299));var r=!1,o="",a=HT;return t!=null&&(t.unstable_strictMode===!0&&(r=!0),t.identifierPrefix!==void 0&&(o=t.identifierPrefix),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=Fw(e,1,!1,null,null,r,!1,o,a),e[ss]=t.current,oh(e.nodeType===8?e.parentNode:e),new Ow(t)};Ii.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(Et(188)):(e=Object.keys(e).join(","),Error(Et(268,e)));return e=hx(t),e=e===null?null:e.stateNode,e};Ii.flushSync=function(e){return Va(e)};Ii.hydrate=function(e,t,r){if(!Gg(t))throw Error(Et(200));return qg(null,e,t,!0,r)};Ii.hydrateRoot=function(e,t,r){if(!Dw(e))throw Error(Et(405));var o=r!=null&&r.hydratedSources||null,a=!1,l="",p=HT;if(r!=null&&(r.unstable_strictMode===!0&&(a=!0),r.identifierPrefix!==void 0&&(l=r.identifierPrefix),r.onRecoverableError!==void 0&&(p=r.onRecoverableError)),t=qT(t,null,e,1,r??null,a,!1,l,p),e[ss]=t.current,oh(e),o)for(e=0;e<o.length;e++)r=o[e],a=r._getVersion,a=a(r._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[r,a]:t.mutableSourceEagerHydrationData.push(r,a);return new Wg(t)};Ii.render=function(e,t,r){if(!Gg(t))throw Error(Et(200));return qg(null,e,t,!1,r)};Ii.unmountComponentAtNode=function(e){if(!Gg(e))throw Error(Et(40));return e._reactRootContainer?(Va(function(){qg(null,null,e,!1,function(){e._reactRootContainer=null,e[ss]=null})}),!0):!1};Ii.unstable_batchedUpdates=Cw;Ii.unstable_renderSubtreeIntoContainer=function(e,t,r,o){if(!Gg(r))throw Error(Et(200));if(e==null||e._reactInternals===void 0)throw Error(Et(38));return qg(e,t,r,!1,o)};Ii.version="18.2.0-next-9e3b772b8-20220608";function KT(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(KT)}catch(e){console.error(e)}}KT(),qM.exports=Ii;var XT=qM.exports,hM=XT;Ly.createRoot=hM.createRoot,Ly.hydrateRoot=hM.hydrateRoot;function QT(e,t){return function(){return e.apply(t,arguments)}}const{toString:WC}=Object.prototype,{getPrototypeOf:zw}=Object,Hg=(e=>t=>{const r=WC.call(t);return e[r]||(e[r]=r.slice(8,-1).toLowerCase())})(Object.create(null)),zo=e=>(e=e.toLowerCase(),t=>Hg(t)===e),Kg=e=>t=>typeof t===e,{isArray:sc}=Array,hh=Kg("undefined");function GC(e){return e!==null&&!hh(e)&&e.constructor!==null&&!hh(e.constructor)&&Hi(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const YT=zo("ArrayBuffer");function qC(e){let t;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?t=ArrayBuffer.isView(e):t=e&&e.buffer&&YT(e.buffer),t}const HC=Kg("string"),Hi=Kg("function"),JT=Kg("number"),Xg=e=>e!==null&&typeof e=="object",KC=e=>e===!0||e===!1,Jm=e=>{if(Hg(e)!=="object")return!1;const t=zw(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},XC=zo("Date"),QC=zo("File"),YC=zo("Blob"),JC=zo("FileList"),ZC=e=>Xg(e)&&Hi(e.pipe),eP=e=>{let t;return e&&(typeof FormData=="function"&&e instanceof FormData||Hi(e.append)&&((t=Hg(e))==="formdata"||t==="object"&&Hi(e.toString)&&e.toString()==="[object FormData]"))},tP=zo("URLSearchParams"),nP=e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function vh(e,t,{allOwnKeys:r=!1}={}){if(e===null||typeof e>"u")return;let o,a;if(typeof e!="object"&&(e=[e]),sc(e))for(o=0,a=e.length;o<a;o++)t.call(null,e[o],o,e);else{const l=r?Object.getOwnPropertyNames(e):Object.keys(e),p=l.length;let w;for(o=0;o<p;o++)w=l[o],t.call(null,e[w],w,e)}}function ZT(e,t){t=t.toLowerCase();const r=Object.keys(e);let o=r.length,a;for(;o-- >0;)if(a=r[o],t===a.toLowerCase())return a;return null}const e2=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global,t2=e=>!hh(e)&&e!==e2;function $0(){const{caseless:e}=t2(this)&&this||{},t={},r=(o,a)=>{const l=e&&ZT(t,a)||a;Jm(t[l])&&Jm(o)?t[l]=$0(t[l],o):Jm(o)?t[l]=$0({},o):sc(o)?t[l]=o.slice():t[l]=o};for(let o=0,a=arguments.length;o<a;o++)arguments[o]&&vh(arguments[o],r);return t}const rP=(e,t,r,{allOwnKeys:o}={})=>(vh(t,(a,l)=>{r&&Hi(a)?e[l]=QT(a,r):e[l]=a},{allOwnKeys:o}),e),iP=e=>(e.charCodeAt(0)===65279&&(e=e.slice(1)),e),oP=(e,t,r,o)=>{e.prototype=Object.create(t.prototype,o),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),r&&Object.assign(e.prototype,r)},sP=(e,t,r,o)=>{let a,l,p;const w={};if(t=t||{},e==null)return t;do{for(a=Object.getOwnPropertyNames(e),l=a.length;l-- >0;)p=a[l],(!o||o(p,e,t))&&!w[p]&&(t[p]=e[p],w[p]=!0);e=r!==!1&&zw(e)}while(e&&(!r||r(e,t))&&e!==Object.prototype);return t},aP=(e,t,r)=>{e=String(e),(r===void 0||r>e.length)&&(r=e.length),r-=t.length;const o=e.indexOf(t,r);return o!==-1&&o===r},lP=e=>{if(!e)return null;if(sc(e))return e;let t=e.length;if(!JT(t))return null;const r=new Array(t);for(;t-- >0;)r[t]=e[t];return r},uP=(e=>t=>e&&t instanceof e)(typeof Uint8Array<"u"&&zw(Uint8Array)),cP=(e,t)=>{const o=(e&&e[Symbol.iterator]).call(e);let a;for(;(a=o.next())&&!a.done;){const l=a.value;t.call(e,l[0],l[1])}},dP=(e,t)=>{let r;const o=[];for(;(r=e.exec(t))!==null;)o.push(r);return o},pP=zo("HTMLFormElement"),fP=e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(r,o,a){return o.toUpperCase()+a}),mM=(({hasOwnProperty:e})=>(t,r)=>e.call(t,r))(Object.prototype),hP=zo("RegExp"),n2=(e,t)=>{const r=Object.getOwnPropertyDescriptors(e),o={};vh(r,(a,l)=>{t(a,l,e)!==!1&&(o[l]=a)}),Object.defineProperties(e,o)},mP=e=>{n2(e,(t,r)=>{if(Hi(e)&&["arguments","caller","callee"].indexOf(r)!==-1)return!1;const o=e[r];if(Hi(o)){if(t.enumerable=!1,"writable"in t){t.writable=!1;return}t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+r+"'")})}})},gP=(e,t)=>{const r={},o=a=>{a.forEach(l=>{r[l]=!0})};return sc(e)?o(e):o(String(e).split(t)),r},_P=()=>{},yP=(e,t)=>(e=+e,Number.isFinite(e)?e:t),wy="abcdefghijklmnopqrstuvwxyz",gM="0123456789",r2={DIGIT:gM,ALPHA:wy,ALPHA_DIGIT:wy+wy.toUpperCase()+gM},wP=(e=16,t=r2.ALPHA_DIGIT)=>{let r="";const{length:o}=t;for(;e--;)r+=t[Math.random()*o|0];return r};function vP(e){return!!(e&&Hi(e.append)&&e[Symbol.toStringTag]==="FormData"&&e[Symbol.iterator])}const bP=e=>{const t=new Array(10),r=(o,a)=>{if(Xg(o)){if(t.indexOf(o)>=0)return;if(!("toJSON"in o)){t[a]=o;const l=sc(o)?[]:{};return vh(o,(p,w)=>{const _=r(p,a+1);!hh(_)&&(l[w]=_)}),t[a]=void 0,l}}return o};return r(e,0)},MP=zo("AsyncFunction"),xP=e=>e&&(Xg(e)||Hi(e))&&Hi(e.then)&&Hi(e.catch),ct={isArray:sc,isArrayBuffer:YT,isBuffer:GC,isFormData:eP,isArrayBufferView:qC,isString:HC,isNumber:JT,isBoolean:KC,isObject:Xg,isPlainObject:Jm,isUndefined:hh,isDate:XC,isFile:QC,isBlob:YC,isRegExp:hP,isFunction:Hi,isStream:ZC,isURLSearchParams:tP,isTypedArray:uP,isFileList:JC,forEach:vh,merge:$0,extend:rP,trim:nP,stripBOM:iP,inherits:oP,toFlatObject:sP,kindOf:Hg,kindOfTest:zo,endsWith:aP,toArray:lP,forEachEntry:cP,matchAll:dP,isHTMLForm:pP,hasOwnProperty:mM,hasOwnProp:mM,reduceDescriptors:n2,freezeMethods:mP,toObjectSet:gP,toCamelCase:fP,noop:_P,toFiniteNumber:yP,findKey:ZT,global:e2,isContextDefined:t2,ALPHABET:r2,generateString:wP,isSpecCompliantForm:vP,toJSONObject:bP,isAsyncFn:MP,isThenable:xP};function Hn(e,t,r,o,a){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=e,this.name="AxiosError",t&&(this.code=t),r&&(this.config=r),o&&(this.request=o),a&&(this.response=a)}ct.inherits(Hn,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:ct.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const i2=Hn.prototype,o2={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(e=>{o2[e]={value:e}});Object.defineProperties(Hn,o2);Object.defineProperty(i2,"isAxiosError",{value:!0});Hn.from=(e,t,r,o,a,l)=>{const p=Object.create(i2);return ct.toFlatObject(e,p,function(_){return _!==Error.prototype},w=>w!=="isAxiosError"),Hn.call(p,e.message,t,r,o,a),p.cause=e,p.name=e.name,l&&Object.assign(p,l),p};const TP=null;function A0(e){return ct.isPlainObject(e)||ct.isArray(e)}function s2(e){return ct.endsWith(e,"[]")?e.slice(0,-2):e}function _M(e,t,r){return e?e.concat(t).map(function(a,l){return a=s2(a),!r&&l?"["+a+"]":a}).join(r?".":""):t}function SP(e){return ct.isArray(e)&&!e.some(A0)}const EP=ct.toFlatObject(ct,{},null,function(t){return/^is[A-Z]/.test(t)});function Qg(e,t,r){if(!ct.isObject(e))throw new TypeError("target must be an object");t=t||new FormData,r=ct.toFlatObject(r,{metaTokens:!0,dots:!1,indexes:!1},!1,function(Y,B){return!ct.isUndefined(B[Y])});const o=r.metaTokens,a=r.visitor||T,l=r.dots,p=r.indexes,_=(r.Blob||typeof Blob<"u"&&Blob)&&ct.isSpecCompliantForm(t);if(!ct.isFunction(a))throw new TypeError("visitor must be a function");function y(W){if(W===null)return"";if(ct.isDate(W))return W.toISOString();if(!_&&ct.isBlob(W))throw new Hn("Blob is not supported. Use a Buffer instead.");return ct.isArrayBuffer(W)||ct.isTypedArray(W)?_&&typeof Blob=="function"?new Blob([W]):Buffer.from(W):W}function T(W,Y,B){let F=W;if(W&&!B&&typeof W=="object"){if(ct.endsWith(Y,"{}"))Y=o?Y:Y.slice(0,-2),W=JSON.stringify(W);else if(ct.isArray(W)&&SP(W)||(ct.isFileList(W)||ct.endsWith(Y,"[]"))&&(F=ct.toArray(W)))return Y=s2(Y),F.forEach(function(P,j){!(ct.isUndefined(P)||P===null)&&t.append(p===!0?_M([Y],j,l):p===null?Y:Y+"[]",y(P))}),!1}return A0(W)?!0:(t.append(_M(B,Y,l),y(W)),!1)}const E=[],A=Object.assign(EP,{defaultVisitor:T,convertValue:y,isVisitable:A0});function H(W,Y){if(!ct.isUndefined(W)){if(E.indexOf(W)!==-1)throw Error("Circular reference detected in "+Y.join("."));E.push(W),ct.forEach(W,function(F,O){(!(ct.isUndefined(F)||F===null)&&a.call(t,F,ct.isString(O)?O.trim():O,Y,A))===!0&&H(F,Y?Y.concat(O):[O])}),E.pop()}}if(!ct.isObject(e))throw new TypeError("data must be an object");return H(e),t}function yM(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,function(o){return t[o]})}function Lw(e,t){this._pairs=[],e&&Qg(e,this,t)}const a2=Lw.prototype;a2.append=function(t,r){this._pairs.push([t,r])};a2.toString=function(t){const r=t?function(o){return t.call(this,o,yM)}:yM;return this._pairs.map(function(a){return r(a[0])+"="+r(a[1])},"").join("&")};function kP(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function l2(e,t,r){if(!t)return e;const o=r&&r.encode||kP,a=r&&r.serialize;let l;if(a?l=a(t,r):l=ct.isURLSearchParams(t)?t.toString():new Lw(t,r).toString(o),l){const p=e.indexOf("#");p!==-1&&(e=e.slice(0,p)),e+=(e.indexOf("?")===-1?"?":"&")+l}return e}class wM{constructor(){this.handlers=[]}use(t,r,o){return this.handlers.push({fulfilled:t,rejected:r,synchronous:o?o.synchronous:!1,runWhen:o?o.runWhen:null}),this.handlers.length-1}eject(t){this.handlers[t]&&(this.handlers[t]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(t){ct.forEach(this.handlers,function(o){o!==null&&t(o)})}}const u2={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},CP=typeof URLSearchParams<"u"?URLSearchParams:Lw,PP=typeof FormData<"u"?FormData:null,$P=typeof Blob<"u"?Blob:null,AP=(()=>{let e;return typeof navigator<"u"&&((e=navigator.product)==="ReactNative"||e==="NativeScript"||e==="NS")?!1:typeof window<"u"&&typeof document<"u"})(),FP=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function",Fo={isBrowser:!0,classes:{URLSearchParams:CP,FormData:PP,Blob:$P},isStandardBrowserEnv:AP,isStandardBrowserWebWorkerEnv:FP,protocols:["http","https","file","blob","url","data"]};function IP(e,t){return Qg(e,new Fo.classes.URLSearchParams,Object.assign({visitor:function(r,o,a,l){return Fo.isNode&&ct.isBuffer(r)?(this.append(o,r.toString("base64")),!1):l.defaultVisitor.apply(this,arguments)}},t))}function OP(e){return ct.matchAll(/\w+|\[(\w*)]/g,e).map(t=>t[0]==="[]"?"":t[1]||t[0])}function DP(e){const t={},r=Object.keys(e);let o;const a=r.length;let l;for(o=0;o<a;o++)l=r[o],t[l]=e[l];return t}function c2(e){function t(r,o,a,l){let p=r[l++];const w=Number.isFinite(+p),_=l>=r.length;return p=!p&&ct.isArray(a)?a.length:p,_?(ct.hasOwnProp(a,p)?a[p]=[a[p],o]:a[p]=o,!w):((!a[p]||!ct.isObject(a[p]))&&(a[p]=[]),t(r,o,a[p],l)&&ct.isArray(a[p])&&(a[p]=DP(a[p])),!w)}if(ct.isFormData(e)&&ct.isFunction(e.entries)){const r={};return ct.forEachEntry(e,(o,a)=>{t(OP(o),a,r,0)}),r}return null}const zP={"Content-Type":void 0};function LP(e,t,r){if(ct.isString(e))try{return(t||JSON.parse)(e),ct.trim(e)}catch(o){if(o.name!=="SyntaxError")throw o}return(r||JSON.stringify)(e)}const ac={transitional:u2,adapter:["xhr","http"],transformRequest:[function(t,r){const o=r.getContentType()||"",a=o.indexOf("application/json")>-1,l=ct.isObject(t);if(l&&ct.isHTMLForm(t)&&(t=new FormData(t)),ct.isFormData(t))return a&&a?JSON.stringify(c2(t)):t;if(ct.isArrayBuffer(t)||ct.isBuffer(t)||ct.isStream(t)||ct.isFile(t)||ct.isBlob(t))return t;if(ct.isArrayBufferView(t))return t.buffer;if(ct.isURLSearchParams(t))return r.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),t.toString();let w;if(l){if(o.indexOf("application/x-www-form-urlencoded")>-1)return IP(t,this.formSerializer).toString();if((w=ct.isFileList(t))||o.indexOf("multipart/form-data")>-1){const _=this.env&&this.env.FormData;return Qg(w?{"files[]":t}:t,_&&new _,this.formSerializer)}}return l||a?(r.setContentType("application/json",!1),LP(t)):t}],transformResponse:[function(t){const r=this.transitional||ac.transitional,o=r&&r.forcedJSONParsing,a=this.responseType==="json";if(t&&ct.isString(t)&&(o&&!this.responseType||a)){const p=!(r&&r.silentJSONParsing)&&a;try{return JSON.parse(t)}catch(w){if(p)throw w.name==="SyntaxError"?Hn.from(w,Hn.ERR_BAD_RESPONSE,this,null,this.response):w}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Fo.classes.FormData,Blob:Fo.classes.Blob},validateStatus:function(t){return t>=200&&t<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};ct.forEach(["delete","get","head"],function(t){ac.headers[t]={}});ct.forEach(["post","put","patch"],function(t){ac.headers[t]=ct.merge(zP)});const RP=ct.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),BP=e=>{const t={};let r,o,a;return e&&e.split(`
`).forEach(function(p){a=p.indexOf(":"),r=p.substring(0,a).trim().toLowerCase(),o=p.substring(a+1).trim(),!(!r||t[r]&&RP[r])&&(r==="set-cookie"?t[r]?t[r].push(o):t[r]=[o]:t[r]=t[r]?t[r]+", "+o:o)}),t},vM=Symbol("internals");function Ff(e){return e&&String(e).trim().toLowerCase()}function Zm(e){return e===!1||e==null?e:ct.isArray(e)?e.map(Zm):String(e)}function NP(e){const t=Object.create(null),r=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let o;for(;o=r.exec(e);)t[o[1]]=o[2];return t}const UP=e=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());function vy(e,t,r,o,a){if(ct.isFunction(o))return o.call(this,t,r);if(a&&(t=r),!!ct.isString(t)){if(ct.isString(o))return t.indexOf(o)!==-1;if(ct.isRegExp(o))return o.test(t)}}function jP(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(t,r,o)=>r.toUpperCase()+o)}function VP(e,t){const r=ct.toCamelCase(" "+t);["get","set","has"].forEach(o=>{Object.defineProperty(e,o+r,{value:function(a,l,p){return this[o].call(this,t,a,l,p)},configurable:!0})})}class Ki{constructor(t){t&&this.set(t)}set(t,r,o){const a=this;function l(w,_,y){const T=Ff(_);if(!T)throw new Error("header name must be a non-empty string");const E=ct.findKey(a,T);(!E||a[E]===void 0||y===!0||y===void 0&&a[E]!==!1)&&(a[E||_]=Zm(w))}const p=(w,_)=>ct.forEach(w,(y,T)=>l(y,T,_));return ct.isPlainObject(t)||t instanceof this.constructor?p(t,r):ct.isString(t)&&(t=t.trim())&&!UP(t)?p(BP(t),r):t!=null&&l(r,t,o),this}get(t,r){if(t=Ff(t),t){const o=ct.findKey(this,t);if(o){const a=this[o];if(!r)return a;if(r===!0)return NP(a);if(ct.isFunction(r))return r.call(this,a,o);if(ct.isRegExp(r))return r.exec(a);throw new TypeError("parser must be boolean|regexp|function")}}}has(t,r){if(t=Ff(t),t){const o=ct.findKey(this,t);return!!(o&&this[o]!==void 0&&(!r||vy(this,this[o],o,r)))}return!1}delete(t,r){const o=this;let a=!1;function l(p){if(p=Ff(p),p){const w=ct.findKey(o,p);w&&(!r||vy(o,o[w],w,r))&&(delete o[w],a=!0)}}return ct.isArray(t)?t.forEach(l):l(t),a}clear(t){const r=Object.keys(this);let o=r.length,a=!1;for(;o--;){const l=r[o];(!t||vy(this,this[l],l,t,!0))&&(delete this[l],a=!0)}return a}normalize(t){const r=this,o={};return ct.forEach(this,(a,l)=>{const p=ct.findKey(o,l);if(p){r[p]=Zm(a),delete r[l];return}const w=t?jP(l):String(l).trim();w!==l&&delete r[l],r[w]=Zm(a),o[w]=!0}),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(t){const r=Object.create(null);return ct.forEach(this,(o,a)=>{o!=null&&o!==!1&&(r[a]=t&&ct.isArray(o)?o.join(", "):o)}),r}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([t,r])=>t+": "+r).join(`
`)}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...r){const o=new this(t);return r.forEach(a=>o.set(a)),o}static accessor(t){const o=(this[vM]=this[vM]={accessors:{}}).accessors,a=this.prototype;function l(p){const w=Ff(p);o[w]||(VP(a,p),o[w]=!0)}return ct.isArray(t)?t.forEach(l):l(t),this}}Ki.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);ct.freezeMethods(Ki.prototype);ct.freezeMethods(Ki);function by(e,t){const r=this||ac,o=t||r,a=Ki.from(o.headers);let l=o.data;return ct.forEach(e,function(w){l=w.call(r,l,a.normalize(),t?t.status:void 0)}),a.normalize(),l}function d2(e){return!!(e&&e.__CANCEL__)}function bh(e,t,r){Hn.call(this,e??"canceled",Hn.ERR_CANCELED,t,r),this.name="CanceledError"}ct.inherits(bh,Hn,{__CANCEL__:!0});function WP(e,t,r){const o=r.config.validateStatus;!r.status||!o||o(r.status)?e(r):t(new Hn("Request failed with status code "+r.status,[Hn.ERR_BAD_REQUEST,Hn.ERR_BAD_RESPONSE][Math.floor(r.status/100)-4],r.config,r.request,r))}const GP=Fo.isStandardBrowserEnv?function(){return{write:function(r,o,a,l,p,w){const _=[];_.push(r+"="+encodeURIComponent(o)),ct.isNumber(a)&&_.push("expires="+new Date(a).toGMTString()),ct.isString(l)&&_.push("path="+l),ct.isString(p)&&_.push("domain="+p),w===!0&&_.push("secure"),document.cookie=_.join("; ")},read:function(r){const o=document.cookie.match(new RegExp("(^|;\\s*)("+r+")=([^;]*)"));return o?decodeURIComponent(o[3]):null},remove:function(r){this.write(r,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function qP(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}function HP(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}function p2(e,t){return e&&!qP(t)?HP(e,t):t}const KP=Fo.isStandardBrowserEnv?function(){const t=/(msie|trident)/i.test(navigator.userAgent),r=document.createElement("a");let o;function a(l){let p=l;return t&&(r.setAttribute("href",p),p=r.href),r.setAttribute("href",p),{href:r.href,protocol:r.protocol?r.protocol.replace(/:$/,""):"",host:r.host,search:r.search?r.search.replace(/^\?/,""):"",hash:r.hash?r.hash.replace(/^#/,""):"",hostname:r.hostname,port:r.port,pathname:r.pathname.charAt(0)==="/"?r.pathname:"/"+r.pathname}}return o=a(window.location.href),function(p){const w=ct.isString(p)?a(p):p;return w.protocol===o.protocol&&w.host===o.host}}():function(){return function(){return!0}}();function XP(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}function QP(e,t){e=e||10;const r=new Array(e),o=new Array(e);let a=0,l=0,p;return t=t!==void 0?t:1e3,function(_){const y=Date.now(),T=o[l];p||(p=y),r[a]=_,o[a]=y;let E=l,A=0;for(;E!==a;)A+=r[E++],E=E%e;if(a=(a+1)%e,a===l&&(l=(l+1)%e),y-p<t)return;const H=T&&y-T;return H?Math.round(A*1e3/H):void 0}}function bM(e,t){let r=0;const o=QP(50,250);return a=>{const l=a.loaded,p=a.lengthComputable?a.total:void 0,w=l-r,_=o(w),y=l<=p;r=l;const T={loaded:l,total:p,progress:p?l/p:void 0,bytes:w,rate:_||void 0,estimated:_&&p&&y?(p-l)/_:void 0,event:a};T[t?"download":"upload"]=!0,e(T)}}const YP=typeof XMLHttpRequest<"u",JP=YP&&function(e){return new Promise(function(r,o){let a=e.data;const l=Ki.from(e.headers).normalize(),p=e.responseType;let w;function _(){e.cancelToken&&e.cancelToken.unsubscribe(w),e.signal&&e.signal.removeEventListener("abort",w)}ct.isFormData(a)&&(Fo.isStandardBrowserEnv||Fo.isStandardBrowserWebWorkerEnv?l.setContentType(!1):l.setContentType("multipart/form-data;",!1));let y=new XMLHttpRequest;if(e.auth){const H=e.auth.username||"",W=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";l.set("Authorization","Basic "+btoa(H+":"+W))}const T=p2(e.baseURL,e.url);y.open(e.method.toUpperCase(),l2(T,e.params,e.paramsSerializer),!0),y.timeout=e.timeout;function E(){if(!y)return;const H=Ki.from("getAllResponseHeaders"in y&&y.getAllResponseHeaders()),Y={data:!p||p==="text"||p==="json"?y.responseText:y.response,status:y.status,statusText:y.statusText,headers:H,config:e,request:y};WP(function(F){r(F),_()},function(F){o(F),_()},Y),y=null}if("onloadend"in y?y.onloadend=E:y.onreadystatechange=function(){!y||y.readyState!==4||y.status===0&&!(y.responseURL&&y.responseURL.indexOf("file:")===0)||setTimeout(E)},y.onabort=function(){y&&(o(new Hn("Request aborted",Hn.ECONNABORTED,e,y)),y=null)},y.onerror=function(){o(new Hn("Network Error",Hn.ERR_NETWORK,e,y)),y=null},y.ontimeout=function(){let W=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded";const Y=e.transitional||u2;e.timeoutErrorMessage&&(W=e.timeoutErrorMessage),o(new Hn(W,Y.clarifyTimeoutError?Hn.ETIMEDOUT:Hn.ECONNABORTED,e,y)),y=null},Fo.isStandardBrowserEnv){const H=(e.withCredentials||KP(T))&&e.xsrfCookieName&&GP.read(e.xsrfCookieName);H&&l.set(e.xsrfHeaderName,H)}a===void 0&&l.setContentType(null),"setRequestHeader"in y&&ct.forEach(l.toJSON(),function(W,Y){y.setRequestHeader(Y,W)}),ct.isUndefined(e.withCredentials)||(y.withCredentials=!!e.withCredentials),p&&p!=="json"&&(y.responseType=e.responseType),typeof e.onDownloadProgress=="function"&&y.addEventListener("progress",bM(e.onDownloadProgress,!0)),typeof e.onUploadProgress=="function"&&y.upload&&y.upload.addEventListener("progress",bM(e.onUploadProgress)),(e.cancelToken||e.signal)&&(w=H=>{y&&(o(!H||H.type?new bh(null,e,y):H),y.abort(),y=null)},e.cancelToken&&e.cancelToken.subscribe(w),e.signal&&(e.signal.aborted?w():e.signal.addEventListener("abort",w)));const A=XP(T);if(A&&Fo.protocols.indexOf(A)===-1){o(new Hn("Unsupported protocol "+A+":",Hn.ERR_BAD_REQUEST,e));return}y.send(a||null)})},eg={http:TP,xhr:JP};ct.forEach(eg,(e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch{}Object.defineProperty(e,"adapterName",{value:t})}});const ZP={getAdapter:e=>{e=ct.isArray(e)?e:[e];const{length:t}=e;let r,o;for(let a=0;a<t&&(r=e[a],!(o=ct.isString(r)?eg[r.toLowerCase()]:r));a++);if(!o)throw o===!1?new Hn(`Adapter ${r} is not supported by the environment`,"ERR_NOT_SUPPORT"):new Error(ct.hasOwnProp(eg,r)?`Adapter '${r}' is not available in the build`:`Unknown adapter '${r}'`);if(!ct.isFunction(o))throw new TypeError("adapter is not a function");return o},adapters:eg};function My(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new bh(null,e)}function MM(e){return My(e),e.headers=Ki.from(e.headers),e.data=by.call(e,e.transformRequest),["post","put","patch"].indexOf(e.method)!==-1&&e.headers.setContentType("application/x-www-form-urlencoded",!1),ZP.getAdapter(e.adapter||ac.adapter)(e).then(function(o){return My(e),o.data=by.call(e,e.transformResponse,o),o.headers=Ki.from(o.headers),o},function(o){return d2(o)||(My(e),o&&o.response&&(o.response.data=by.call(e,e.transformResponse,o.response),o.response.headers=Ki.from(o.response.headers))),Promise.reject(o)})}const xM=e=>e instanceof Ki?e.toJSON():e;function nc(e,t){t=t||{};const r={};function o(y,T,E){return ct.isPlainObject(y)&&ct.isPlainObject(T)?ct.merge.call({caseless:E},y,T):ct.isPlainObject(T)?ct.merge({},T):ct.isArray(T)?T.slice():T}function a(y,T,E){if(ct.isUndefined(T)){if(!ct.isUndefined(y))return o(void 0,y,E)}else return o(y,T,E)}function l(y,T){if(!ct.isUndefined(T))return o(void 0,T)}function p(y,T){if(ct.isUndefined(T)){if(!ct.isUndefined(y))return o(void 0,y)}else return o(void 0,T)}function w(y,T,E){if(E in t)return o(y,T);if(E in e)return o(void 0,y)}const _={url:l,method:l,data:l,baseURL:p,transformRequest:p,transformResponse:p,paramsSerializer:p,timeout:p,timeoutMessage:p,withCredentials:p,adapter:p,responseType:p,xsrfCookieName:p,xsrfHeaderName:p,onUploadProgress:p,onDownloadProgress:p,decompress:p,maxContentLength:p,maxBodyLength:p,beforeRedirect:p,transport:p,httpAgent:p,httpsAgent:p,cancelToken:p,socketPath:p,responseEncoding:p,validateStatus:w,headers:(y,T)=>a(xM(y),xM(T),!0)};return ct.forEach(Object.keys(Object.assign({},e,t)),function(T){const E=_[T]||a,A=E(e[T],t[T],T);ct.isUndefined(A)&&E!==w||(r[T]=A)}),r}const f2="1.4.0",Rw={};["object","boolean","number","function","string","symbol"].forEach((e,t)=>{Rw[e]=function(o){return typeof o===e||"a"+(t<1?"n ":" ")+e}});const TM={};Rw.transitional=function(t,r,o){function a(l,p){return"[Axios v"+f2+"] Transitional option '"+l+"'"+p+(o?". "+o:"")}return(l,p,w)=>{if(t===!1)throw new Hn(a(p," has been removed"+(r?" in "+r:"")),Hn.ERR_DEPRECATED);return r&&!TM[p]&&(TM[p]=!0,console.warn(a(p," has been deprecated since v"+r+" and will be removed in the near future"))),t?t(l,p,w):!0}};function e$(e,t,r){if(typeof e!="object")throw new Hn("options must be an object",Hn.ERR_BAD_OPTION_VALUE);const o=Object.keys(e);let a=o.length;for(;a-- >0;){const l=o[a],p=t[l];if(p){const w=e[l],_=w===void 0||p(w,l,e);if(_!==!0)throw new Hn("option "+l+" must be "+_,Hn.ERR_BAD_OPTION_VALUE);continue}if(r!==!0)throw new Hn("Unknown option "+l,Hn.ERR_BAD_OPTION)}}const F0={assertOptions:e$,validators:Rw},Ds=F0.validators;class La{constructor(t){this.defaults=t,this.interceptors={request:new wM,response:new wM}}request(t,r){typeof t=="string"?(r=r||{},r.url=t):r=t||{},r=nc(this.defaults,r);const{transitional:o,paramsSerializer:a,headers:l}=r;o!==void 0&&F0.assertOptions(o,{silentJSONParsing:Ds.transitional(Ds.boolean),forcedJSONParsing:Ds.transitional(Ds.boolean),clarifyTimeoutError:Ds.transitional(Ds.boolean)},!1),a!=null&&(ct.isFunction(a)?r.paramsSerializer={serialize:a}:F0.assertOptions(a,{encode:Ds.function,serialize:Ds.function},!0)),r.method=(r.method||this.defaults.method||"get").toLowerCase();let p;p=l&&ct.merge(l.common,l[r.method]),p&&ct.forEach(["delete","get","head","post","put","patch","common"],W=>{delete l[W]}),r.headers=Ki.concat(p,l);const w=[];let _=!0;this.interceptors.request.forEach(function(Y){typeof Y.runWhen=="function"&&Y.runWhen(r)===!1||(_=_&&Y.synchronous,w.unshift(Y.fulfilled,Y.rejected))});const y=[];this.interceptors.response.forEach(function(Y){y.push(Y.fulfilled,Y.rejected)});let T,E=0,A;if(!_){const W=[MM.bind(this),void 0];for(W.unshift.apply(W,w),W.push.apply(W,y),A=W.length,T=Promise.resolve(r);E<A;)T=T.then(W[E++],W[E++]);return T}A=w.length;let H=r;for(E=0;E<A;){const W=w[E++],Y=w[E++];try{H=W(H)}catch(B){Y.call(this,B);break}}try{T=MM.call(this,H)}catch(W){return Promise.reject(W)}for(E=0,A=y.length;E<A;)T=T.then(y[E++],y[E++]);return T}getUri(t){t=nc(this.defaults,t);const r=p2(t.baseURL,t.url);return l2(r,t.params,t.paramsSerializer)}}ct.forEach(["delete","get","head","options"],function(t){La.prototype[t]=function(r,o){return this.request(nc(o||{},{method:t,url:r,data:(o||{}).data}))}});ct.forEach(["post","put","patch"],function(t){function r(o){return function(l,p,w){return this.request(nc(w||{},{method:t,headers:o?{"Content-Type":"multipart/form-data"}:{},url:l,data:p}))}}La.prototype[t]=r(),La.prototype[t+"Form"]=r(!0)});class Bw{constructor(t){if(typeof t!="function")throw new TypeError("executor must be a function.");let r;this.promise=new Promise(function(l){r=l});const o=this;this.promise.then(a=>{if(!o._listeners)return;let l=o._listeners.length;for(;l-- >0;)o._listeners[l](a);o._listeners=null}),this.promise.then=a=>{let l;const p=new Promise(w=>{o.subscribe(w),l=w}).then(a);return p.cancel=function(){o.unsubscribe(l)},p},t(function(l,p,w){o.reason||(o.reason=new bh(l,p,w),r(o.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(t){if(this.reason){t(this.reason);return}this._listeners?this._listeners.push(t):this._listeners=[t]}unsubscribe(t){if(!this._listeners)return;const r=this._listeners.indexOf(t);r!==-1&&this._listeners.splice(r,1)}static source(){let t;return{token:new Bw(function(a){t=a}),cancel:t}}}function t$(e){return function(r){return e.apply(null,r)}}function n$(e){return ct.isObject(e)&&e.isAxiosError===!0}const I0={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(I0).forEach(([e,t])=>{I0[t]=e});function h2(e){const t=new La(e),r=QT(La.prototype.request,t);return ct.extend(r,La.prototype,t,{allOwnKeys:!0}),ct.extend(r,t,null,{allOwnKeys:!0}),r.create=function(a){return h2(nc(e,a))},r}const Br=h2(ac);Br.Axios=La;Br.CanceledError=bh;Br.CancelToken=Bw;Br.isCancel=d2;Br.VERSION=f2;Br.toFormData=Qg;Br.AxiosError=Hn;Br.Cancel=Br.CanceledError;Br.all=function(t){return Promise.all(t)};Br.spread=t$;Br.isAxiosError=n$;Br.mergeConfig=nc;Br.AxiosHeaders=Ki;Br.formToJSON=e=>c2(ct.isHTMLForm(e)?new FormData(e):e);Br.HttpStatusCode=I0;Br.default=Br;var r$=Object.defineProperty,i$=(e,t,r)=>t in e?r$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,xy=(e,t,r)=>(i$(e,typeof t!="symbol"?t+"":t,r),r);let o$=class{constructor(){xy(this,"current",this.detect()),xy(this,"handoffState","pending"),xy(this,"currentId",0)}set(t){this.current!==t&&(this.handoffState="pending",this.currentId=0,this.current=t)}reset(){this.set(this.detect())}nextId(){return++this.currentId}get isServer(){return this.current==="server"}get isClient(){return this.current==="client"}detect(){return typeof window>"u"||typeof document>"u"?"server":"client"}handoff(){this.handoffState==="pending"&&(this.handoffState="complete")}get isHandoffComplete(){return this.handoffState==="complete"}},rs=new o$,Lo=(e,t)=>{rs.isServer?Le.useEffect(e,t):Le.useLayoutEffect(e,t)};function is(e){let t=Le.useRef(e);return Lo(()=>{t.current=e},[e]),t}function Mh(e){typeof queueMicrotask=="function"?queueMicrotask(e):Promise.resolve().then(e).catch(t=>setTimeout(()=>{throw t}))}function lc(){let e=[],t={addEventListener(r,o,a,l){return r.addEventListener(o,a,l),t.add(()=>r.removeEventListener(o,a,l))},requestAnimationFrame(...r){let o=requestAnimationFrame(...r);return t.add(()=>cancelAnimationFrame(o))},nextFrame(...r){return t.requestAnimationFrame(()=>t.requestAnimationFrame(...r))},setTimeout(...r){let o=setTimeout(...r);return t.add(()=>clearTimeout(o))},microTask(...r){let o={current:!0};return Mh(()=>{o.current&&r[0]()}),t.add(()=>{o.current=!1})},style(r,o,a){let l=r.style.getPropertyValue(o);return Object.assign(r.style,{[o]:a}),this.add(()=>{Object.assign(r.style,{[o]:l})})},group(r){let o=lc();return r(o),this.add(()=>o.dispose())},add(r){return e.push(r),()=>{let o=e.indexOf(r);if(o>=0)for(let a of e.splice(o,1))a()}},dispose(){for(let r of e.splice(0))r()}};return t}function Nw(){let[e]=Le.useState(lc);return Le.useEffect(()=>()=>e.dispose(),[e]),e}let Gr=function(e){let t=is(e);return qn.useCallback((...r)=>t.current(...r),[t])};function uc(){let[e,t]=Le.useState(rs.isHandoffComplete);return e&&rs.isHandoffComplete===!1&&t(!1),Le.useEffect(()=>{e!==!0&&t(!0)},[e]),Le.useEffect(()=>rs.handoff(),[]),e}var SM;let cc=(SM=qn.useId)!=null?SM:function(){let e=uc(),[t,r]=qn.useState(e?()=>rs.nextId():null);return Lo(()=>{t===null&&r(rs.nextId())},[t]),t!=null?""+t:void 0};function ii(e,t,...r){if(e in t){let a=t[e];return typeof a=="function"?a(...r):a}let o=new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map(a=>`"${a}"`).join(", ")}.`);throw Error.captureStackTrace&&Error.captureStackTrace(o,ii),o}function m2(e){return rs.isServer?null:e instanceof Node?e.ownerDocument:e!=null&&e.hasOwnProperty("current")&&e.current instanceof Node?e.current.ownerDocument:document}let O0=["[contentEditable=true]","[tabindex]","a[href]","area[href]","button:not([disabled])","iframe","input:not([disabled])","select:not([disabled])","textarea:not([disabled])"].map(e=>`${e}:not([tabindex='-1'])`).join(",");var $a=(e=>(e[e.First=1]="First",e[e.Previous=2]="Previous",e[e.Next=4]="Next",e[e.Last=8]="Last",e[e.WrapAround=16]="WrapAround",e[e.NoScroll=32]="NoScroll",e))($a||{}),g2=(e=>(e[e.Error=0]="Error",e[e.Overflow=1]="Overflow",e[e.Success=2]="Success",e[e.Underflow=3]="Underflow",e))(g2||{}),s$=(e=>(e[e.Previous=-1]="Previous",e[e.Next=1]="Next",e))(s$||{});function a$(e=document.body){return e==null?[]:Array.from(e.querySelectorAll(O0)).sort((t,r)=>Math.sign((t.tabIndex||Number.MAX_SAFE_INTEGER)-(r.tabIndex||Number.MAX_SAFE_INTEGER)))}var _2=(e=>(e[e.Strict=0]="Strict",e[e.Loose=1]="Loose",e))(_2||{});function l$(e,t=0){var r;return e===((r=m2(e))==null?void 0:r.body)?!1:ii(t,{0(){return e.matches(O0)},1(){let o=e;for(;o!==null;){if(o.matches(O0))return!0;o=o.parentElement}return!1}})}var u$=(e=>(e[e.Keyboard=0]="Keyboard",e[e.Mouse=1]="Mouse",e))(u$||{});typeof window<"u"&&typeof document<"u"&&(document.addEventListener("keydown",e=>{e.metaKey||e.altKey||e.ctrlKey||(document.documentElement.dataset.headlessuiFocusVisible="")},!0),document.addEventListener("click",e=>{e.detail===1?delete document.documentElement.dataset.headlessuiFocusVisible:e.detail===0&&(document.documentElement.dataset.headlessuiFocusVisible="")},!0));function Ra(e){e==null||e.focus({preventScroll:!0})}let c$=["textarea","input"].join(",");function d$(e){var t,r;return(r=(t=e==null?void 0:e.matches)==null?void 0:t.call(e,c$))!=null?r:!1}function p$(e,t=r=>r){return e.slice().sort((r,o)=>{let a=t(r),l=t(o);if(a===null||l===null)return 0;let p=a.compareDocumentPosition(l);return p&Node.DOCUMENT_POSITION_FOLLOWING?-1:p&Node.DOCUMENT_POSITION_PRECEDING?1:0})}function tg(e,t,{sorted:r=!0,relativeTo:o=null,skipElements:a=[]}={}){let l=Array.isArray(e)?e.length>0?e[0].ownerDocument:document:e.ownerDocument,p=Array.isArray(e)?r?p$(e):e:a$(e);a.length>0&&p.length>1&&(p=p.filter(H=>!a.includes(H))),o=o??l.activeElement;let w=(()=>{if(t&5)return 1;if(t&10)return-1;throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")})(),_=(()=>{if(t&1)return 0;if(t&2)return Math.max(0,p.indexOf(o))-1;if(t&4)return Math.max(0,p.indexOf(o))+1;if(t&8)return p.length-1;throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")})(),y=t&32?{preventScroll:!0}:{},T=0,E=p.length,A;do{if(T>=E||T+E<=0)return 0;let H=_+T;if(t&16)H=(H+E)%E;else{if(H<0)return 3;if(H>=E)return 1}A=p[H],A==null||A.focus(y),T+=w}while(A!==l.activeElement);return t&6&&d$(A)&&A.select(),2}function Ty(e,t,r){let o=is(t);Le.useEffect(()=>{function a(l){o.current(l)}return document.addEventListener(e,a,r),()=>document.removeEventListener(e,a,r)},[e,r])}function f$(e,t,r=!0){let o=Le.useRef(!1);Le.useEffect(()=>{requestAnimationFrame(()=>{o.current=r})},[r]);function a(p,w){if(!o.current||p.defaultPrevented)return;let _=function T(E){return typeof E=="function"?T(E()):Array.isArray(E)||E instanceof Set?E:[E]}(e),y=w(p);if(y!==null&&y.getRootNode().contains(y)){for(let T of _){if(T===null)continue;let E=T instanceof HTMLElement?T:T.current;if(E!=null&&E.contains(y)||p.composed&&p.composedPath().includes(E))return}return!l$(y,_2.Loose)&&y.tabIndex!==-1&&p.preventDefault(),t(p,y)}}let l=Le.useRef(null);Ty("mousedown",p=>{var w,_;o.current&&(l.current=((_=(w=p.composedPath)==null?void 0:w.call(p))==null?void 0:_[0])||p.target)},!0),Ty("click",p=>{l.current&&(a(p,()=>l.current),l.current=null)},!0),Ty("blur",p=>a(p,()=>window.document.activeElement instanceof HTMLIFrameElement?window.document.activeElement:null),!0)}let y2=Symbol();function h$(e,t=!0){return Object.assign(e,{[y2]:t})}function _o(...e){let t=Le.useRef(e);Le.useEffect(()=>{t.current=e},[e]);let r=Gr(o=>{for(let a of t.current)a!=null&&(typeof a=="function"?a(o):a.current=o)});return e.every(o=>o==null||(o==null?void 0:o[y2]))?void 0:r}function D0(...e){return e.filter(Boolean).join(" ")}var kg=(e=>(e[e.None=0]="None",e[e.RenderStrategy=1]="RenderStrategy",e[e.Static=2]="Static",e))(kg||{}),ts=(e=>(e[e.Unmount=0]="Unmount",e[e.Hidden=1]="Hidden",e))(ts||{});function Yi({ourProps:e,theirProps:t,slot:r,defaultTag:o,features:a,visible:l=!0,name:p}){let w=w2(t,e);if(l)return Bm(w,r,o,p);let _=a??0;if(_&2){let{static:y=!1,...T}=w;if(y)return Bm(T,r,o,p)}if(_&1){let{unmount:y=!0,...T}=w;return ii(y?0:1,{0(){return null},1(){return Bm({...T,hidden:!0,style:{display:"none"}},r,o,p)}})}return Bm(w,r,o,p)}function Bm(e,t={},r,o){let{as:a=r,children:l,refName:p="ref",...w}=Sy(e,["unmount","static"]),_=e.ref!==void 0?{[p]:e.ref}:{},y=typeof l=="function"?l(t):l;"className"in w&&w.className&&typeof w.className=="function"&&(w.className=w.className(t));let T={};if(t){let E=!1,A=[];for(let[H,W]of Object.entries(t))typeof W=="boolean"&&(E=!0),W===!0&&A.push(H);E&&(T["data-headlessui-state"]=A.join(" "))}if(a===Le.Fragment&&Object.keys(EM(w)).length>0){if(!Le.isValidElement(y)||Array.isArray(y)&&y.length>1)throw new Error(['Passing props on "Fragment"!',"",`The current component <${o} /> is rendering a "Fragment".`,"However we need to passthrough the following props:",Object.keys(w).map(W=>`  - ${W}`).join(`
`),"","You can apply a few solutions:",['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".',"Render a single element as the child so that we can forward the props onto that element."].map(W=>`  - ${W}`).join(`
`)].join(`
`));let E=y.props,A=typeof(E==null?void 0:E.className)=="function"?(...W)=>D0(E==null?void 0:E.className(...W),w.className):D0(E==null?void 0:E.className,w.className),H=A?{className:A}:{};return Le.cloneElement(y,Object.assign({},w2(y.props,EM(Sy(w,["ref"]))),T,_,m$(y.ref,_.ref),H))}return Le.createElement(a,Object.assign({},Sy(w,["ref"]),a!==Le.Fragment&&_,a!==Le.Fragment&&T),y)}function m$(...e){return{ref:e.every(t=>t==null)?void 0:t=>{for(let r of e)r!=null&&(typeof r=="function"?r(t):r.current=t)}}}function w2(...e){if(e.length===0)return{};if(e.length===1)return e[0];let t={},r={};for(let o of e)for(let a in o)a.startsWith("on")&&typeof o[a]=="function"?(r[a]!=null||(r[a]=[]),r[a].push(o[a])):t[a]=o[a];if(t.disabled||t["aria-disabled"])return Object.assign(t,Object.fromEntries(Object.keys(r).map(o=>[o,void 0])));for(let o in r)Object.assign(t,{[o](a,...l){let p=r[o];for(let w of p){if((a instanceof Event||(a==null?void 0:a.nativeEvent)instanceof Event)&&a.defaultPrevented)return;w(a,...l)}}});return t}function Di(e){var t;return Object.assign(Le.forwardRef(e),{displayName:(t=e.displayName)!=null?t:e.name})}function EM(e){let t=Object.assign({},e);for(let r in t)t[r]===void 0&&delete t[r];return t}function Sy(e,t=[]){let r=Object.assign({},e);for(let o of t)o in r&&delete r[o];return r}function g$(e){let t=e.parentElement,r=null;for(;t&&!(t instanceof HTMLFieldSetElement);)t instanceof HTMLLegendElement&&(r=t),t=t.parentElement;let o=(t==null?void 0:t.getAttribute("disabled"))==="";return o&&_$(r)?!1:o}function _$(e){if(!e)return!1;let t=e.previousElementSibling;for(;t!==null;){if(t instanceof HTMLLegendElement)return!1;t=t.previousElementSibling}return!0}let y$="div";var Cg=(e=>(e[e.None=1]="None",e[e.Focusable=2]="Focusable",e[e.Hidden=4]="Hidden",e))(Cg||{});function w$(e,t){let{features:r=1,...o}=e,a={ref:t,"aria-hidden":(r&2)===2?!0:void 0,style:{position:"fixed",top:1,left:1,width:1,height:0,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",borderWidth:"0",...(r&4)===4&&(r&2)!==2&&{display:"none"}}};return Yi({ourProps:a,theirProps:o,slot:{},defaultTag:y$,name:"Hidden"})}let z0=Di(w$),Uw=Le.createContext(null);Uw.displayName="OpenClosedContext";var Pi=(e=>(e[e.Open=1]="Open",e[e.Closed=2]="Closed",e[e.Closing=4]="Closing",e[e.Opening=8]="Opening",e))(Pi||{});function jw(){return Le.useContext(Uw)}function v$({value:e,children:t}){return qn.createElement(Uw.Provider,{value:e},t)}var v2=(e=>(e.Space=" ",e.Enter="Enter",e.Escape="Escape",e.Backspace="Backspace",e.Delete="Delete",e.ArrowLeft="ArrowLeft",e.ArrowUp="ArrowUp",e.ArrowRight="ArrowRight",e.ArrowDown="ArrowDown",e.Home="Home",e.End="End",e.PageUp="PageUp",e.PageDown="PageDown",e.Tab="Tab",e))(v2||{});function Vw(e,t){let r=Le.useRef([]),o=Gr(e);Le.useEffect(()=>{let a=[...r.current];for(let[l,p]of t.entries())if(r.current[l]!==p){let w=o(t,a);return r.current=t,w}},[o,...t])}function b$(){return/iPhone/gi.test(window.navigator.platform)||/Mac/gi.test(window.navigator.platform)&&window.navigator.maxTouchPoints>0}function M$(e,t,r){let o=is(t);Le.useEffect(()=>{function a(l){o.current(l)}return window.addEventListener(e,a,r),()=>window.removeEventListener(e,a,r)},[e,r])}var Nf=(e=>(e[e.Forwards=0]="Forwards",e[e.Backwards=1]="Backwards",e))(Nf||{});function x$(){let e=Le.useRef(0);return M$("keydown",t=>{t.key==="Tab"&&(e.current=t.shiftKey?1:0)},!0),e}function xh(){let e=Le.useRef(!1);return Lo(()=>(e.current=!0,()=>{e.current=!1}),[]),e}function Yg(...e){return Le.useMemo(()=>m2(...e),[...e])}function b2(e,t,r,o){let a=is(r);Le.useEffect(()=>{e=e??window;function l(p){a.current(p)}return e.addEventListener(t,l,o),()=>e.removeEventListener(t,l,o)},[e,t,o])}function T$(e){function t(){document.readyState!=="loading"&&(e(),document.removeEventListener("DOMContentLoaded",t))}typeof window<"u"&&typeof document<"u"&&(document.addEventListener("DOMContentLoaded",t),t())}function M2(e){if(!e)return new Set;if(typeof e=="function")return new Set(e());let t=new Set;for(let r of e.current)r.current instanceof HTMLElement&&t.add(r.current);return t}let S$="div";var x2=(e=>(e[e.None=1]="None",e[e.InitialFocus=2]="InitialFocus",e[e.TabLock=4]="TabLock",e[e.FocusLock=8]="FocusLock",e[e.RestoreFocus=16]="RestoreFocus",e[e.All=30]="All",e))(x2||{});function E$(e,t){let r=Le.useRef(null),o=_o(r,t),{initialFocus:a,containers:l,features:p=30,...w}=e;uc()||(p=1);let _=Yg(r);P$({ownerDocument:_},!!(p&16));let y=$$({ownerDocument:_,container:r,initialFocus:a},!!(p&2));A$({ownerDocument:_,container:r,containers:l,previousActiveElement:y},!!(p&8));let T=x$(),E=Gr(Y=>{let B=r.current;B&&(F=>F())(()=>{ii(T.current,{[Nf.Forwards]:()=>{tg(B,$a.First,{skipElements:[Y.relatedTarget]})},[Nf.Backwards]:()=>{tg(B,$a.Last,{skipElements:[Y.relatedTarget]})}})})}),A=Nw(),H=Le.useRef(!1),W={ref:o,onKeyDown(Y){Y.key=="Tab"&&(H.current=!0,A.requestAnimationFrame(()=>{H.current=!1}))},onBlur(Y){let B=M2(l);r.current instanceof HTMLElement&&B.add(r.current);let F=Y.relatedTarget;F instanceof HTMLElement&&F.dataset.headlessuiFocusGuard!=="true"&&(T2(B,F)||(H.current?tg(r.current,ii(T.current,{[Nf.Forwards]:()=>$a.Next,[Nf.Backwards]:()=>$a.Previous})|$a.WrapAround,{relativeTo:Y.target}):Y.target instanceof HTMLElement&&Ra(Y.target)))}};return qn.createElement(qn.Fragment,null,!!(p&4)&&qn.createElement(z0,{as:"button",type:"button","data-headlessui-focus-guard":!0,onFocus:E,features:Cg.Focusable}),Yi({ourProps:W,theirProps:w,defaultTag:S$,name:"FocusTrap"}),!!(p&4)&&qn.createElement(z0,{as:"button",type:"button","data-headlessui-focus-guard":!0,onFocus:E,features:Cg.Focusable}))}let k$=Di(E$),If=Object.assign(k$,{features:x2}),Ns=[];T$(()=>{function e(t){t.target instanceof HTMLElement&&t.target!==document.body&&Ns[0]!==t.target&&(Ns.unshift(t.target),Ns=Ns.filter(r=>r!=null&&r.isConnected),Ns.splice(10))}window.addEventListener("click",e,{capture:!0}),window.addEventListener("mousedown",e,{capture:!0}),window.addEventListener("focus",e,{capture:!0}),document.body.addEventListener("click",e,{capture:!0}),document.body.addEventListener("mousedown",e,{capture:!0}),document.body.addEventListener("focus",e,{capture:!0})});function C$(e=!0){let t=Le.useRef(Ns.slice());return Vw(([r],[o])=>{o===!0&&r===!1&&Mh(()=>{t.current.splice(0)}),o===!1&&r===!0&&(t.current=Ns.slice())},[e,Ns,t]),Gr(()=>{var r;return(r=t.current.find(o=>o!=null&&o.isConnected))!=null?r:null})}function P$({ownerDocument:e},t){let r=C$(t);Vw(()=>{t||(e==null?void 0:e.activeElement)===(e==null?void 0:e.body)&&Ra(r())},[t]);let o=Le.useRef(!1);Le.useEffect(()=>(o.current=!1,()=>{o.current=!0,Mh(()=>{o.current&&Ra(r())})}),[])}function $$({ownerDocument:e,container:t,initialFocus:r},o){let a=Le.useRef(null),l=xh();return Vw(()=>{if(!o)return;let p=t.current;p&&Mh(()=>{if(!l.current)return;let w=e==null?void 0:e.activeElement;if(r!=null&&r.current){if((r==null?void 0:r.current)===w){a.current=w;return}}else if(p.contains(w)){a.current=w;return}r!=null&&r.current?Ra(r.current):tg(p,$a.First)===g2.Error&&console.warn("There are no focusable elements inside the <FocusTrap />"),a.current=e==null?void 0:e.activeElement})},[o]),a}function A$({ownerDocument:e,container:t,containers:r,previousActiveElement:o},a){let l=xh();b2(e==null?void 0:e.defaultView,"focus",p=>{if(!a||!l.current)return;let w=M2(r);t.current instanceof HTMLElement&&w.add(t.current);let _=o.current;if(!_)return;let y=p.target;y&&y instanceof HTMLElement?T2(w,y)?(o.current=y,Ra(y)):(p.preventDefault(),p.stopPropagation(),Ra(_)):Ra(o.current)},!0)}function T2(e,t){for(let r of e)if(r.contains(t))return!0;return!1}let S2=Le.createContext(!1);function F$(){return Le.useContext(S2)}function L0(e){return qn.createElement(S2.Provider,{value:e.force},e.children)}function I$(e){let t=F$(),r=Le.useContext(E2),o=Yg(e),[a,l]=Le.useState(()=>{if(!t&&r!==null||rs.isServer)return null;let p=o==null?void 0:o.getElementById("headlessui-portal-root");if(p)return p;if(o===null)return null;let w=o.createElement("div");return w.setAttribute("id","headlessui-portal-root"),o.body.appendChild(w)});return Le.useEffect(()=>{a!==null&&(o!=null&&o.body.contains(a)||o==null||o.body.appendChild(a))},[a,o]),Le.useEffect(()=>{t||r!==null&&l(r.current)},[r,l,t]),a}let O$=Le.Fragment;function D$(e,t){let r=e,o=Le.useRef(null),a=_o(h$(T=>{o.current=T}),t),l=Yg(o),p=I$(o),[w]=Le.useState(()=>{var T;return rs.isServer?null:(T=l==null?void 0:l.createElement("div"))!=null?T:null}),_=uc(),y=Le.useRef(!1);return Lo(()=>{if(y.current=!1,!(!p||!w))return p.contains(w)||(w.setAttribute("data-headlessui-portal",""),p.appendChild(w)),()=>{y.current=!0,Mh(()=>{var T;y.current&&(!p||!w||(w instanceof Node&&p.contains(w)&&p.removeChild(w),p.childNodes.length<=0&&((T=p.parentElement)==null||T.removeChild(p))))})}},[p,w]),_?!p||!w?null:XT.createPortal(Yi({ourProps:{ref:a},theirProps:r,defaultTag:O$,name:"Portal"}),w):null}let z$=Le.Fragment,E2=Le.createContext(null);function L$(e,t){let{target:r,...o}=e,a={ref:_o(t)};return qn.createElement(E2.Provider,{value:r},Yi({ourProps:a,theirProps:o,defaultTag:z$,name:"Popover.Group"}))}let R$=Di(D$),B$=Di(L$),R0=Object.assign(R$,{Group:B$}),k2=Le.createContext(null);function C2(){let e=Le.useContext(k2);if(e===null){let t=new Error("You used a <Description /> component, but it is not inside a relevant parent.");throw Error.captureStackTrace&&Error.captureStackTrace(t,C2),t}return e}function N$(){let[e,t]=Le.useState([]);return[e.length>0?e.join(" "):void 0,Le.useMemo(()=>function(r){let o=Gr(l=>(t(p=>[...p,l]),()=>t(p=>{let w=p.slice(),_=w.indexOf(l);return _!==-1&&w.splice(_,1),w}))),a=Le.useMemo(()=>({register:o,slot:r.slot,name:r.name,props:r.props}),[o,r.slot,r.name,r.props]);return qn.createElement(k2.Provider,{value:a},r.children)},[t])]}let U$="p";function j$(e,t){let r=cc(),{id:o=`headlessui-description-${r}`,...a}=e,l=C2(),p=_o(t);Lo(()=>l.register(o),[o,l.register]);let w={ref:p,...l.props,id:o};return Yi({ourProps:w,theirProps:a,slot:l.slot||{},defaultTag:U$,name:l.name||"Description"})}let V$=Di(j$),W$=Object.assign(V$,{}),Ww=Le.createContext(()=>{});Ww.displayName="StackContext";var B0=(e=>(e[e.Add=0]="Add",e[e.Remove=1]="Remove",e))(B0||{});function G$(){return Le.useContext(Ww)}function q$({children:e,onUpdate:t,type:r,element:o,enabled:a}){let l=G$(),p=Gr((...w)=>{t==null||t(...w),l(...w)});return Lo(()=>{let w=a===void 0||a===!0;return w&&p(0,r,o),()=>{w&&p(1,r,o)}},[p,r,o,a]),qn.createElement(Ww.Provider,{value:p},e)}function H$(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}const K$=typeof Object.is=="function"?Object.is:H$,{useState:X$,useEffect:Q$,useLayoutEffect:Y$,useDebugValue:J$}=zy;function Z$(e,t,r){const o=t(),[{inst:a},l]=X$({inst:{value:o,getSnapshot:t}});return Y$(()=>{a.value=o,a.getSnapshot=t,Ey(a)&&l({inst:a})},[e,o,t]),Q$(()=>(Ey(a)&&l({inst:a}),e(()=>{Ey(a)&&l({inst:a})})),[e]),J$(o),o}function Ey(e){const t=e.getSnapshot,r=e.value;try{const o=t();return!K$(r,o)}catch{return!0}}function eA(e,t,r){return t()}const tA=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",nA=!tA,rA=nA?eA:Z$,iA="useSyncExternalStore"in zy?(e=>e.useSyncExternalStore)(zy):rA;function oA(e){return iA(e.subscribe,e.getSnapshot,e.getSnapshot)}function sA(e,t){let r=e(),o=new Set;return{getSnapshot(){return r},subscribe(a){return o.add(a),()=>o.delete(a)},dispatch(a,...l){let p=t[a].call(r,...l);p&&(r=p,o.forEach(w=>w()))}}}function aA(){let e;return{before({doc:t}){var r;let o=t.documentElement;e=((r=t.defaultView)!=null?r:window).innerWidth-o.clientWidth},after({doc:t,d:r}){let o=t.documentElement,a=o.clientWidth-o.offsetWidth,l=e-a;r.style(o,"paddingRight",`${l}px`)}}}function lA(){if(!b$())return{};let e;return{before(){e=window.pageYOffset},after({doc:t,d:r,meta:o}){function a(p){return o.containers.flatMap(w=>w()).some(w=>w.contains(p))}r.style(t.body,"marginTop",`-${e}px`),window.scrollTo(0,0);let l=null;r.addEventListener(t,"click",p=>{if(p.target instanceof HTMLElement)try{let w=p.target.closest("a");if(!w)return;let{hash:_}=new URL(w.href),y=t.querySelector(_);y&&!a(y)&&(l=y)}catch{}},!0),r.addEventListener(t,"touchmove",p=>{p.target instanceof HTMLElement&&!a(p.target)&&p.preventDefault()},{passive:!1}),r.add(()=>{window.scrollTo(0,window.pageYOffset+e),l&&l.isConnected&&(l.scrollIntoView({block:"nearest"}),l=null)})}}}function uA(){return{before({doc:e,d:t}){t.style(e.documentElement,"overflow","hidden")}}}function cA(e){let t={};for(let r of e)Object.assign(t,r(t));return t}let Oa=sA(()=>new Map,{PUSH(e,t){var r;let o=(r=this.get(e))!=null?r:{doc:e,count:0,d:lc(),meta:new Set};return o.count++,o.meta.add(t),this.set(e,o),this},POP(e,t){let r=this.get(e);return r&&(r.count--,r.meta.delete(t)),this},SCROLL_PREVENT({doc:e,d:t,meta:r}){let o={doc:e,d:t,meta:cA(r)},a=[lA(),aA(),uA()];a.forEach(({before:l})=>l==null?void 0:l(o)),a.forEach(({after:l})=>l==null?void 0:l(o))},SCROLL_ALLOW({d:e}){e.dispose()},TEARDOWN({doc:e}){this.delete(e)}});Oa.subscribe(()=>{let e=Oa.getSnapshot(),t=new Map;for(let[r]of e)t.set(r,r.documentElement.style.overflow);for(let r of e.values()){let o=t.get(r.doc)==="hidden",a=r.count!==0;(a&&!o||!a&&o)&&Oa.dispatch(r.count>0?"SCROLL_PREVENT":"SCROLL_ALLOW",r),r.count===0&&Oa.dispatch("TEARDOWN",r)}});function dA(e,t,r){let o=oA(Oa),a=e?o.get(e):void 0,l=a?a.count>0:!1;return Lo(()=>{if(!(!e||!t))return Oa.dispatch("PUSH",e,r),()=>Oa.dispatch("POP",e,r)},[t,e]),l}let ky=new Map,Of=new Map;function kM(e,t=!0){Lo(()=>{var r;if(!t)return;let o=typeof e=="function"?e():e.current;if(!o)return;function a(){var p;if(!o)return;let w=(p=Of.get(o))!=null?p:1;if(w===1?Of.delete(o):Of.set(o,w-1),w!==1)return;let _=ky.get(o);_&&(_["aria-hidden"]===null?o.removeAttribute("aria-hidden"):o.setAttribute("aria-hidden",_["aria-hidden"]),o.inert=_.inert,ky.delete(o))}let l=(r=Of.get(o))!=null?r:0;return Of.set(o,l+1),l!==0||(ky.set(o,{"aria-hidden":o.getAttribute("aria-hidden"),inert:o.inert}),o.setAttribute("aria-hidden","true"),o.inert=!0),a},[e,t])}var pA=(e=>(e[e.Open=0]="Open",e[e.Closed=1]="Closed",e))(pA||{}),fA=(e=>(e[e.SetTitleId=0]="SetTitleId",e))(fA||{});let hA={0(e,t){return e.titleId===t.id?e:{...e,titleId:t.id}}},Pg=Le.createContext(null);Pg.displayName="DialogContext";function Th(e){let t=Le.useContext(Pg);if(t===null){let r=new Error(`<${e} /> is missing a parent <Dialog /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(r,Th),r}return t}function mA(e,t,r=()=>[document.body]){dA(e,t,o=>{var a;return{containers:[...(a=o.containers)!=null?a:[],r]}})}function gA(e,t){return ii(t.type,hA,e,t)}let _A="div",yA=kg.RenderStrategy|kg.Static;function wA(e,t){let r=cc(),{id:o=`headlessui-dialog-${r}`,open:a,onClose:l,initialFocus:p,__demoMode:w=!1,..._}=e,[y,T]=Le.useState(0),E=jw();a===void 0&&E!==null&&(a=(E&Pi.Open)===Pi.Open);let A=Le.useRef(null),H=_o(A,t),W=Le.useRef(null),Y=Yg(A),B=e.hasOwnProperty("open")||E!==null,F=e.hasOwnProperty("onClose");if(!B&&!F)throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");if(!B)throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");if(!F)throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");if(typeof a!="boolean")throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${a}`);if(typeof l!="function")throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${l}`);let O=a?0:1,[P,j]=Le.useReducer(gA,{titleId:null,descriptionId:null,panelRef:Le.createRef()}),V=Gr(()=>l(!1)),z=Gr(et=>j({type:0,id:et})),q=uc()?w?!1:O===0:!1,L=y>1,pe=Le.useContext(Pg)!==null,fe=L?"parent":"leaf",xe=E!==null?(E&Pi.Closing)===Pi.Closing:!1,$e=pe||xe?!1:q,Ce=Le.useCallback(()=>{var et,Ie;return(Ie=Array.from((et=Y==null?void 0:Y.querySelectorAll("body > *"))!=null?et:[]).find(rt=>rt.id==="headlessui-portal-root"?!1:rt.contains(W.current)&&rt instanceof HTMLElement))!=null?Ie:null},[W]);kM(Ce,$e);let tt=L?!0:q,Je=Le.useCallback(()=>{var et,Ie;return(Ie=Array.from((et=Y==null?void 0:Y.querySelectorAll("[data-headlessui-portal]"))!=null?et:[]).find(rt=>rt.contains(W.current)&&rt instanceof HTMLElement))!=null?Ie:null},[W]);kM(Je,tt);let it=Gr(()=>{var et,Ie;return[...Array.from((et=Y==null?void 0:Y.querySelectorAll("html > *, body > *, [data-headlessui-portal]"))!=null?et:[]).filter(rt=>!(rt===document.body||rt===document.head||!(rt instanceof HTMLElement)||rt.contains(W.current)||P.panelRef.current&&rt.contains(P.panelRef.current))),(Ie=P.panelRef.current)!=null?Ie:A.current]});f$(()=>it(),V,!(!q||L));let Q=!(L||O!==0);b2(Y==null?void 0:Y.defaultView,"keydown",et=>{Q&&(et.defaultPrevented||et.key===v2.Escape&&(et.preventDefault(),et.stopPropagation(),V()))}),mA(Y,!(xe||O!==0||pe),it),Le.useEffect(()=>{if(O!==0||!A.current)return;let et=new ResizeObserver(Ie=>{for(let rt of Ie){let vt=rt.target.getBoundingClientRect();vt.x===0&&vt.y===0&&vt.width===0&&vt.height===0&&V()}});return et.observe(A.current),()=>et.disconnect()},[O,A,V]);let[ye,Pe]=N$(),Ze=Le.useMemo(()=>[{dialogState:O,close:V,setTitleId:z},P],[O,P,V,z]),me=Le.useMemo(()=>({open:O===0}),[O]),Qe={ref:H,id:o,role:"dialog","aria-modal":O===0?!0:void 0,"aria-labelledby":P.titleId,"aria-describedby":ye};return qn.createElement(q$,{type:"Dialog",enabled:O===0,element:A,onUpdate:Gr((et,Ie)=>{Ie==="Dialog"&&ii(et,{[B0.Add]:()=>T(rt=>rt+1),[B0.Remove]:()=>T(rt=>rt-1)})})},qn.createElement(L0,{force:!0},qn.createElement(R0,null,qn.createElement(Pg.Provider,{value:Ze},qn.createElement(R0.Group,{target:A},qn.createElement(L0,{force:!1},qn.createElement(Pe,{slot:me,name:"Dialog.Description"},qn.createElement(If,{initialFocus:p,containers:it,features:q?ii(fe,{parent:If.features.RestoreFocus,leaf:If.features.All&~If.features.FocusLock}):If.features.None},Yi({ourProps:Qe,theirProps:_,slot:me,defaultTag:_A,features:yA,visible:O===0,name:"Dialog"})))))))),qn.createElement(z0,{features:Cg.Hidden,ref:W}))}let vA="div";function bA(e,t){let r=cc(),{id:o=`headlessui-dialog-overlay-${r}`,...a}=e,[{dialogState:l,close:p}]=Th("Dialog.Overlay"),w=_o(t),_=Gr(T=>{if(T.target===T.currentTarget){if(g$(T.currentTarget))return T.preventDefault();T.preventDefault(),T.stopPropagation(),p()}}),y=Le.useMemo(()=>({open:l===0}),[l]);return Yi({ourProps:{ref:w,id:o,"aria-hidden":!0,onClick:_},theirProps:a,slot:y,defaultTag:vA,name:"Dialog.Overlay"})}let MA="div";function xA(e,t){let r=cc(),{id:o=`headlessui-dialog-backdrop-${r}`,...a}=e,[{dialogState:l},p]=Th("Dialog.Backdrop"),w=_o(t);Le.useEffect(()=>{if(p.panelRef.current===null)throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.")},[p.panelRef]);let _=Le.useMemo(()=>({open:l===0}),[l]);return qn.createElement(L0,{force:!0},qn.createElement(R0,null,Yi({ourProps:{ref:w,id:o,"aria-hidden":!0},theirProps:a,slot:_,defaultTag:MA,name:"Dialog.Backdrop"})))}let TA="div";function SA(e,t){let r=cc(),{id:o=`headlessui-dialog-panel-${r}`,...a}=e,[{dialogState:l},p]=Th("Dialog.Panel"),w=_o(t,p.panelRef),_=Le.useMemo(()=>({open:l===0}),[l]),y=Gr(T=>{T.stopPropagation()});return Yi({ourProps:{ref:w,id:o,onClick:y},theirProps:a,slot:_,defaultTag:TA,name:"Dialog.Panel"})}let EA="h2";function kA(e,t){let r=cc(),{id:o=`headlessui-dialog-title-${r}`,...a}=e,[{dialogState:l,setTitleId:p}]=Th("Dialog.Title"),w=_o(t);Le.useEffect(()=>(p(o),()=>p(null)),[o,p]);let _=Le.useMemo(()=>({open:l===0}),[l]);return Yi({ourProps:{ref:w,id:o},theirProps:a,slot:_,defaultTag:EA,name:"Dialog.Title"})}let CA=Di(wA),PA=Di(xA),$A=Di(SA),AA=Di(bA),FA=Di(kA),Cy=Object.assign(CA,{Backdrop:PA,Panel:$A,Overlay:AA,Title:FA,Description:W$});function IA(e=0){let[t,r]=Le.useState(e),o=xh(),a=Le.useCallback(_=>{o.current&&r(y=>y|_)},[t,o]),l=Le.useCallback(_=>!!(t&_),[t]),p=Le.useCallback(_=>{o.current&&r(y=>y&~_)},[r,o]),w=Le.useCallback(_=>{o.current&&r(y=>y^_)},[r]);return{flags:t,addFlag:a,hasFlag:l,removeFlag:p,toggleFlag:w}}function OA(e){let t={called:!1};return(...r)=>{if(!t.called)return t.called=!0,e(...r)}}function Py(e,...t){e&&t.length>0&&e.classList.add(...t)}function $y(e,...t){e&&t.length>0&&e.classList.remove(...t)}function DA(e,t){let r=lc();if(!e)return r.dispose;let{transitionDuration:o,transitionDelay:a}=getComputedStyle(e),[l,p]=[o,a].map(_=>{let[y=0]=_.split(",").filter(Boolean).map(T=>T.includes("ms")?parseFloat(T):parseFloat(T)*1e3).sort((T,E)=>E-T);return y}),w=l+p;if(w!==0){r.group(y=>{y.setTimeout(()=>{t(),y.dispose()},w),y.addEventListener(e,"transitionrun",T=>{T.target===T.currentTarget&&y.dispose()})});let _=r.addEventListener(e,"transitionend",y=>{y.target===y.currentTarget&&(t(),_())})}else t();return r.add(()=>t()),r.dispose}function zA(e,t,r,o){let a=r?"enter":"leave",l=lc(),p=o!==void 0?OA(o):()=>{};a==="enter"&&(e.removeAttribute("hidden"),e.style.display="");let w=ii(a,{enter:()=>t.enter,leave:()=>t.leave}),_=ii(a,{enter:()=>t.enterTo,leave:()=>t.leaveTo}),y=ii(a,{enter:()=>t.enterFrom,leave:()=>t.leaveFrom});return $y(e,...t.enter,...t.enterTo,...t.enterFrom,...t.leave,...t.leaveFrom,...t.leaveTo,...t.entered),Py(e,...w,...y),l.nextFrame(()=>{$y(e,...y),Py(e,..._),DA(e,()=>($y(e,...w),Py(e,...t.entered),p()))}),l.dispose}function LA({container:e,direction:t,classes:r,onStart:o,onStop:a}){let l=xh(),p=Nw(),w=is(t);Lo(()=>{let _=lc();p.add(_.dispose);let y=e.current;if(y&&w.current!=="idle"&&l.current)return _.dispose(),o.current(w.current),_.add(zA(y,r.current,w.current==="enter",()=>{_.dispose(),a.current(w.current)})),_.dispose},[t])}function ka(e=""){return e.split(" ").filter(t=>t.trim().length>1)}let Jg=Le.createContext(null);Jg.displayName="TransitionContext";var RA=(e=>(e.Visible="visible",e.Hidden="hidden",e))(RA||{});function BA(){let e=Le.useContext(Jg);if(e===null)throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");return e}function NA(){let e=Le.useContext(Zg);if(e===null)throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");return e}let Zg=Le.createContext(null);Zg.displayName="NestingContext";function e_(e){return"children"in e?e_(e.children):e.current.filter(({el:t})=>t.current!==null).filter(({state:t})=>t==="visible").length>0}function P2(e,t){let r=is(e),o=Le.useRef([]),a=xh(),l=Nw(),p=Gr((H,W=ts.Hidden)=>{let Y=o.current.findIndex(({el:B})=>B===H);Y!==-1&&(ii(W,{[ts.Unmount](){o.current.splice(Y,1)},[ts.Hidden](){o.current[Y].state="hidden"}}),l.microTask(()=>{var B;!e_(o)&&a.current&&((B=r.current)==null||B.call(r))}))}),w=Gr(H=>{let W=o.current.find(({el:Y})=>Y===H);return W?W.state!=="visible"&&(W.state="visible"):o.current.push({el:H,state:"visible"}),()=>p(H,ts.Unmount)}),_=Le.useRef([]),y=Le.useRef(Promise.resolve()),T=Le.useRef({enter:[],leave:[],idle:[]}),E=Gr((H,W,Y)=>{_.current.splice(0),t&&(t.chains.current[W]=t.chains.current[W].filter(([B])=>B!==H)),t==null||t.chains.current[W].push([H,new Promise(B=>{_.current.push(B)})]),t==null||t.chains.current[W].push([H,new Promise(B=>{Promise.all(T.current[W].map(([F,O])=>O)).then(()=>B())})]),W==="enter"?y.current=y.current.then(()=>t==null?void 0:t.wait.current).then(()=>Y(W)):Y(W)}),A=Gr((H,W,Y)=>{Promise.all(T.current[W].splice(0).map(([B,F])=>F)).then(()=>{var B;(B=_.current.shift())==null||B()}).then(()=>Y(W))});return Le.useMemo(()=>({children:o,register:w,unregister:p,onStart:E,onStop:A,wait:y,chains:T}),[w,p,o,E,A,T,y])}function UA(){}let jA=["beforeEnter","afterEnter","beforeLeave","afterLeave"];function CM(e){var t;let r={};for(let o of jA)r[o]=(t=e[o])!=null?t:UA;return r}function VA(e){let t=Le.useRef(CM(e));return Le.useEffect(()=>{t.current=CM(e)},[e]),t}let WA="div",$2=kg.RenderStrategy;function GA(e,t){let{beforeEnter:r,afterEnter:o,beforeLeave:a,afterLeave:l,enter:p,enterFrom:w,enterTo:_,entered:y,leave:T,leaveFrom:E,leaveTo:A,...H}=e,W=Le.useRef(null),Y=_o(W,t),B=H.unmount?ts.Unmount:ts.Hidden,{show:F,appear:O,initial:P}=BA(),[j,V]=Le.useState(F?"visible":"hidden"),z=NA(),{register:q,unregister:L}=z,pe=Le.useRef(null);Le.useEffect(()=>q(W),[q,W]),Le.useEffect(()=>{if(B===ts.Hidden&&W.current){if(F&&j!=="visible"){V("visible");return}return ii(j,{hidden:()=>L(W),visible:()=>q(W)})}},[j,W,q,L,F,B]);let fe=is({enter:ka(p),enterFrom:ka(w),enterTo:ka(_),entered:ka(y),leave:ka(T),leaveFrom:ka(E),leaveTo:ka(A)}),xe=VA({beforeEnter:r,afterEnter:o,beforeLeave:a,afterLeave:l}),$e=uc();Le.useEffect(()=>{if($e&&j==="visible"&&W.current===null)throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")},[W,j,$e]);let Ce=P&&!O,tt=!$e||Ce||pe.current===F?"idle":F?"enter":"leave",Je=IA(0),it=Gr(Pe=>ii(Pe,{enter:()=>{Je.addFlag(Pi.Opening),xe.current.beforeEnter()},leave:()=>{Je.addFlag(Pi.Closing),xe.current.beforeLeave()},idle:()=>{}})),be=Gr(Pe=>ii(Pe,{enter:()=>{Je.removeFlag(Pi.Opening),xe.current.afterEnter()},leave:()=>{Je.removeFlag(Pi.Closing),xe.current.afterLeave()},idle:()=>{}})),Q=P2(()=>{V("hidden"),L(W)},z);LA({container:W,classes:fe,direction:tt,onStart:is(Pe=>{Q.onStart(W,Pe,it)}),onStop:is(Pe=>{Q.onStop(W,Pe,be),Pe==="leave"&&!e_(Q)&&(V("hidden"),L(W))})}),Le.useEffect(()=>{Ce&&(B===ts.Hidden?pe.current=null:pe.current=F)},[F,Ce,j]);let ae=H,ye={ref:Y};return O&&F&&(ae={...ae,className:D0(H.className,...fe.current.enter,...fe.current.enterFrom)}),qn.createElement(Zg.Provider,{value:Q},qn.createElement(v$,{value:ii(j,{visible:Pi.Open,hidden:Pi.Closed})|Je.flags},Yi({ourProps:ye,theirProps:ae,defaultTag:WA,features:$2,visible:j==="visible",name:"Transition.Child"})))}function qA(e,t){let{show:r,appear:o=!1,unmount:a,...l}=e,p=Le.useRef(null),w=_o(p,t);uc();let _=jw();if(r===void 0&&_!==null&&(r=(_&Pi.Open)===Pi.Open),![!0,!1].includes(r))throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");let[y,T]=Le.useState(r?"visible":"hidden"),E=P2(()=>{T("hidden")}),[A,H]=Le.useState(!0),W=Le.useRef([r]);Lo(()=>{A!==!1&&W.current[W.current.length-1]!==r&&(W.current.push(r),H(!1))},[W,r]);let Y=Le.useMemo(()=>({show:r,appear:o,initial:A}),[r,o,A]);Le.useEffect(()=>{if(r)T("visible");else if(!e_(E))T("hidden");else{let F=p.current;if(!F)return;let O=F.getBoundingClientRect();O.x===0&&O.y===0&&O.width===0&&O.height===0&&T("hidden")}},[r,E]);let B={unmount:a};return qn.createElement(Zg.Provider,{value:E},qn.createElement(Jg.Provider,{value:Y},Yi({ourProps:{...B,as:Le.Fragment,children:qn.createElement(A2,{ref:w,...B,...l})},theirProps:{},defaultTag:Le.Fragment,features:$2,visible:y==="visible",name:"Transition"})))}function HA(e,t){let r=Le.useContext(Jg)!==null,o=jw()!==null;return qn.createElement(qn.Fragment,null,!r&&o?qn.createElement(N0,{ref:t,...e}):qn.createElement(A2,{ref:t,...e}))}let N0=Di(qA),A2=Di(GA),KA=Di(HA),Ay=Object.assign(N0,{Child:KA,Root:N0});function Gw({show:e,onClose:t,onSubmit:r,title:o,content:a,submitText:l,submitEnabled:p=!0}){return wt(Ay,{appear:!0,show:e,as:Le.Fragment,children:tr(Cy,{as:"div",className:"relative z-10",onClose:t,children:[wt(Ay.Child,{as:Le.Fragment,enter:"ease-out duration-300",enterFrom:"opacity-0",enterTo:"opacity-100",leave:"ease-in duration-200",leaveFrom:"opacity-100",leaveTo:"opacity-0",children:wt("div",{className:"fixed inset-0 bg-black bg-opacity-25"})}),wt("div",{className:"fixed inset-0 overflow-y-auto",children:wt("div",{className:"flex min-h-full items-center justify-center p-4 text-center",children:wt(Ay.Child,{as:Le.Fragment,enter:"ease-out duration-300",enterFrom:"opacity-0 scale-95",enterTo:"opacity-100 scale-100",leave:"ease-in duration-200",leaveFrom:"opacity-100 scale-100",leaveTo:"opacity-0 scale-95",children:tr(Cy.Panel,{className:"w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all",children:[wt(Cy.Title,{as:"h3",className:"text-lg font-medium leading-6 text-gray-900",children:o}),wt("div",{className:"mt-3 text-sm text-gray-500",children:a}),tr("div",{className:"mt-4 flex flex-row-reverse",children:[l&&wt("button",{type:"button",disabled:!p,className:`inline-flex ml-4 justify-center rounded-md border border-transparent ${p?"bg-indigo-600":"bg-grey-300"} px-4 py-2 text-sm font-medium text-indigo-100 ${p?"hover:bg-indigo-500 focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2":""} transition-all duration-300`,onClick:r,children:l}),wt("button",{type:"button",className:"inline-flex justify-center rounded-md border border-transparent bg-indigo-100 px-4 py-2 text-sm font-medium text-indigo-900 hover:bg-indigo-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 transition-all duration-300",onClick:t,children:"Close"})]})]})})})})]})})}function XA(e){return wt("div",{children:wt("input",{...e,type:"url",className:"my-2 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500",placeholder:"www.example.com",required:!0})})}function QA(e){const t=Le.useRef(null),r=Le.useRef(null);return Le.useEffect(()=>{t.current&&r.current&&(r.current.src=e.audioUrl,t.current.load())},[e.audioUrl]),wt("div",{className:"flex relative z-10 p-4 w-full",children:wt("audio",{ref:t,controls:!0,className:"w-full h-14 rounded-lg bg-white shadow-xl shadow-black/5 ring-1 ring-slate-700/10",children:wt("source",{ref:r,type:e.mimeType})})})}function YA(e){const{isModelLoading:t,isTranscribing:r,onClick:o,...a}=e;return wt("button",{...a,onClick:l=>{o&&!r&&!t&&o(l)},disabled:r,className:"text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 text-center mr-2 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800 inline-flex items-center",children:t?wt(PM,{text:"Loading model..."}):r?wt(PM,{text:"Transcribing..."}):"Transcribe Audio"})}function PM(e){return tr("div",{role:"status",children:[tr("svg",{"aria-hidden":"true",role:"status",className:"inline w-4 h-4 mr-3 text-white animate-spin",viewBox:"0 0 100 101",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[wt("path",{d:"M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",fill:"#E5E7EB"}),wt("path",{d:"M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",fill:"currentColor"})]}),e.text]})}function JA(){let e=!1;return function(t){(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)))&&(e=!0)}(navigator.userAgent||navigator.vendor||("opera"in window&&typeof window.opera=="string"?window.opera:"")),e}const $M=JA(),fo={SAMPLING_RATE:16e3,DEFAULT_AUDIO_URL:`https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/${$M?"jfk":"ted_60_16k"}.wav`,DEFAULT_MODEL:"onnx-community/whisper-tiny",DEFAULT_SUBTASK:"transcribe",DEFAULT_LANGUAGE:"english",DEFAULT_DTYPE:$M?"uint8":"fp32",DEFAULT_MULTILINGUAL:!1};function AM({text:e,percentage:t}){return t=t??0,wt("div",{className:"mt-0.5 w-full relative text-sm text-white background-bg-cyan-400 bg-gray-200 border-1 border-gray-400 rounded-lg text-left overflow-hidden",children:tr("div",{className:"top-0 h-full bg-blue-500 whitespace-nowrap px-2",style:{width:`${t}%`},children:[e," (",`${t.toFixed(2)}%`,")"]})})}function Fy(e){return String(e).padStart(2,"0")}function ZA(e){const t=e/3600|0;e-=t*(60*60);const r=e/60|0;e-=r*60;const o=e|0;return`${t?Fy(t)+":":""}${Fy(r)}:${Fy(o)}`}const eF={172351395:{name:"EBML",type:"Container"},646:{name:"EBMLVersion",type:"Uint"},759:{name:"EBMLReadVersion",type:"Uint"},754:{name:"EBMLMaxIDLength",type:"Uint"},755:{name:"EBMLMaxSizeLength",type:"Uint"},642:{name:"DocType",type:"String"},647:{name:"DocTypeVersion",type:"Uint"},645:{name:"DocTypeReadVersion",type:"Uint"},108:{name:"Void",type:"Binary"},63:{name:"CRC-32",type:"Binary"},190023271:{name:"SignatureSlot",type:"Container"},16010:{name:"SignatureAlgo",type:"Uint"},16026:{name:"SignatureHash",type:"Uint"},16037:{name:"SignaturePublicKey",type:"Binary"},16053:{name:"Signature",type:"Binary"},15963:{name:"SignatureElements",type:"Container"},15995:{name:"SignatureElementList",type:"Container"},9522:{name:"SignedElement",type:"Binary"},139690087:{name:"Segment",type:"Container"},21863284:{name:"SeekHead",type:"Container"},3515:{name:"Seek",type:"Container"},5035:{name:"SeekID",type:"Binary"},5036:{name:"SeekPosition",type:"Uint"},88713574:{name:"Info",type:"Container"},13220:{name:"SegmentUID",type:"Binary"},13188:{name:"SegmentFilename",type:"String"},1882403:{name:"PrevUID",type:"Binary"},1868715:{name:"PrevFilename",type:"String"},2013475:{name:"NextUID",type:"Binary"},1999803:{name:"NextFilename",type:"String"},1092:{name:"SegmentFamily",type:"Binary"},10532:{name:"ChapterTranslate",type:"Container"},10748:{name:"ChapterTranslateEditionUID",type:"Uint"},10687:{name:"ChapterTranslateCodec",type:"Uint"},10661:{name:"ChapterTranslateID",type:"Binary"},710577:{name:"TimecodeScale",type:"Uint"},1161:{name:"Duration",type:"Float"},1121:{name:"DateUTC",type:"Date"},15273:{name:"Title",type:"String"},3456:{name:"MuxingApp",type:"String"},5953:{name:"WritingApp",type:"String"},103:{name:"Timecode",type:"Uint"},6228:{name:"SilentTracks",type:"Container"},6359:{name:"SilentTrackNumber",type:"Uint"},39:{name:"Position",type:"Uint"},43:{name:"PrevSize",type:"Uint"},35:{name:"SimpleBlock",type:"Binary"},32:{name:"BlockGroup",type:"Container"},33:{name:"Block",type:"Binary"},34:{name:"BlockVirtual",type:"Binary"},13729:{name:"BlockAdditions",type:"Container"},38:{name:"BlockMore",type:"Container"},110:{name:"BlockAddID",type:"Uint"},37:{name:"BlockAdditional",type:"Binary"},27:{name:"BlockDuration",type:"Uint"},122:{name:"ReferencePriority",type:"Uint"},123:{name:"ReferenceBlock",type:"Int"},125:{name:"ReferenceVirtual",type:"Int"},36:{name:"CodecState",type:"Binary"},13730:{name:"DiscardPadding",type:"Int"},14:{name:"Slices",type:"Container"},104:{name:"TimeSlice",type:"Container"},76:{name:"LaceNumber",type:"Uint"},77:{name:"FrameNumber",type:"Uint"},75:{name:"BlockAdditionID",type:"Uint"},78:{name:"Delay",type:"Uint"},79:{name:"SliceDuration",type:"Uint"},72:{name:"ReferenceFrame",type:"Container"},73:{name:"ReferenceOffset",type:"Uint"},74:{name:"ReferenceTimeCode",type:"Uint"},47:{name:"EncryptedBlock",type:"Binary"},106212971:{name:"Tracks",type:"Container"},46:{name:"TrackEntry",type:"Container"},87:{name:"TrackNumber",type:"Uint"},13253:{name:"TrackUID",type:"Uint"},3:{name:"TrackType",type:"Uint"},57:{name:"FlagEnabled",type:"Uint"},8:{name:"FlagDefault",type:"Uint"},5546:{name:"FlagForced",type:"Uint"},28:{name:"FlagLacing",type:"Uint"},11751:{name:"MinCache",type:"Uint"},11768:{name:"MaxCache",type:"Uint"},254851:{name:"DefaultDuration",type:"Uint"},216698:{name:"DefaultDecodedFieldDuration",type:"Uint"},209231:{name:"TrackTimecodeScale",type:"Float"},4991:{name:"TrackOffset",type:"Int"},5614:{name:"MaxBlockAdditionID",type:"Uint"},4974:{name:"Name",type:"String"},177564:{name:"Language",type:"String"},6:{name:"CodecID",type:"String"},9122:{name:"CodecPrivate",type:"Binary"},362120:{name:"CodecName",type:"String"},13382:{name:"AttachmentLink",type:"Uint"},1742487:{name:"CodecSettings",type:"String"},1785920:{name:"CodecInfoURL",type:"String"},438848:{name:"CodecDownloadURL",type:"String"},42:{name:"CodecDecodeAll",type:"Uint"},12203:{name:"TrackOverlay",type:"Uint"},5802:{name:"CodecDelay",type:"Uint"},5819:{name:"SeekPreRoll",type:"Uint"},9764:{name:"TrackTranslate",type:"Container"},9980:{name:"TrackTranslateEditionUID",type:"Uint"},9919:{name:"TrackTranslateCodec",type:"Uint"},9893:{name:"TrackTranslateTrackID",type:"Binary"},96:{name:"Video",type:"Container"},26:{name:"FlagInterlaced",type:"Uint"},5048:{name:"StereoMode",type:"Uint"},5056:{name:"AlphaMode",type:"Uint"},5049:{name:"OldStereoMode",type:"Uint"},48:{name:"PixelWidth",type:"Uint"},58:{name:"PixelHeight",type:"Uint"},5290:{name:"PixelCropBottom",type:"Uint"},5307:{name:"PixelCropTop",type:"Uint"},5324:{name:"PixelCropLeft",type:"Uint"},5341:{name:"PixelCropRight",type:"Uint"},5296:{name:"DisplayWidth",type:"Uint"},5306:{name:"DisplayHeight",type:"Uint"},5298:{name:"DisplayUnit",type:"Uint"},5299:{name:"AspectRatioType",type:"Uint"},963876:{name:"ColourSpace",type:"Binary"},1029411:{name:"GammaValue",type:"Float"},230371:{name:"FrameRate",type:"Float"},97:{name:"Audio",type:"Container"},53:{name:"SamplingFrequency",type:"Float"},14517:{name:"OutputSamplingFrequency",type:"Float"},31:{name:"Channels",type:"Uint"},15739:{name:"ChannelPositions",type:"Binary"},8804:{name:"BitDepth",type:"Uint"},98:{name:"TrackOperation",type:"Container"},99:{name:"TrackCombinePlanes",type:"Container"},100:{name:"TrackPlane",type:"Container"},101:{name:"TrackPlaneUID",type:"Uint"},102:{name:"TrackPlaneType",type:"Uint"},105:{name:"TrackJoinBlocks",type:"Container"},109:{name:"TrackJoinUID",type:"Uint"},64:{name:"TrickTrackUID",type:"Uint"},65:{name:"TrickTrackSegmentUID",type:"Binary"},70:{name:"TrickTrackFlag",type:"Uint"},71:{name:"TrickMasterTrackUID",type:"Uint"},68:{name:"TrickMasterTrackSegmentUID",type:"Binary"},11648:{name:"ContentEncodings",type:"Container"},8768:{name:"ContentEncoding",type:"Container"},4145:{name:"ContentEncodingOrder",type:"Uint"},4146:{name:"ContentEncodingScope",type:"Uint"},4147:{name:"ContentEncodingType",type:"Uint"},4148:{name:"ContentCompression",type:"Container"},596:{name:"ContentCompAlgo",type:"Uint"},597:{name:"ContentCompSettings",type:"Binary"},4149:{name:"ContentEncryption",type:"Container"},2017:{name:"ContentEncAlgo",type:"Uint"},2018:{name:"ContentEncKeyID",type:"Binary"},2019:{name:"ContentSignature",type:"Binary"},2020:{name:"ContentSigKeyID",type:"Binary"},2021:{name:"ContentSigAlgo",type:"Uint"},2022:{name:"ContentSigHashAlgo",type:"Uint"},206814059:{name:"Cues",type:"Container"},59:{name:"CuePoint",type:"Container"},51:{name:"CueTime",type:"Uint"},55:{name:"CueTrackPositions",type:"Container"},119:{name:"CueTrack",type:"Uint"},113:{name:"CueClusterPosition",type:"Uint"},112:{name:"CueRelativePosition",type:"Uint"},50:{name:"CueDuration",type:"Uint"},4984:{name:"CueBlockNumber",type:"Uint"},106:{name:"CueCodecState",type:"Uint"},91:{name:"CueReference",type:"Container"},22:{name:"CueRefTime",type:"Uint"},23:{name:"CueRefCluster",type:"Uint"},4959:{name:"CueRefNumber",type:"Uint"},107:{name:"CueRefCodecState",type:"Uint"},155296873:{name:"Attachments",type:"Container"},8615:{name:"AttachedFile",type:"Container"},1662:{name:"FileDescription",type:"String"},1646:{name:"FileName",type:"String"},1632:{name:"FileMimeType",type:"String"},1628:{name:"FileData",type:"Binary"},1710:{name:"FileUID",type:"Uint"},1653:{name:"FileReferral",type:"Binary"},1633:{name:"FileUsedStartTime",type:"Uint"},1634:{name:"FileUsedEndTime",type:"Uint"},4433776:{name:"Chapters",type:"Container"},1465:{name:"EditionEntry",type:"Container"},1468:{name:"EditionUID",type:"Uint"},1469:{name:"EditionFlagHidden",type:"Uint"},1499:{name:"EditionFlagDefault",type:"Uint"},1501:{name:"EditionFlagOrdered",type:"Uint"},54:{name:"ChapterAtom",type:"Container"},13252:{name:"ChapterUID",type:"Uint"},5716:{name:"ChapterStringUID",type:"String"},17:{name:"ChapterTimeStart",type:"Uint"},18:{name:"ChapterTimeEnd",type:"Uint"},24:{name:"ChapterFlagHidden",type:"Uint"},1432:{name:"ChapterFlagEnabled",type:"Uint"},11879:{name:"ChapterSegmentUID",type:"Binary"},11964:{name:"ChapterSegmentEditionUID",type:"Uint"},9155:{name:"ChapterPhysicalEquiv",type:"Uint"},15:{name:"ChapterTrack",type:"Container"},9:{name:"ChapterTrackNumber",type:"Uint"},0:{name:"ChapterDisplay",type:"Container"},5:{name:"ChapString",type:"String"},892:{name:"ChapLanguage",type:"String"},894:{name:"ChapCountry",type:"String"},10564:{name:"ChapProcess",type:"Container"},10581:{name:"ChapProcessCodecID",type:"Uint"},1293:{name:"ChapProcessPrivate",type:"Binary"},10513:{name:"ChapProcessCommand",type:"Container"},10530:{name:"ChapProcessTime",type:"Uint"},10547:{name:"ChapProcessData",type:"Binary"},39109479:{name:"Tags",type:"Container"},13171:{name:"Tag",type:"Container"},9152:{name:"Targets",type:"Container"},10442:{name:"TargetTypeValue",type:"Uint"},9162:{name:"TargetType",type:"String"},9157:{name:"TagTrackUID",type:"Uint"},9161:{name:"TagEditionUID",type:"Uint"},9156:{name:"TagChapterUID",type:"Uint"},9158:{name:"TagAttachmentUID",type:"Uint"},10184:{name:"SimpleTag",type:"Container"},1443:{name:"TagName",type:"String"},1146:{name:"TagLanguage",type:"String"},1156:{name:"TagDefault",type:"Uint"},1159:{name:"TagString",type:"String"},1157:{name:"TagBinary",type:"Binary"}};class $g{constructor(t="Unknown",r="Unknown"){Ee(this,"source");Ee(this,"data");this.name=t,this.type=r}updateBySource(){}setSource(t){this.source=t,this.updateBySource()}updateByData(){}setData(t){this.data=t,this.updateByData()}}class tF extends $g{constructor(t,r){super(t,r||"Uint")}updateBySource(){this.data="";for(let t=0;t<this.source.length;t++){const r=this.source[t].toString(16);this.data+=FM(r)}}updateByData(){const t=this.data.length/2;this.source=new Uint8Array(t);for(let r=0;r<t;r++){const o=this.data.substr(r*2,2);this.source[r]=parseInt(o,16)}}getValue(){return parseInt(this.data,16)}setValue(t){this.setData(FM(t.toString(16)))}}function FM(e){return e.length%2===1?"0"+e:e}class F2 extends $g{constructor(t,r){super(t,r||"Float")}getFloatArrayType(){return this.source&&this.source.length===4?Float32Array:Float64Array}updateBySource(){const t=this.source.reverse(),r=this.getFloatArrayType(),o=new r(t.buffer);this.data=o[0]}updateByData(){const t=this.getFloatArrayType(),r=new t([this.data]),o=new Uint8Array(r.buffer);this.source=o.reverse()}getValue(){return this.data}setValue(t){this.setData(t)}}class qw extends $g{constructor(r,o){super(r,o||"Container");Ee(this,"offset",0);Ee(this,"data",[])}readByte(){return this.source[this.offset++]}readUint(){const r=this.readByte(),o=8-r.toString(2).length;let a=r-(1<<7-o);for(let l=0;l<o;l++)a*=256,a+=this.readByte();return a}updateBySource(){let r;for(this.data=[],this.offset=0;this.offset<this.source.length;this.offset=r){const o=this.readUint(),a=this.readUint();r=Math.min(this.offset+a,this.source.length);const l=this.source.slice(this.offset,r),p=eF[o]||{name:"Unknown",type:"Unknown"};let w=$g;switch(p.type){case"Container":w=qw;break;case"Uint":w=tF;break;case"Float":w=F2;break}const _=new w(p.name,p.type);_.setSource(l),this.data.push({id:o,idHex:o.toString(16),data:_})}}writeUint(r,o=!1){for(var a=1,l=128;r>=l&&a<8;a++,l*=128);if(!o){let p=l+r;for(let w=a-1;w>=0;w--){const _=p%256;this.source[this.offset+w]=_,p=(p-_)/256}}this.offset+=a}writeSections(r=!1){this.offset=0;for(let o=0;o<this.data.length;o++){const a=this.data[o],l=a.data.source,p=l.length;this.writeUint(a.id,r),this.writeUint(p,r),r||this.source.set(l,this.offset),this.offset+=p}return this.offset}updateByData(){const r=this.writeSections(!0);this.source=new Uint8Array(r),this.writeSections()}getSectionById(r){for(let o=0;o<this.data.length;o++){const a=this.data[o];if(a.id===r)return a.data}}}class nF extends qw{constructor(t){super("File","File"),this.setSource(t)}fixDuration(t){const r=this.getSectionById(139690087);if(!r)return!1;const o=r.getSectionById(88713574);if(!o)return!1;const a=o.getSectionById(710577);if(!a)return!1;let l=o.getSectionById(1161);if(l)if(l.getValue()<=0)l.setValue(t);else return!1;else l=new F2("Duration","Float"),l.setValue(t),o.data.push({id:1161,data:l});return a.setValue(1e6),o.updateByData(),r.updateByData(),this.updateByData(),!0}toBlob(t="video/webm"){return new Blob([this.source.buffer],{type:t})}}const rF=(e,t,r="video/webm")=>new Promise((o,a)=>{try{const l=new FileReader;l.addEventListener("loadend",()=>{try{const p=l.result,w=new nF(new Uint8Array(p));w.fixDuration(t)?o(w.toBlob(r)):o(e)}catch(p){a(p)}}),l.addEventListener("error",()=>a()),l.readAsArrayBuffer(e)}catch(l){a(l)}});function iF(){const e=["audio/webm","audio/mp4","audio/ogg","audio/wav","audio/aac"];for(let t=0;t<e.length;t++)if(MediaRecorder.isTypeSupported(e[t]))return e[t]}function oF(e){const[t,r]=Le.useState(!1),[o,a]=Le.useState(0),[l,p]=Le.useState(null),w=Le.useRef(null),_=Le.useRef(null),y=Le.useRef([]),T=Le.useRef(null),E=async()=>{p(null);let W=Date.now();try{w.current||(w.current=await navigator.mediaDevices.getUserMedia({audio:!0}));const Y=iF(),B=new MediaRecorder(w.current,{mimeType:Y});_.current=B,B.addEventListener("dataavailable",async F=>{if(F.data.size>0&&y.current.push(F.data),B.state==="inactive"){const O=Date.now()-W;let P=new Blob(y.current,{type:Y});Y==="audio/webm"&&(P=await rF(P,O,P.type)),p(P),e.onRecordingComplete(P),y.current=[]}}),B.start(),r(!0)}catch(Y){console.error("Error accessing microphone:",Y)}},A=()=>{_.current&&_.current.state==="recording"&&(_.current.stop(),a(0),r(!1))};return Le.useEffect(()=>{if(t){const W=setInterval(()=>{a(Y=>Y+1)},1e3);return()=>{clearInterval(W)}}return()=>{}},[t]),tr("div",{className:"flex flex-col justify-center items-center",children:[wt("button",{type:"button",className:`m-2 inline-flex justify-center rounded-md border border-transparent px-4 py-2 text-sm font-medium text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 transition-all duration-200 ${t?"bg-red-500 hover:bg-red-600":"bg-green-500 hover:bg-green-600"}`,onClick:()=>{t?A():E()},children:t?`Stop Recording (${ZA(o)})`:"Start Recording"}),l&&wt("audio",{className:"w-full",ref:T,controls:!0,children:wt("source",{src:URL.createObjectURL(l),type:l.type})})]})}function sF(e){return e=e.toLowerCase(),(e.match(/\w+.?/g)||[]).map(t=>t.charAt(0).toUpperCase()+t.slice(1)).join("")}const IM={en:"english",zh:"chinese",de:"german",es:"spanish/castilian",ru:"russian",ko:"korean",fr:"french",ja:"japanese",pt:"portuguese",tr:"turkish",pl:"polish",ca:"catalan/valencian",nl:"dutch/flemish",ar:"arabic",sv:"swedish",it:"italian",id:"indonesian",hi:"hindi",fi:"finnish",vi:"vietnamese",he:"hebrew",uk:"ukrainian",el:"greek",ms:"malay",cs:"czech",ro:"romanian/moldavian/moldovan",da:"danish",hu:"hungarian",ta:"tamil",no:"norwegian",th:"thai",ur:"urdu",hr:"croatian",bg:"bulgarian",lt:"lithuanian",la:"latin",mi:"maori",ml:"malayalam",cy:"welsh",sk:"slovak",te:"telugu",fa:"persian",lv:"latvian",bn:"bengali",sr:"serbian",az:"azerbaijani",sl:"slovenian",kn:"kannada",et:"estonian",mk:"macedonian",br:"breton",eu:"basque",is:"icelandic",hy:"armenian",ne:"nepali",mn:"mongolian",bs:"bosnian",kk:"kazakh",sq:"albanian",sw:"swahili",gl:"galician",mr:"marathi",pa:"punjabi/panjabi",si:"sinhala/sinhalese",km:"khmer",sn:"shona",yo:"yoruba",so:"somali",af:"afrikaans",oc:"occitan",ka:"georgian",be:"belarusian",tg:"tajik",sd:"sindhi",gu:"gujarati",am:"amharic",yi:"yiddish",lo:"lao",uz:"uzbek",fo:"faroese",ht:"haitian creole/haitian",ps:"pashto/pushto",tk:"turkmen",nn:"nynorsk",mt:"maltese",sa:"sanskrit",lb:"luxembourgish/letzeburgesch",my:"myanmar/burmese",bo:"tibetan",tl:"tagalog",mg:"malagasy",as:"assamese",tt:"tatar",haw:"hawaiian",ln:"lingala",ha:"hausa",ba:"bashkir",jw:"javanese",su:"sundanese"};function aF(e){const[t,r]=Le.useState(void 0),[o,a]=Le.useState(void 0),[l,p]=Le.useState(void 0),[w,_]=Le.useState([]),[y,T]=Le.useState([]),[E,A]=Le.useState(0),H=t!==void 0,W=()=>{a(void 0),p(void 0)},Y=async(P,j)=>{const V=new AudioContext({sampleRate:fo.SAMPLING_RATE}),z=URL.createObjectURL(new Blob([P],{type:"audio/*"})),q=await V.decodeAudioData(P);a({buffer:q,url:z,source:"URL",mimeType:j})},B=async P=>{W(),r(0);const j=URL.createObjectURL(P),V=new FileReader;V.onprogress=z=>{r(z.loaded/z.total||0)},V.onloadend=async()=>{const z=new AudioContext({sampleRate:fo.SAMPLING_RATE}),q=V.result,L=await z.decodeAudioData(q);r(void 0),a({buffer:L,url:j,source:"RECORDING",mimeType:P.type})},V.readAsArrayBuffer(P)},F=async P=>{if(l)try{a(void 0),r(0);const{data:j,headers:V}=await Br.get(l,{signal:P.signal,responseType:"arraybuffer",onDownloadProgress(q){r(q.progress||0)}});let z=V["content-type"];(!z||z==="audio/wave")&&(z="audio/wav"),Y(j,z)}catch(j){console.log("Request failed or aborted",j)}finally{r(void 0)}},O=async()=>{A(0),T([]);const P=w.length;for(let j=0;j<P;j++){const V=w[j];let z;try{const q=await e.transcriber.start(V.buffer);q?z={filename:V.filename,groundTruth:V.transcription,transcription:q.text,latency:q.latency}:console.error("Transcription failed for file:",V.filename)}catch(q){console.error("Error during transcription of file:",V.filename,q)}A((j+1)/P*100),T(q=>[...q,z])}};return Le.useEffect(()=>{if(l){const P=new AbortController;return F(P),()=>{P.abort()}}},[l]),Le.useEffect(()=>{w.length>0&&O()},[w]),tr(Io,{children:[tr("div",{className:"flex flex-col justify-center items-center rounded-lg bg-white shadow-xl shadow-black/5 ring-1 ring-slate-700/10",children:[tr("div",{className:"flex flex-row space-x-2 py-2 w-full px-2",children:[wt(fF,{icon:wt(OM,{}),text:"Use Test Files",onFilesLoaded:P=>{e.transcriber.onInputChange(),_(P)}}),wt(Iy,{}),wt(hF,{icon:wt(wF,{}),text:"From URL",onUrlUpdate:P=>{e.transcriber.onInputChange(),p(P)}}),wt(Iy,{}),wt(gF,{icon:wt(OM,{}),text:"From file",onFileUpdate:(P,j,V)=>{e.transcriber.onInputChange(),a({buffer:P,url:j,source:"FILE",mimeType:V})}}),navigator.mediaDevices&&tr(Io,{children:[wt(Iy,{}),wt(_F,{icon:wt(bF,{}),text:"Record",setAudioData:P=>{e.transcriber.onInputChange(),B(P)}})]})]}),wt(dF,{progress:H?t:+!!o})]}),o&&tr(Io,{children:[wt(QA,{audioUrl:o.url,mimeType:o.mimeType}),wt("div",{className:"relative w-full flex justify-center items-center",children:wt(YA,{onClick:()=>{e.transcriber.start(o.buffer)},isModelLoading:e.transcriber.isModelLoading,isTranscribing:e.transcriber.isBusy})}),e.transcriber.progressItems.length>0&&tr("div",{className:"relative z-10 p-4 w-full",children:[wt("label",{children:"Loading model files... (only run once)"}),e.transcriber.progressItems.map(P=>wt("div",{children:wt(AM,{text:P.file,percentage:P.progress})},P.file))]})]}),wt(uF,{className:"absolute right-4",transcriber:e.transcriber,icon:wt(vF,{})}),`model: ${e.transcriber.model}-encoder_${e.transcriber.encoderDtype}-decoder_${e.transcriber.decoderDtype}`,w.length>0&&tr("div",{className:"w-full p-4",children:[wt("label",{children:"Processing files..."}),wt(AM,{text:`Processing ${w.length} files`,percentage:E})]}),y.length>0&&wt(lF,{transcriptionResults:y})]})}function lF(e){const t=e.transcriptionResults.map(r=>`${r.latency}
${r.groundTruth.toLowerCase().trim()}
${r.transcription.toLowerCase().trim()}`).join(`
`);return tr("div",{className:"w-full mb-4",children:[wt("textarea",{readOnly:!0,value:t,className:"w-full h-64 p-2 border rounded"}),wt("button",{onClick:()=>{navigator.clipboard.writeText(t)},className:"mt-2 px-4 py-2 bg-blue-500 text-white rounded",children:"Copy Test Results"})]})}function uF(e){const[t,r]=Le.useState(!1),o=()=>{r(!0)},a=()=>{r(!1)},l=p=>{a()};return tr("div",{className:e.className,children:[wt(Sh,{icon:e.icon,onClick:o}),wt(cF,{show:t,onSubmit:l,onClose:a,transcriber:e.transcriber})]})}function cF(e){const t=Object.values(IM).map(sF),r={fp32:32.9,fp16:16.5,q4:9.02,bnb4:8.58,uint8:10.1,quantized:10.1},o={fp32:119,fp16:59.6,q4:86.7,bnb4:86.1,uint8:30.7,quantized:30.7};return wt(Gw,{show:e.show,title:"Settings",content:tr(Io,{children:[wt("label",{children:"Select the Encoder to use."}),wt("select",{className:"mt-1 mb-1 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500",defaultValue:e.transcriber.encoderDtype,onChange:a=>{e.transcriber.setEncoderDtype(a.target.value)},children:Object.keys(r).map(a=>wt("option",{value:a,children:`whisper-tiny/encoder_model_${a} (${r[a]}MB)`},a))}),wt("label",{children:"Select the Decoder to use."}),wt("select",{className:"mt-1 mb-1 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500",defaultValue:e.transcriber.decoderDtype,onChange:a=>{e.transcriber.setDecoderDtype(a.target.value)},children:Object.keys(o).map(a=>wt("option",{value:a,children:`whisper-tiny/decoder_model_${a} (${o[a]}MB)`},a))}),wt("div",{className:"flex justify-between items-center mb-3 px-1",children:tr("div",{className:"flex",children:[wt("input",{id:"multilingual",type:"checkbox",checked:e.transcriber.multilingual,onChange:a=>{e.transcriber.setMultilingual(a.target.checked)}}),wt("label",{htmlFor:"multilingual",className:"ms-1",children:"Multilingual"})]})}),`Total size: ${r[e.transcriber.encoderDtype]+o[e.transcriber.decoderDtype]} MB`,e.transcriber.multilingual&&tr(Io,{children:[wt("label",{children:"Select the source language."}),wt("select",{className:"mt-1 mb-3 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500",defaultValue:e.transcriber.language,onChange:a=>{e.transcriber.setLanguage(a.target.value)},children:Object.keys(IM).map((a,l)=>wt("option",{value:a,children:t[l]},a))}),wt("label",{children:"Select the task to perform."}),tr("select",{className:"mt-1 mb-3 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500",defaultValue:e.transcriber.subtask,onChange:a=>{e.transcriber.setSubtask(a.target.value)},children:[wt("option",{value:"transcribe",children:"Transcribe"}),wt("option",{value:"translate",children:"Translate (to English)"})]})]})]}),onClose:e.onClose,onSubmit:()=>{}})}function Iy(){return wt("div",{className:"w-[1px] bg-slate-200"})}function dF(e){return wt(pF,{progress:`${Math.round(e.progress*100)}%`})}function pF(e){return wt("div",{className:"w-full bg-gray-200 rounded-full h-1 dark:bg-gray-700",children:wt("div",{className:"bg-blue-600 h-1 rounded-full transition-all duration-100",style:{width:e.progress}})})}function fF(e){const t=async()=>{const r="/ODAC/test-clean/",o=`${r}61-70968.trans.txt`;try{const p=(await(await fetch(o)).text()).split(`
`).filter(_=>_.trim()!==""),w=[];for(const _ of p){const y=_.indexOf(" ");if(y===-1)continue;const T=_.substring(0,y),E=_.substring(y+1).trim(),A=`${r}${T}.flac`;try{const H=await fetch(A),W=await H.arrayBuffer(),B=await new AudioContext({sampleRate:fo.SAMPLING_RATE}).decodeAudioData(W);w.push({buffer:B,url:A,source:"TEST",mimeType:H.headers.get("Content-Type")||"audio/wav",filename:T,transcription:E})}catch(H){console.error(`Error loading file ${A}:`,H)}}console.log("Test Files loaded:",w),e.onFilesLoaded(w)}catch(a){console.error("Error fetching or parsing transcriptions file:",a)}};return wt(Sh,{icon:e.icon,text:e.text,onClick:t})}function hF(e){const[t,r]=Le.useState(!1),o=()=>{r(!0)},a=()=>{r(!1)},l=p=>{e.onUrlUpdate(p),a()};return tr(Io,{children:[wt(Sh,{icon:e.icon,text:e.text,onClick:o}),wt(mF,{show:t,onSubmit:l,onClose:a})]})}function mF(e){const[t,r]=Le.useState(fo.DEFAULT_AUDIO_URL),o=l=>{r(l.target.value)},a=()=>{e.onSubmit(t)};return wt(Gw,{show:e.show,title:"From URL",content:tr(Io,{children:["Enter the URL of the audio file you want to load.",wt(XA,{onChange:o,value:t})]}),onClose:e.onClose,submitText:"Load",onSubmit:a})}function gF(e){let t=document.createElement("input");return t.type="file",t.oninput=r=>{let o=r.target.files;if(!o)return;const a=URL.createObjectURL(o[0]),l=o[0].type,p=new FileReader;p.addEventListener("load",async w=>{var E;const _=(E=w.target)==null?void 0:E.result;if(!_)return;const T=await new AudioContext({sampleRate:fo.SAMPLING_RATE}).decodeAudioData(_);e.onFileUpdate(T,a,l)}),p.readAsArrayBuffer(o[0]),t.value=""},wt(Io,{children:wt(Sh,{icon:e.icon,text:e.text,onClick:()=>t.click()})})}function _F(e){const[t,r]=Le.useState(!1),o=()=>{r(!0)},a=()=>{r(!1)},l=p=>{p&&(e.setAudioData(p),a())};return tr(Io,{children:[wt(Sh,{icon:e.icon,text:e.text,onClick:o}),wt(yF,{show:t,onSubmit:l,onClose:a})]})}function yF(e){const[t,r]=Le.useState(),o=p=>{r(p)},a=()=>{e.onSubmit(t),r(void 0)},l=()=>{e.onClose(),r(void 0)};return wt(Gw,{show:e.show,title:"From Recording",content:tr(Io,{children:["Record audio using your microphone",wt(oF,{onRecordingComplete:o})]}),onClose:l,submitText:"Load",submitEnabled:t!==void 0,onSubmit:a})}function Sh(e){return tr("button",{onClick:e.onClick,className:"flex items-center justify-center rounded-lg p-2 bg-blue text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 transition-all duration-200",children:[wt("div",{className:"w-7 h-7",children:e.icon}),e.text&&wt("div",{className:"ml-2 break-text text-center text-md w-30",children:e.text})]})}function wF(){return wt("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:"1.5",stroke:"currentColor",children:wt("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"})})}function OM(){return wt("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:"1.5",stroke:"currentColor",children:wt("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3.75 9.776c.112-.017.227-.026.344-.026h15.812c.117 0 .232.009.344.026m-16.5 0a2.25 2.25 0 00-1.883 2.542l.857 6a2.25 2.25 0 002.227 1.932H19.05a2.25 2.25 0 002.227-1.932l.857-6a2.25 2.25 0 00-1.883-2.542m-16.5 0V6A2.25 2.25 0 016 3.75h3.879a1.5 1.5 0 011.06.44l2.122 2.12a1.5 1.5 0 001.06.44H18A2.25 2.25 0 0120.25 9v.776"})})}function vF(){return tr("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:"1.25",stroke:"currentColor",children:[wt("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z"}),wt("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15 12a3 3 0 11-6 0 3 3 0 016 0z"})]})}function bF(){return wt("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",children:wt("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"})})}function MF(e){const[t]=Le.useState(()=>xF(e));return t}function xF(e){const t=new Worker(new URL("/ODAC/assets/worker-HPx2DJ9M.js",import.meta.url),{type:"module"});return t.addEventListener("message",e),t}var Qo={},I2={"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":(e,t,r)=>{e.exports=r.p+"ort-wasm-simd-threaded.jsep.wasm"},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,t,r)=>{r.r(t),r.d(t,{Environment:()=>Ge,Interpreter:()=>ht,Template:()=>Ct,parse:()=>ye,tokenize:()=>E});var o=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),a=Object.freeze({set:o.Set,for:o.For,in:o.In,is:o.Is,if:o.If,else:o.Else,endif:o.EndIf,elif:o.ElseIf,endfor:o.EndFor,and:o.And,or:o.Or,not:o.Not,"not in":o.NotIn,macro:o.Macro,endmacro:o.EndMacro,true:o.BooleanLiteral,false:o.BooleanLiteral,True:o.BooleanLiteral,False:o.BooleanLiteral}),l=class{constructor(U,se){this.value=U,this.type=se}};function p(U){return/\w/.test(U)}function w(U){return/[0-9]/.test(U)}var _=[["{%",o.OpenStatement],["%}",o.CloseStatement],["{{",o.OpenExpression],["}}",o.CloseExpression],["(",o.OpenParen],[")",o.CloseParen],["{",o.OpenCurlyBracket],["}",o.CloseCurlyBracket],["[",o.OpenSquareBracket],["]",o.CloseSquareBracket],[",",o.Comma],[".",o.Dot],[":",o.Colon],["|",o.Pipe],["<=",o.ComparisonBinaryOperator],[">=",o.ComparisonBinaryOperator],["==",o.ComparisonBinaryOperator],["!=",o.ComparisonBinaryOperator],["<",o.ComparisonBinaryOperator],[">",o.ComparisonBinaryOperator],["+",o.AdditiveBinaryOperator],["-",o.AdditiveBinaryOperator],["*",o.MultiplicativeBinaryOperator],["/",o.MultiplicativeBinaryOperator],["%",o.MultiplicativeBinaryOperator],["=",o.Equals]],y=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function T(U,se={}){return U.endsWith(`
`)&&(U=U.slice(0,-1)),U=U.replace(/{#.*?#}/gs,"{##}"),se.lstrip_blocks&&(U=U.replace(/^[ \t]*({[#%])/gm,"$1")),se.trim_blocks&&(U=U.replace(/([#%]})\n/g,"$1")),U.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function E(U,se={}){var at,Wt,Tt;const J=[],ue=T(U,se);let Me=0;const dt=St=>{let Nt="";for(;St(ue[Me]);){if(ue[Me]==="\\"){if(++Me,Me>=ue.length)throw new SyntaxError("Unexpected end of input");const Dt=ue[Me++],gn=y.get(Dt);if(gn===void 0)throw new SyntaxError(`Unexpected escaped character: ${Dt}`);Nt+=gn;continue}if(Nt+=ue[Me++],Me>=ue.length)throw new SyntaxError("Unexpected end of input")}return Nt};e:for(;Me<ue.length;){const St=(at=J.at(-1))==null?void 0:at.type;if(St===void 0||St===o.CloseStatement||St===o.CloseExpression){let Dt="";for(;Me<ue.length&&!(ue[Me]==="{"&&(ue[Me+1]==="%"||ue[Me+1]==="{"));)Dt+=ue[Me++];if(Dt.length>0){J.push(new l(Dt,o.Text));continue}}dt(Dt=>/\s/.test(Dt));const Nt=ue[Me];if(Nt==="-"||Nt==="+"){const Dt=(Wt=J.at(-1))==null?void 0:Wt.type;if(Dt===o.Text||Dt===void 0)throw new SyntaxError(`Unexpected character: ${Nt}`);switch(Dt){case o.Identifier:case o.NumericLiteral:case o.BooleanLiteral:case o.StringLiteral:case o.CloseParen:case o.CloseSquareBracket:break;default:{++Me;const gn=dt(w);J.push(new l(`${Nt}${gn}`,gn.length>0?o.NumericLiteral:o.UnaryOperator));continue}}}for(const[Dt,gn]of _)if(ue.slice(Me,Me+Dt.length)===Dt){J.push(new l(Dt,gn)),Me+=Dt.length;continue e}if(Nt==="'"||Nt==='"'){++Me;const Dt=dt(gn=>gn!==Nt);J.push(new l(Dt,o.StringLiteral)),++Me;continue}if(w(Nt)){const Dt=dt(w);J.push(new l(Dt,o.NumericLiteral));continue}if(p(Nt)){const Dt=dt(p),gn=Object.hasOwn(a,Dt)?a[Dt]:o.Identifier;gn===o.In&&((Tt=J.at(-1))==null?void 0:Tt.type)===o.Not?(J.pop(),J.push(new l("not in",o.NotIn))):J.push(new l(Dt,gn));continue}throw new SyntaxError(`Unexpected character: ${Nt}`)}return J}var A=class{constructor(){Ee(this,"type","Statement")}},H=class extends A{constructor(se){super();Ee(this,"type","Program");this.body=se}},W=class extends A{constructor(se,J,ue){super();Ee(this,"type","If");this.test=se,this.body=J,this.alternate=ue}},Y=class extends A{constructor(se,J,ue,Me){super();Ee(this,"type","For");this.loopvar=se,this.iterable=J,this.body=ue,this.defaultBlock=Me}},B=class extends A{constructor(se,J){super();Ee(this,"type","Set");this.assignee=se,this.value=J}},F=class extends A{constructor(se,J,ue){super();Ee(this,"type","Macro");this.name=se,this.args=J,this.body=ue}},O=class extends A{constructor(){super(...arguments);Ee(this,"type","Expression")}},P=class extends O{constructor(se,J,ue){super();Ee(this,"type","MemberExpression");this.object=se,this.property=J,this.computed=ue}},j=class extends O{constructor(se,J){super();Ee(this,"type","CallExpression");this.callee=se,this.args=J}},V=class extends O{constructor(se){super();Ee(this,"type","Identifier");this.value=se}},z=class extends O{constructor(se){super();Ee(this,"type","Literal");this.value=se}},q=class extends z{constructor(){super(...arguments);Ee(this,"type","NumericLiteral")}},L=class extends z{constructor(){super(...arguments);Ee(this,"type","StringLiteral")}},pe=class extends z{constructor(){super(...arguments);Ee(this,"type","BooleanLiteral")}},fe=class extends z{constructor(){super(...arguments);Ee(this,"type","ArrayLiteral")}},xe=class extends z{constructor(){super(...arguments);Ee(this,"type","TupleLiteral")}},$e=class extends z{constructor(){super(...arguments);Ee(this,"type","ObjectLiteral")}},Ce=class extends O{constructor(se,J,ue){super();Ee(this,"type","BinaryExpression");this.operator=se,this.left=J,this.right=ue}},tt=class extends O{constructor(se,J){super();Ee(this,"type","FilterExpression");this.operand=se,this.filter=J}},Je=class extends O{constructor(se,J){super();Ee(this,"type","SelectExpression");this.iterable=se,this.test=J}},it=class extends O{constructor(se,J,ue){super();Ee(this,"type","TestExpression");this.operand=se,this.negate=J,this.test=ue}},be=class extends O{constructor(se,J){super();Ee(this,"type","UnaryExpression");this.operator=se,this.argument=J}},Q=class extends O{constructor(se=void 0,J=void 0,ue=void 0){super();Ee(this,"type","SliceExpression");this.start=se,this.stop=J,this.step=ue}},ae=class extends O{constructor(se,J){super();Ee(this,"type","KeywordArgumentExpression");this.key=se,this.value=J}};function ye(U){const se=new H([]);let J=0;function ue(Be,Ne){const mt=U[J++];if(!mt||mt.type!==Be)throw new Error(`Parser Error: ${Ne}. ${mt.type} !== ${Be}.`);return mt}function Me(){switch(U[J].type){case o.Text:return Wt();case o.OpenStatement:return Tt();case o.OpenExpression:return St();default:throw new SyntaxError(`Unexpected token type: ${U[J].type}`)}}function dt(...Be){return J+Be.length<=U.length&&Be.some((Ne,mt)=>Ne!==U[J+mt].type)}function at(...Be){return J+Be.length<=U.length&&Be.every((Ne,mt)=>Ne===U[J+mt].type)}function Wt(){return new L(ue(o.Text,"Expected text token").value)}function Tt(){ue(o.OpenStatement,"Expected opening statement token");let Be;switch(U[J].type){case o.Set:++J,Be=Nt(),ue(o.CloseStatement,"Expected closing statement token");break;case o.If:++J,Be=Dt(),ue(o.OpenStatement,"Expected {% token"),ue(o.EndIf,"Expected endif token"),ue(o.CloseStatement,"Expected %} token");break;case o.Macro:++J,Be=gn(),ue(o.OpenStatement,"Expected {% token"),ue(o.EndMacro,"Expected endmacro token"),ue(o.CloseStatement,"Expected %} token");break;case o.For:++J,Be=pr(),ue(o.OpenStatement,"Expected {% token"),ue(o.EndFor,"Expected endfor token"),ue(o.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${U[J].type}`)}return Be}function St(){ue(o.OpenExpression,"Expected opening expression token");const Be=Xn();return ue(o.CloseExpression,"Expected closing expression token"),Be}function Nt(){const Be=Xn();if(at(o.Equals)){++J;const Ne=Nt();return new B(Be,Ne)}return Be}function Dt(){var Ht,cn,En,Qn,bn,Dn,xn,si;const Be=Xn();ue(o.CloseStatement,"Expected closing statement token");const Ne=[],mt=[];for(;!(((Ht=U[J])==null?void 0:Ht.type)===o.OpenStatement&&(((cn=U[J+1])==null?void 0:cn.type)===o.ElseIf||((En=U[J+1])==null?void 0:En.type)===o.Else||((Qn=U[J+1])==null?void 0:Qn.type)===o.EndIf));)Ne.push(Me());if(((bn=U[J])==null?void 0:bn.type)===o.OpenStatement&&((Dn=U[J+1])==null?void 0:Dn.type)!==o.EndIf)if(++J,at(o.ElseIf))ue(o.ElseIf,"Expected elseif token"),mt.push(Dt());else for(ue(o.Else,"Expected else token"),ue(o.CloseStatement,"Expected closing statement token");!(((xn=U[J])==null?void 0:xn.type)===o.OpenStatement&&((si=U[J+1])==null?void 0:si.type)===o.EndIf);)mt.push(Me());return new W(Be,Ne,mt)}function gn(){const Be=Rt();if(Be.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const Ne=ut();ue(o.CloseStatement,"Expected closing statement token");const mt=[];for(;dt(o.OpenStatement,o.EndMacro);)mt.push(Me());return new F(Be,Ne,mt)}function An(Be=!1){const Ne=Be?Rt:Xn,mt=[Ne()],Ht=at(o.Comma);for(;Ht&&(++J,mt.push(Ne()),!!at(o.Comma)););return Ht?new xe(mt):mt[0]}function pr(){const Be=An(!0);if(!(Be instanceof V||Be instanceof xe))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Be.type} instead`);ue(o.In,"Expected `in` keyword following loop variable");const Ne=Xn();ue(o.CloseStatement,"Expected closing statement token");const mt=[];for(;dt(o.OpenStatement,o.EndFor)&&dt(o.OpenStatement,o.Else);)mt.push(Me());const Ht=[];if(at(o.OpenStatement,o.Else))for(++J,++J,ue(o.CloseStatement,"Expected closing statement token");dt(o.OpenStatement,o.EndFor);)Ht.push(Me());return new Y(Be,Ne,mt,Ht)}function Xn(){return mr()}function mr(){const Be=Hr();if(at(o.If)){++J;const Ne=Hr();if(at(o.Else)){++J;const mt=Hr();return new W(Ne,[Be],[mt])}else return new Je(Be,Ne)}return Be}function Hr(){let Be=ft();for(;at(o.Or);){const Ne=U[J];++J;const mt=ft();Be=new Ce(Ne,Be,mt)}return Be}function ft(){let Be=oe();for(;at(o.And);){const Ne=U[J];++J;const mt=oe();Be=new Ce(Ne,Be,mt)}return Be}function oe(){let Be;for(;at(o.Not);){const Ne=U[J];++J;const mt=oe();Be=new be(Ne,mt)}return Be??Se()}function Se(){let Be=Re();for(;at(o.ComparisonBinaryOperator)||at(o.In)||at(o.NotIn);){const Ne=U[J];++J;const mt=Re();Be=new Ce(Ne,Be,mt)}return Be}function Re(){let Be=_t();for(;at(o.AdditiveBinaryOperator);){const Ne=U[J];++J;const mt=_t();Be=new Ce(Ne,Be,mt)}return Be}function Oe(){const Be=$t();return at(o.OpenParen)?Ve(Be):Be}function Ve(Be){let Ne=new j(Be,ut());return at(o.OpenParen)&&(Ne=Ve(Ne)),Ne}function ut(){ue(o.OpenParen,"Expected opening parenthesis for arguments list");const Be=xt();return ue(o.CloseParen,"Expected closing parenthesis for arguments list"),Be}function xt(){const Be=[];for(;!at(o.CloseParen);){let Ne=Xn();if(at(o.Equals)){if(++J,!(Ne instanceof V))throw new SyntaxError("Expected identifier for keyword argument");const mt=Xn();Ne=new ae(Ne,mt)}Be.push(Ne),at(o.Comma)&&++J}return Be}function yt(){const Be=[];let Ne=!1;for(;!at(o.CloseSquareBracket);)at(o.Colon)?(Be.push(void 0),++J,Ne=!0):(Be.push(Xn()),at(o.Colon)&&(++J,Ne=!0));if(Be.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Ne){if(Be.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new Q(...Be)}return Be[0]}function $t(){let Be=Rt();for(;at(o.Dot)||at(o.OpenSquareBracket);){const Ne=U[J];++J;let mt;const Ht=Ne.type!==o.Dot;if(Ht)mt=yt(),ue(o.CloseSquareBracket,"Expected closing square bracket");else if(mt=Rt(),mt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Be=new P(Be,mt,Ht)}return Be}function _t(){let Be=Ut();for(;at(o.MultiplicativeBinaryOperator);){const Ne=U[J];++J;const mt=Ut();Be=new Ce(Ne,Be,mt)}return Be}function Ut(){let Be=Gt();for(;at(o.Is);){++J;const Ne=at(o.Not);Ne&&++J;let mt=Rt();if(mt instanceof pe&&(mt=new V(mt.value.toString())),!(mt instanceof V))throw new SyntaxError("Expected identifier for the test");Be=new it(Be,Ne,mt)}return Be}function Gt(){let Be=Oe();for(;at(o.Pipe);){++J;let Ne=Rt();if(!(Ne instanceof V))throw new SyntaxError("Expected identifier for the filter");at(o.OpenParen)&&(Ne=Ve(Ne)),Be=new tt(Be,Ne)}return Be}function Rt(){const Be=U[J];switch(Be.type){case o.NumericLiteral:return++J,new q(Number(Be.value));case o.StringLiteral:return++J,new L(Be.value);case o.BooleanLiteral:return++J,new pe(Be.value.toLowerCase()==="true");case o.Identifier:return++J,new V(Be.value);case o.OpenParen:{++J;const Ne=An();if(U[J].type!==o.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${U[J].type} instead`);return++J,Ne}case o.OpenSquareBracket:{++J;const Ne=[];for(;!at(o.CloseSquareBracket);)Ne.push(Xn()),at(o.Comma)&&++J;return++J,new fe(Ne)}case o.OpenCurlyBracket:{++J;const Ne=new Map;for(;!at(o.CloseCurlyBracket);){const mt=Xn();ue(o.Colon,"Expected colon between key and value in object literal");const Ht=Xn();Ne.set(mt,Ht),at(o.Comma)&&++J}return++J,new $e(Ne)}default:throw new SyntaxError(`Unexpected token: ${Be.type}`)}}for(;J<U.length;)se.body.push(Me());return se}function Pe(U,se,J=1){se===void 0&&(se=U,U=0);const ue=[];for(let Me=U;Me<se;Me+=J)ue.push(Me);return ue}function Ze(U,se,J,ue=1){const Me=Math.sign(ue);Me>=0?(se=(se??(se=0))<0?Math.max(U.length+se,0):Math.min(se,U.length),J=(J??(J=U.length))<0?Math.max(U.length+J,0):Math.min(J,U.length)):(se=(se??(se=U.length-1))<0?Math.max(U.length+se,-1):Math.min(se,U.length-1),J=(J??(J=-1))<-1?Math.max(U.length+J,-1):Math.min(J,U.length-1));const dt=[];for(let at=se;Me*at<Me*J;at+=ue)dt.push(U[at]);return dt}function me(U){return U.replace(/\b\w/g,se=>se.toUpperCase())}var Qe=class{constructor(U=void 0){Ee(this,"type","RuntimeValue");Ee(this,"value");Ee(this,"builtins",new Map);this.value=U}__bool__(){return new rt(!!this.value)}},et=class extends Qe{constructor(){super(...arguments);Ee(this,"type","NumericValue")}},Ie=class extends Qe{constructor(){super(...arguments);Ee(this,"type","StringValue");Ee(this,"builtins",new Map([["upper",new Ye(()=>new Ie(this.value.toUpperCase()))],["lower",new Ye(()=>new Ie(this.value.toLowerCase()))],["strip",new Ye(()=>new Ie(this.value.trim()))],["title",new Ye(()=>new Ie(me(this.value)))],["length",new et(this.value.length)]]))}},rt=class extends Qe{constructor(){super(...arguments);Ee(this,"type","BooleanValue")}},vt=class extends Qe{constructor(){super(...arguments);Ee(this,"type","ObjectValue");Ee(this,"builtins",new Map([["get",new Ye(([se,J])=>{if(!(se instanceof Ie))throw new Error(`Object key must be a string: got ${se.type}`);return this.value.get(se.value)??J??new lt})],["items",new Ye(()=>new ce(Array.from(this.value.entries()).map(([se,J])=>new ce([new Ie(se),J]))))]]))}__bool__(){return new rt(this.value.size>0)}},nt=class extends vt{constructor(){super(...arguments);Ee(this,"type","KeywordArgumentsValue")}},ce=class extends Qe{constructor(){super(...arguments);Ee(this,"type","ArrayValue");Ee(this,"builtins",new Map([["length",new et(this.value.length)]]))}__bool__(){return new rt(this.value.length>0)}},ze=class extends ce{constructor(){super(...arguments);Ee(this,"type","TupleValue")}},Ye=class extends Qe{constructor(){super(...arguments);Ee(this,"type","FunctionValue")}},lt=class extends Qe{constructor(){super(...arguments);Ee(this,"type","NullValue")}},We=class extends Qe{constructor(){super(...arguments);Ee(this,"type","UndefinedValue")}},Ge=class{constructor(U){Ee(this,"variables",new Map([["namespace",new Ye(U=>{if(U.length===0)return new vt(new Map);if(U.length!==1||!(U[0]instanceof vt))throw new Error("`namespace` expects either zero arguments or a single object argument");return U[0]})]]));Ee(this,"tests",new Map([["boolean",U=>U.type==="BooleanValue"],["callable",U=>U instanceof Ye],["odd",U=>{if(U.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${U.type}`);return U.value%2!==0}],["even",U=>{if(U.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${U.type}`);return U.value%2===0}],["false",U=>U.type==="BooleanValue"&&!U.value],["true",U=>U.type==="BooleanValue"&&U.value],["string",U=>U.type==="StringValue"],["number",U=>U.type==="NumericValue"],["integer",U=>U.type==="NumericValue"&&Number.isInteger(U.value)],["iterable",U=>U instanceof ce||U instanceof Ie],["lower",U=>{const se=U.value;return U.type==="StringValue"&&se===se.toLowerCase()}],["upper",U=>{const se=U.value;return U.type==="StringValue"&&se===se.toUpperCase()}],["none",U=>U.type==="NullValue"],["defined",U=>U.type!=="UndefinedValue"],["undefined",U=>U.type==="UndefinedValue"],["equalto",(U,se)=>U.value===se.value],["eq",(U,se)=>U.value===se.value]]));this.parent=U}set(U,se){return this.declareVariable(U,bt(se))}declareVariable(U,se){if(this.variables.has(U))throw new SyntaxError(`Variable already declared: ${U}`);return this.variables.set(U,se),se}setVariable(U,se){return this.variables.set(U,se),se}resolve(U){if(this.variables.has(U))return this;if(this.parent)return this.parent.resolve(U);throw new Error(`Unknown variable: ${U}`)}lookupVariable(U){try{return this.resolve(U).variables.get(U)??new We}catch{return new We}}},ht=class{constructor(U){Ee(this,"global");this.global=U??new Ge}run(U){return this.evaluate(U,this.global)}evaluateBinaryExpression(U,se){const J=this.evaluate(U.left,se);switch(U.operator.value){case"and":return J.__bool__().value?this.evaluate(U.right,se):J;case"or":return J.__bool__().value?J:this.evaluate(U.right,se)}const ue=this.evaluate(U.right,se);switch(U.operator.value){case"==":return new rt(J.value==ue.value);case"!=":return new rt(J.value!=ue.value)}if(J instanceof We||ue instanceof We)throw new Error("Cannot perform operation on undefined values");if(J instanceof lt||ue instanceof lt)throw new Error("Cannot perform operation on null values");if(J instanceof et&&ue instanceof et)switch(U.operator.value){case"+":return new et(J.value+ue.value);case"-":return new et(J.value-ue.value);case"*":return new et(J.value*ue.value);case"/":return new et(J.value/ue.value);case"%":return new et(J.value%ue.value);case"<":return new rt(J.value<ue.value);case">":return new rt(J.value>ue.value);case">=":return new rt(J.value>=ue.value);case"<=":return new rt(J.value<=ue.value)}else if(J instanceof ce&&ue instanceof ce)switch(U.operator.value){case"+":return new ce(J.value.concat(ue.value))}else if(ue instanceof ce){const Me=ue.value.find(dt=>dt.value===J.value)!==void 0;switch(U.operator.value){case"in":return new rt(Me);case"not in":return new rt(!Me)}}if(J instanceof Ie||ue instanceof Ie)switch(U.operator.value){case"+":return new Ie(J.value.toString()+ue.value.toString())}if(J instanceof Ie&&ue instanceof Ie)switch(U.operator.value){case"in":return new rt(ue.value.includes(J.value));case"not in":return new rt(!ue.value.includes(J.value))}if(J instanceof Ie&&ue instanceof vt)switch(U.operator.value){case"in":return new rt(ue.value.has(J.value));case"not in":return new rt(!ue.value.has(J.value))}throw new SyntaxError(`Unknown operator "${U.operator.value}" between ${J.type} and ${ue.type}`)}evaluateArguments(U,se){const J=[],ue=new Map;for(const Me of U)if(Me.type==="KeywordArgumentExpression"){const dt=Me;ue.set(dt.key.value,this.evaluate(dt.value,se))}else{if(ue.size>0)throw new Error("Positional arguments must come before keyword arguments");J.push(this.evaluate(Me,se))}return[J,ue]}evaluateFilterExpression(U,se){const J=this.evaluate(U.operand,se);if(U.filter.type==="Identifier"){const ue=U.filter;if(ue.value==="tojson")return new Ie(Ot(J));if(J instanceof ce)switch(ue.value){case"list":return J;case"first":return J.value[0];case"last":return J.value[J.value.length-1];case"length":return new et(J.value.length);case"reverse":return new ce(J.value.reverse());case"sort":return new ce(J.value.sort((Me,dt)=>{if(Me.type!==dt.type)throw new Error(`Cannot compare different types: ${Me.type} and ${dt.type}`);switch(Me.type){case"NumericValue":return Me.value-dt.value;case"StringValue":return Me.value.localeCompare(dt.value);default:throw new Error(`Cannot compare type: ${Me.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${ue.value}`)}else if(J instanceof Ie)switch(ue.value){case"length":return new et(J.value.length);case"upper":return new Ie(J.value.toUpperCase());case"lower":return new Ie(J.value.toLowerCase());case"title":return new Ie(me(J.value));case"capitalize":return new Ie(J.value.charAt(0).toUpperCase()+J.value.slice(1));case"trim":return new Ie(J.value.trim());case"indent":return new Ie(J.value.split(`
`).map((Me,dt)=>dt===0||Me.length===0?Me:"    "+Me).join(`
`));case"string":return J;default:throw new Error(`Unknown StringValue filter: ${ue.value}`)}else if(J instanceof et)switch(ue.value){case"abs":return new et(Math.abs(J.value));default:throw new Error(`Unknown NumericValue filter: ${ue.value}`)}else if(J instanceof vt)switch(ue.value){case"items":return new ce(Array.from(J.value.entries()).map(([Me,dt])=>new ce([new Ie(Me),dt])));case"length":return new et(J.value.size);default:throw new Error(`Unknown ObjectValue filter: ${ue.value}`)}throw new Error(`Cannot apply filter "${ue.value}" to type: ${J.type}`)}else if(U.filter.type==="CallExpression"){const ue=U.filter;if(ue.callee.type!=="Identifier")throw new Error(`Unknown filter: ${ue.callee.type}`);const Me=ue.callee.value;if(Me==="tojson"){const[,dt]=this.evaluateArguments(ue.args,se),at=dt.get("indent")??new lt;if(!(at instanceof et||at instanceof lt))throw new Error("If set, indent must be a number");return new Ie(Ot(J,at.value))}if(J instanceof ce){switch(Me){case"selectattr":{if(J.value.some(Nt=>!(Nt instanceof vt)))throw new Error("`selectattr` can only be applied to array of objects");if(ue.args.some(Nt=>Nt.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[dt,at,Wt]=ue.args.map(Nt=>this.evaluate(Nt,se));let Tt;if(at){const Nt=se.tests.get(at.value);if(!Nt)throw new Error(`Unknown test: ${at.value}`);Tt=Nt}else Tt=(...Nt)=>Nt[0].__bool__().value;const St=J.value.filter(Nt=>{const Dt=Nt.value.get(dt.value);return Dt?Tt(Dt,Wt):!1});return new ce(St)}case"map":{const[,dt]=this.evaluateArguments(ue.args,se);if(dt.has("attribute")){const at=dt.get("attribute");if(!(at instanceof Ie))throw new Error("attribute must be a string");const Wt=dt.get("default"),Tt=J.value.map(St=>{if(!(St instanceof vt))throw new Error("items in map must be an object");return St.value.get(at.value)??Wt??new We});return new ce(Tt)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${Me}`)}else if(J instanceof Ie){switch(Me){case"indent":{const[dt,at]=this.evaluateArguments(ue.args,se),Wt=dt.at(0)??at.get("width")??new et(4);if(!(Wt instanceof et))throw new Error("width must be a number");const Tt=dt.at(1)??at.get("first")??new rt(!1),St=dt.at(2)??at.get("blank")??new rt(!1),Nt=J.value.split(`
`),Dt=" ".repeat(Wt.value),gn=Nt.map((An,pr)=>!Tt.value&&pr===0||!St.value&&An.length===0?An:Dt+An);return new Ie(gn.join(`
`))}}throw new Error(`Unknown StringValue filter: ${Me}`)}else throw new Error(`Cannot apply filter "${Me}" to type: ${J.type}`)}throw new Error(`Unknown filter: ${U.filter.type}`)}evaluateTestExpression(U,se){const J=this.evaluate(U.operand,se),ue=se.tests.get(U.test.value);if(!ue)throw new Error(`Unknown test: ${U.test.value}`);const Me=ue(J);return new rt(U.negate?!Me:Me)}evaluateUnaryExpression(U,se){const J=this.evaluate(U.argument,se);switch(U.operator.value){case"not":return new rt(!J.value);default:throw new SyntaxError(`Unknown operator: ${U.operator.value}`)}}evalProgram(U,se){return this.evaluateBlock(U.body,se)}evaluateBlock(U,se){let J="";for(const ue of U){const Me=this.evaluate(ue,se);Me.type!=="NullValue"&&Me.type!=="UndefinedValue"&&(J+=Me.value)}return new Ie(J)}evaluateIdentifier(U,se){return se.lookupVariable(U.value)}evaluateCallExpression(U,se){const[J,ue]=this.evaluateArguments(U.args,se);ue.size>0&&J.push(new nt(ue));const Me=this.evaluate(U.callee,se);if(Me.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Me.type}`);return Me.value(J,se)}evaluateSliceExpression(U,se,J){if(!(U instanceof ce||U instanceof Ie))throw new Error("Slice object must be an array or string");const ue=this.evaluate(se.start,J),Me=this.evaluate(se.stop,J),dt=this.evaluate(se.step,J);if(!(ue instanceof et||ue instanceof We))throw new Error("Slice start must be numeric or undefined");if(!(Me instanceof et||Me instanceof We))throw new Error("Slice stop must be numeric or undefined");if(!(dt instanceof et||dt instanceof We))throw new Error("Slice step must be numeric or undefined");return U instanceof ce?new ce(Ze(U.value,ue.value,Me.value,dt.value)):new Ie(Ze(Array.from(U.value),ue.value,Me.value,dt.value).join(""))}evaluateMemberExpression(U,se){const J=this.evaluate(U.object,se);let ue;if(U.computed){if(U.property.type==="SliceExpression")return this.evaluateSliceExpression(J,U.property,se);ue=this.evaluate(U.property,se)}else ue=new Ie(U.property.value);let Me;if(J instanceof vt){if(!(ue instanceof Ie))throw new Error(`Cannot access property with non-string: got ${ue.type}`);Me=J.value.get(ue.value)??J.builtins.get(ue.value)}else if(J instanceof ce||J instanceof Ie)if(ue instanceof et)Me=J.value.at(ue.value),J instanceof Ie&&(Me=new Ie(J.value.at(ue.value)));else if(ue instanceof Ie)Me=J.builtins.get(ue.value);else throw new Error(`Cannot access property with non-string/non-number: got ${ue.type}`);else{if(!(ue instanceof Ie))throw new Error(`Cannot access property with non-string: got ${ue.type}`);Me=J.builtins.get(ue.value)}return Me instanceof Qe?Me:new We}evaluateSet(U,se){const J=this.evaluate(U.value,se);if(U.assignee.type==="Identifier"){const ue=U.assignee.value;se.setVariable(ue,J)}else if(U.assignee.type==="MemberExpression"){const ue=U.assignee,Me=this.evaluate(ue.object,se);if(!(Me instanceof vt))throw new Error("Cannot assign to member of non-object");if(ue.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");Me.value.set(ue.property.value,J)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(U.assignee)}`);return new lt}evaluateIf(U,se){const J=this.evaluate(U.test,se);return this.evaluateBlock(J.__bool__().value?U.body:U.alternate,se)}evaluateFor(U,se){const J=new Ge(se);let ue,Me;if(U.iterable.type==="SelectExpression"){const St=U.iterable;Me=this.evaluate(St.iterable,J),ue=St.test}else Me=this.evaluate(U.iterable,J);if(!(Me instanceof ce))throw new Error(`Expected iterable type in for loop: got ${Me.type}`);const dt=[],at=[];for(let St=0;St<Me.value.length;++St){const Nt=new Ge(J),Dt=Me.value[St];let gn;if(U.loopvar.type==="Identifier")gn=An=>An.setVariable(U.loopvar.value,Dt);else if(U.loopvar.type==="TupleLiteral"){const An=U.loopvar;if(Dt.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${Dt.type}`);const pr=Dt;if(An.value.length!==pr.value.length)throw new Error(`Too ${An.value.length>pr.value.length?"few":"many"} items to unpack`);gn=Xn=>{for(let mr=0;mr<An.value.length;++mr){if(An.value[mr].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${An.value[mr].type}`);Xn.setVariable(An.value[mr].value,pr.value[mr])}}}else throw new Error(`Invalid loop variable(s): ${U.loopvar.type}`);ue&&(gn(Nt),!this.evaluate(ue,Nt).__bool__().value)||(dt.push(Dt),at.push(gn))}let Wt="",Tt=!0;for(let St=0;St<dt.length;++St){const Nt=new Map([["index",new et(St+1)],["index0",new et(St)],["revindex",new et(dt.length-St)],["revindex0",new et(dt.length-St-1)],["first",new rt(St===0)],["last",new rt(St===dt.length-1)],["length",new et(dt.length)],["previtem",St>0?dt[St-1]:new We],["nextitem",St<dt.length-1?dt[St+1]:new We]]);J.setVariable("loop",new vt(Nt)),at[St](J);const Dt=this.evaluateBlock(U.body,J);Wt+=Dt.value,Tt=!1}if(Tt){const St=this.evaluateBlock(U.defaultBlock,J);Wt+=St.value}return new Ie(Wt)}evaluateMacro(U,se){return se.setVariable(U.name.value,new Ye((J,ue)=>{var at;const Me=new Ge(ue);J=J.slice();let dt;((at=J.at(-1))==null?void 0:at.type)==="KeywordArgumentsValue"&&(dt=J.pop());for(let Wt=0;Wt<U.args.length;++Wt){const Tt=U.args[Wt],St=J[Wt];if(Tt.type==="Identifier"){const Nt=Tt;if(!St)throw new Error(`Missing positional argument: ${Nt.value}`);Me.setVariable(Nt.value,St)}else if(Tt.type==="KeywordArgumentExpression"){const Nt=Tt,Dt=St??(dt==null?void 0:dt.value.get(Nt.key.value))??this.evaluate(Nt.value,Me);Me.setVariable(Nt.key.value,Dt)}else throw new Error(`Unknown argument type: ${Tt.type}`)}return this.evaluateBlock(U.body,Me)})),new lt}evaluate(U,se){if(U===void 0)return new We;switch(U.type){case"Program":return this.evalProgram(U,se);case"Set":return this.evaluateSet(U,se);case"If":return this.evaluateIf(U,se);case"For":return this.evaluateFor(U,se);case"Macro":return this.evaluateMacro(U,se);case"NumericLiteral":return new et(Number(U.value));case"StringLiteral":return new Ie(U.value);case"BooleanLiteral":return new rt(U.value);case"ArrayLiteral":return new ce(U.value.map(J=>this.evaluate(J,se)));case"TupleLiteral":return new ze(U.value.map(J=>this.evaluate(J,se)));case"ObjectLiteral":{const J=new Map;for(const[ue,Me]of U.value){const dt=this.evaluate(ue,se);if(!(dt instanceof Ie))throw new Error(`Object keys must be strings: got ${dt.type}`);J.set(dt.value,this.evaluate(Me,se))}return new vt(J)}case"Identifier":return this.evaluateIdentifier(U,se);case"CallExpression":return this.evaluateCallExpression(U,se);case"MemberExpression":return this.evaluateMemberExpression(U,se);case"UnaryExpression":return this.evaluateUnaryExpression(U,se);case"BinaryExpression":return this.evaluateBinaryExpression(U,se);case"FilterExpression":return this.evaluateFilterExpression(U,se);case"TestExpression":return this.evaluateTestExpression(U,se);default:throw new SyntaxError(`Unknown node type: ${U.type}`)}}};function bt(U){switch(typeof U){case"number":return new et(U);case"string":return new Ie(U);case"boolean":return new rt(U);case"undefined":return new We;case"object":return U===null?new lt:Array.isArray(U)?new ce(U.map(bt)):new vt(new Map(Object.entries(U).map(([se,J])=>[se,bt(J)])));case"function":return new Ye((se,J)=>{const ue=U(...se.map(Me=>Me.value))??null;return bt(ue)});default:throw new Error(`Cannot convert to runtime value: ${U}`)}}function Ot(U,se,J){const ue=J??0;switch(U.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(U.value);case"ArrayValue":case"ObjectValue":{const Me=se?" ".repeat(se):"",dt=`
`+Me.repeat(ue),at=dt+Me;if(U.type==="ArrayValue"){const Wt=U.value.map(Tt=>Ot(Tt,se,ue+1));return se?`[${at}${Wt.join(`,${at}`)}${dt}]`:`[${Wt.join(", ")}]`}else{const Wt=Array.from(U.value.entries()).map(([Tt,St])=>{const Nt=`"${Tt}": ${Ot(St,se,ue+1)}`;return se?`${at}${Nt}`:Nt});return se?`{${Wt.join(",")}${dt}}`:`{${Wt.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${U.type}`)}}var Ct=class{constructor(U){Ee(this,"parsed");const se=E(U,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=ye(se)}render(U){const se=new Ge;se.set("false",!1),se.set("true",!0),se.set("raise_exception",Me=>{throw new Error(Me)}),se.set("range",Pe);for(const[Me,dt]of Object.entries(U))se.set(Me,dt);return new ht(se).run(this.parsed).value}}},"./node_modules/onnxruntime-common/dist/esm/backend-impl.js":(e,t,r)=>{r.r(t),r.d(t,{registerBackend:()=>l,resolveBackendAndExecutionProviders:()=>w});const o=new Map,a=[],l=(_,y,T)=>{if(y&&typeof y.init=="function"&&typeof y.createInferenceSessionHandler=="function"){const E=o.get(_);if(E===void 0)o.set(_,{backend:y,priority:T});else{if(E.priority>T)return;if(E.priority===T&&E.backend!==y)throw new Error(`cannot register backend "${_}" using priority ${T}`)}if(T>=0){const A=a.indexOf(_);A!==-1&&a.splice(A,1);for(let H=0;H<a.length;H++)if(o.get(a[H]).priority<=T){a.splice(H,0,_);return}a.push(_)}return}throw new TypeError("not a valid backend")},p=async _=>{const y=o.get(_);if(!y)return"backend not found.";if(y.initialized)return y.backend;if(y.aborted)return y.error;{const T=!!y.initPromise;try{return T||(y.initPromise=y.backend.init(_)),await y.initPromise,y.initialized=!0,y.backend}catch(E){return T||(y.error=`${E}`,y.aborted=!0),y.error}finally{delete y.initPromise}}},w=async _=>{const y=_.executionProviders||[],T=y.map(B=>typeof B=="string"?B:B.name),E=T.length===0?a:T;let A;const H=[],W=new Set;for(const B of E){const F=await p(B);typeof F=="string"?H.push({name:B,err:F}):(A||(A=F),A===F&&W.add(B))}if(!A)throw new Error(`no available backend found. ERR: ${H.map(B=>`[${B.name}] ${B.err}`).join(", ")}`);for(const{name:B,err:F}of H)T.includes(B)&&console.warn(`removing requested execution provider "${B}" from session options because it is not available: ${F}`);const Y=y.filter(B=>W.has(typeof B=="string"?B:B.name));return[A,new Proxy(_,{get:(B,F)=>F==="executionProviders"?Y:Reflect.get(B,F)})]}},"./node_modules/onnxruntime-common/dist/esm/backend.js":(e,t,r)=>{r.r(t),r.d(t,{registerBackend:()=>o.registerBackend});var o=r("./node_modules/onnxruntime-common/dist/esm/backend-impl.js")},"./node_modules/onnxruntime-common/dist/esm/env-impl.js":(e,t,r)=>{r.r(t),r.d(t,{env:()=>l});var o=r("./node_modules/onnxruntime-common/dist/esm/version.js");let a="warning";const l={wasm:{},webgl:{},webgpu:{},versions:{common:o.version},set logLevel(p){if(p!==void 0){if(typeof p!="string"||["verbose","info","warning","error","fatal"].indexOf(p)===-1)throw new Error(`Unsupported logging level: ${p}`);a=p}},get logLevel(){return a}};Object.defineProperty(l,"logLevel",{enumerable:!0})},"./node_modules/onnxruntime-common/dist/esm/env.js":(e,t,r)=>{r.r(t),r.d(t,{env:()=>a});var o=r("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const a=o.env},"./node_modules/onnxruntime-common/dist/esm/index.js":(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>l.InferenceSession,TRACE:()=>w.TRACE,TRACE_FUNC_BEGIN:()=>w.TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>w.TRACE_FUNC_END,Tensor:()=>p.Tensor,TrainingSession:()=>_.TrainingSession,env:()=>a.env,registerBackend:()=>o.registerBackend});var o=r("./node_modules/onnxruntime-common/dist/esm/backend.js"),a=r("./node_modules/onnxruntime-common/dist/esm/env.js"),l=r("./node_modules/onnxruntime-common/dist/esm/inference-session.js"),p=r("./node_modules/onnxruntime-common/dist/esm/tensor.js");r("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),r("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");var w=r("./node_modules/onnxruntime-common/dist/esm/trace.js");r("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),r("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");var _=r("./node_modules/onnxruntime-common/dist/esm/training-session.js")},"./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>p});var o=r("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),a=r("./node_modules/onnxruntime-common/dist/esm/tensor.js"),l=r("./node_modules/onnxruntime-common/dist/esm/trace.js");class p{constructor(_){this.handler=_}async run(_,y,T){(0,l.TRACE_FUNC_BEGIN)();const E={};let A={};if(typeof _!="object"||_===null||_ instanceof a.Tensor||Array.isArray(_))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let H=!0;if(typeof y=="object"){if(y===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(y instanceof a.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(y)){if(y.length===0)throw new TypeError("'fetches' cannot be an empty array.");H=!1;for(const B of y){if(typeof B!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(B)===-1)throw new RangeError(`'fetches' contains invalid output name: ${B}.`);E[B]=null}if(typeof T=="object"&&T!==null)A=T;else if(typeof T<"u")throw new TypeError("'options' must be an object.")}else{let B=!1;const F=Object.getOwnPropertyNames(y);for(const O of this.outputNames)if(F.indexOf(O)!==-1){const P=y[O];(P===null||P instanceof a.Tensor)&&(B=!0,H=!1,E[O]=P)}if(B){if(typeof T=="object"&&T!==null)A=T;else if(typeof T<"u")throw new TypeError("'options' must be an object.")}else A=y}}else if(typeof y<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const B of this.inputNames)if(typeof _[B]>"u")throw new Error(`input '${B}' is missing in 'feeds'.`);if(H)for(const B of this.outputNames)E[B]=null;const W=await this.handler.run(_,E,A),Y={};for(const B in W)if(Object.hasOwnProperty.call(W,B)){const F=W[B];F instanceof a.Tensor?Y[B]=F:Y[B]=new a.Tensor(F.type,F.data,F.dims)}return(0,l.TRACE_FUNC_END)(),Y}async release(){return this.handler.dispose()}static async create(_,y,T,E){(0,l.TRACE_FUNC_BEGIN)();let A,H={};if(typeof _=="string"){if(A=_,typeof y=="object"&&y!==null)H=y;else if(typeof y<"u")throw new TypeError("'options' must be an object.")}else if(_ instanceof Uint8Array){if(A=_,typeof y=="object"&&y!==null)H=y;else if(typeof y<"u")throw new TypeError("'options' must be an object.")}else if(_ instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&_ instanceof SharedArrayBuffer){const F=_;let O=0,P=_.byteLength;if(typeof y=="object"&&y!==null)H=y;else if(typeof y=="number"){if(O=y,!Number.isSafeInteger(O))throw new RangeError("'byteOffset' must be an integer.");if(O<0||O>=F.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${F.byteLength}).`);if(P=_.byteLength-O,typeof T=="number"){if(P=T,!Number.isSafeInteger(P))throw new RangeError("'byteLength' must be an integer.");if(P<=0||O+P>F.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${F.byteLength-O}].`);if(typeof E=="object"&&E!==null)H=E;else if(typeof E<"u")throw new TypeError("'options' must be an object.")}else if(typeof T<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof y<"u")throw new TypeError("'options' must be an object.");A=new Uint8Array(F,O,P)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[W,Y]=await(0,o.resolveBackendAndExecutionProviders)(H),B=await W.createInferenceSessionHandler(A,Y);return(0,l.TRACE_FUNC_END)(),new p(B)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./node_modules/onnxruntime-common/dist/esm/inference-session.js":(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>a});var o=r("./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js");const a=o.InferenceSession},"./node_modules/onnxruntime-common/dist/esm/onnx-model.js":(e,t,r)=>{r.r(t)},"./node_modules/onnxruntime-common/dist/esm/onnx-value.js":(e,t,r)=>{r.r(t)},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":(e,t,r)=>{r.r(t),r.d(t,{tensorToDataURL:()=>o,tensorToImageData:()=>a});const o=(l,p)=>{const w=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);w.width=l.dims[3],w.height=l.dims[2];const _=w.getContext("2d");if(_!=null){let y,T;(p==null?void 0:p.tensorLayout)!==void 0&&p.tensorLayout==="NHWC"?(y=l.dims[2],T=l.dims[3]):(y=l.dims[3],T=l.dims[2]);const E=(p==null?void 0:p.format)!==void 0?p.format:"RGB",A=p==null?void 0:p.norm;let H,W;A===void 0||A.mean===void 0?H=[255,255,255,255]:typeof A.mean=="number"?H=[A.mean,A.mean,A.mean,A.mean]:(H=[A.mean[0],A.mean[1],A.mean[2],0],A.mean[3]!==void 0&&(H[3]=A.mean[3])),A===void 0||A.bias===void 0?W=[0,0,0,0]:typeof A.bias=="number"?W=[A.bias,A.bias,A.bias,A.bias]:(W=[A.bias[0],A.bias[1],A.bias[2],0],A.bias[3]!==void 0&&(W[3]=A.bias[3]));const Y=T*y;let B=0,F=Y,O=Y*2,P=-1;E==="RGBA"?(B=0,F=Y,O=Y*2,P=Y*3):E==="RGB"?(B=0,F=Y,O=Y*2):E==="RBG"&&(B=0,O=Y,F=Y*2);for(let j=0;j<T;j++)for(let V=0;V<y;V++){const z=(l.data[B++]-W[0])*H[0],q=(l.data[F++]-W[1])*H[1],L=(l.data[O++]-W[2])*H[2],pe=P===-1?255:(l.data[P++]-W[3])*H[3];_.fillStyle="rgba("+z+","+q+","+L+","+pe+")",_.fillRect(V,j,1,1)}if("toDataURL"in w)return w.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},a=(l,p)=>{const w=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let _;if(w!=null){let y,T,E;(p==null?void 0:p.tensorLayout)!==void 0&&p.tensorLayout==="NHWC"?(y=l.dims[2],T=l.dims[1],E=l.dims[3]):(y=l.dims[3],T=l.dims[2],E=l.dims[1]);const A=p!==void 0&&p.format!==void 0?p.format:"RGB",H=p==null?void 0:p.norm;let W,Y;H===void 0||H.mean===void 0?W=[255,255,255,255]:typeof H.mean=="number"?W=[H.mean,H.mean,H.mean,H.mean]:(W=[H.mean[0],H.mean[1],H.mean[2],255],H.mean[3]!==void 0&&(W[3]=H.mean[3])),H===void 0||H.bias===void 0?Y=[0,0,0,0]:typeof H.bias=="number"?Y=[H.bias,H.bias,H.bias,H.bias]:(Y=[H.bias[0],H.bias[1],H.bias[2],0],H.bias[3]!==void 0&&(Y[3]=H.bias[3]));const B=T*y;if(p!==void 0&&(p.format!==void 0&&E===4&&p.format!=="RGBA"||E===3&&p.format!=="RGB"&&p.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const F=4;let O=0,P=1,j=2,V=3,z=0,q=B,L=B*2,pe=-1;A==="RGBA"?(z=0,q=B,L=B*2,pe=B*3):A==="RGB"?(z=0,q=B,L=B*2):A==="RBG"&&(z=0,L=B,q=B*2),_=w.createImageData(y,T);for(let fe=0;fe<T*y;O+=F,P+=F,j+=F,V+=F,fe++)_.data[O]=(l.data[z++]-Y[0])*W[0],_.data[P]=(l.data[q++]-Y[1])*W[1],_.data[j]=(l.data[L++]-Y[2])*W[2],_.data[V]=pe===-1?255:(l.data[pe++]-Y[3])*W[3]}else throw new Error("Can not access image data");return _}},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":(e,t,r)=>{r.r(t)},"./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":(e,t,r)=>{r.r(t),r.d(t,{bufferToTensor:()=>a,tensorFromGpuBuffer:()=>w,tensorFromImage:()=>l,tensorFromPinnedBuffer:()=>_,tensorFromTexture:()=>p});var o=r("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const a=(y,T)=>{if(y===void 0)throw new Error("Image buffer must be defined");if(T.height===void 0||T.width===void 0)throw new Error("Image height and width must be defined");if(T.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:E,width:A}=T,H=T.norm??{mean:255,bias:0};let W,Y;typeof H.mean=="number"?W=[H.mean,H.mean,H.mean,H.mean]:W=[H.mean[0],H.mean[1],H.mean[2],H.mean[3]??255],typeof H.bias=="number"?Y=[H.bias,H.bias,H.bias,H.bias]:Y=[H.bias[0],H.bias[1],H.bias[2],H.bias[3]??0];const B=T.format!==void 0?T.format:"RGBA",F=T.tensorFormat!==void 0&&T.tensorFormat!==void 0?T.tensorFormat:"RGB",O=E*A,P=F==="RGBA"?new Float32Array(O*4):new Float32Array(O*3);let j=4,V=0,z=1,q=2,L=3,pe=0,fe=O,xe=O*2,$e=-1;B==="RGB"&&(j=3,V=0,z=1,q=2,L=-1),F==="RGBA"?$e=O*3:F==="RBG"?(pe=0,xe=O,fe=O*2):F==="BGR"&&(xe=0,fe=O,pe=O*2);for(let tt=0;tt<O;tt++,V+=j,q+=j,z+=j,L+=j)P[pe++]=(y[V]+Y[0])/W[0],P[fe++]=(y[z]+Y[1])/W[1],P[xe++]=(y[q]+Y[2])/W[2],$e!==-1&&L!==-1&&(P[$e++]=(y[L]+Y[3])/W[3]);return F==="RGBA"?new o.Tensor("float32",P,[1,4,E,A]):new o.Tensor("float32",P,[1,3,E,A])},l=async(y,T)=>{const E=typeof HTMLImageElement<"u"&&y instanceof HTMLImageElement,A=typeof ImageData<"u"&&y instanceof ImageData,H=typeof ImageBitmap<"u"&&y instanceof ImageBitmap,W=typeof y=="string";let Y,B=T??{};const F=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},O=P=>P instanceof HTMLCanvasElement||P instanceof OffscreenCanvas?P.getContext("2d"):null;if(E){const P=F();P.width=y.width,P.height=y.height;const j=O(P);if(j!=null){let V=y.height,z=y.width;if(T!==void 0&&T.resizedHeight!==void 0&&T.resizedWidth!==void 0&&(V=T.resizedHeight,z=T.resizedWidth),T!==void 0){if(B=T,T.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");B.tensorFormat="RGBA",B.height=V,B.width=z}else B.tensorFormat="RGBA",B.height=V,B.width=z;j.drawImage(y,0,0),Y=j.getImageData(0,0,z,V).data}else throw new Error("Can not access image data")}else if(A){let P,j;if(T!==void 0&&T.resizedWidth!==void 0&&T.resizedHeight!==void 0?(P=T.resizedHeight,j=T.resizedWidth):(P=y.height,j=y.width),T!==void 0&&(B=T),B.format="RGBA",B.height=P,B.width=j,T!==void 0){const V=F();V.width=j,V.height=P;const z=O(V);if(z!=null)z.putImageData(y,0,0),Y=z.getImageData(0,0,j,P).data;else throw new Error("Can not access image data")}else Y=y.data}else if(H){if(T===void 0)throw new Error("Please provide image config with format for Imagebitmap");const P=F();P.width=y.width,P.height=y.height;const j=O(P);if(j!=null){const V=y.height,z=y.width;return j.drawImage(y,0,0,z,V),Y=j.getImageData(0,0,z,V).data,B.height=V,B.width=z,a(Y,B)}else throw new Error("Can not access image data")}else{if(W)return new Promise((P,j)=>{const V=F(),z=O(V);if(!y||!z)return j();const q=new Image;q.crossOrigin="Anonymous",q.src=y,q.onload=()=>{V.width=q.width,V.height=q.height,z.drawImage(q,0,0,V.width,V.height);const L=z.getImageData(0,0,V.width,V.height);B.height=V.height,B.width=V.width,P(a(L.data,B))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(Y!==void 0)return a(Y,B);throw new Error("Input data provided is not supported - aborted tensor creation")},p=(y,T)=>{const{width:E,height:A,download:H,dispose:W}=T,Y=[1,A,E,4];return new o.Tensor({location:"texture",type:"float32",texture:y,dims:Y,download:H,dispose:W})},w=(y,T)=>{const{dataType:E,dims:A,download:H,dispose:W}=T;return new o.Tensor({location:"gpu-buffer",type:E??"float32",gpuBuffer:y,dims:A,download:H,dispose:W})},_=(y,T,E)=>new o.Tensor({location:"cpu-pinned",type:y,data:T,dims:E??[T.length]})},"./node_modules/onnxruntime-common/dist/esm/tensor-factory.js":(e,t,r)=>{r.r(t)},"./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":(e,t,r)=>{r.r(t),r.d(t,{NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP:()=>a,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP:()=>o,checkTypedArray:()=>p});const o=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),a=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let l=!1;const p=()=>{if(!l){l=!0;const w=typeof BigInt64Array<"u"&&BigInt64Array.from,_=typeof BigUint64Array<"u"&&BigUint64Array.from,y=typeof Float16Array<"u"&&Float16Array.from;w&&(o.set("int64",BigInt64Array),a.set(BigInt64Array,"int64")),_&&(o.set("uint64",BigUint64Array),a.set(BigUint64Array,"uint64")),y?(o.set("float16",Float16Array),a.set(Float16Array,"float16")):o.set("float16",Uint16Array)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-impl.js":(e,t,r)=>{r.r(t),r.d(t,{Tensor:()=>w});var o=r("./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"),a=r("./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"),l=r("./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"),p=r("./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js");class w{constructor(y,T,E){(0,l.checkTypedArray)();let A,H;if(typeof y=="object"&&"location"in y)switch(this.dataLocation=y.location,A=y.type,H=y.dims,y.location){case"cpu-pinned":{const Y=l.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(A);if(!Y)throw new TypeError(`unsupported type "${A}" to create tensor from pinned buffer`);if(!(y.data instanceof Y))throw new TypeError(`buffer should be of type ${Y.name}`);this.cpuData=y.data;break}case"texture":{if(A!=="float32")throw new TypeError(`unsupported type "${A}" to create tensor from texture`);this.gpuTextureData=y.texture,this.downloader=y.download,this.disposer=y.dispose;break}case"gpu-buffer":{if(A!=="float32"&&A!=="float16"&&A!=="int32"&&A!=="int64"&&A!=="uint32"&&A!=="uint8"&&A!=="bool")throw new TypeError(`unsupported type "${A}" to create tensor from gpu buffer`);this.gpuBufferData=y.gpuBuffer,this.downloader=y.download,this.disposer=y.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let Y,B;if(typeof y=="string")if(A=y,B=E,y==="string"){if(!Array.isArray(T))throw new TypeError("A string tensor's data must be a string array.");Y=T}else{const F=l.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(y);if(F===void 0)throw new TypeError(`Unsupported tensor type: ${y}.`);if(Array.isArray(T)){if(y==="float16"&&F===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");y==="uint64"||y==="int64"?Y=F.from(T,BigInt):Y=F.from(T)}else if(T instanceof F)Y=T;else throw new TypeError(`A ${A} tensor's data must be type of ${F}`)}else if(B=T,Array.isArray(y)){if(y.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const F=typeof y[0];if(F==="string")A="string",Y=y;else if(F==="boolean")A="bool",Y=Uint8Array.from(y);else throw new TypeError(`Invalid element type of data array: ${F}.`)}else{const F=l.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(y.constructor);if(F===void 0)throw new TypeError(`Unsupported type for tensor data: ${y.constructor}.`);A=F,Y=y}if(B===void 0)B=[Y.length];else if(!Array.isArray(B))throw new TypeError("A tensor's dims must be a number array");H=B,this.cpuData=Y,this.dataLocation="cpu"}const W=(0,p.calculateSize)(H);if(this.cpuData&&W!==this.cpuData.length)throw new Error(`Tensor's size(${W}) does not match data length(${this.cpuData.length}).`);this.type=A,this.dims=H,this.size=W}static async fromImage(y,T){return(0,a.tensorFromImage)(y,T)}static fromTexture(y,T){return(0,a.tensorFromTexture)(y,T)}static fromGpuBuffer(y,T){return(0,a.tensorFromGpuBuffer)(y,T)}static fromPinnedBuffer(y,T,E){return(0,a.tensorFromPinnedBuffer)(y,T,E)}toDataURL(y){return(0,o.tensorToDataURL)(this,y)}toImageData(y){return(0,o.tensorToImageData)(this,y)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(y){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const T=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=T,y&&this.disposer&&(this.disposer(),this.disposer=void 0),T}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(y){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return(0,p.tensorReshape)(this,y)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":(e,t,r)=>{r.r(t),r.d(t,{calculateSize:()=>a,tensorReshape:()=>l});var o=r("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const a=p=>{let w=1;for(let _=0;_<p.length;_++){const y=p[_];if(typeof y!="number"||!Number.isSafeInteger(y))throw new TypeError(`dims[${_}] must be an integer, got: ${y}`);if(y<0)throw new RangeError(`dims[${_}] must be a non-negative integer, got: ${y}`);w*=y}return w},l=(p,w)=>{switch(p.location){case"cpu":return new o.Tensor(p.type,p.data,w);case"cpu-pinned":return new o.Tensor({location:"cpu-pinned",data:p.data,type:p.type,dims:w});case"texture":return new o.Tensor({location:"texture",texture:p.texture,type:p.type,dims:w});case"gpu-buffer":return new o.Tensor({location:"gpu-buffer",gpuBuffer:p.gpuBuffer,type:p.type,dims:w});default:throw new Error(`tensorReshape: tensor location ${p.location} is not supported`)}}},"./node_modules/onnxruntime-common/dist/esm/tensor.js":(e,t,r)=>{r.r(t),r.d(t,{Tensor:()=>a});var o=r("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const a=o.Tensor},"./node_modules/onnxruntime-common/dist/esm/trace.js":(e,t,r)=>{r.r(t),r.d(t,{TRACE:()=>a,TRACE_FUNC_BEGIN:()=>p,TRACE_FUNC_END:()=>w});var o=r("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const a=(_,y)=>{(typeof o.env.trace>"u"?!o.env.wasm.trace:!o.env.trace)||console.timeStamp(`${_}::ORT::${y}`)},l=(_,y)=>{var A;const T=((A=new Error().stack)==null?void 0:A.split(/\r\n|\r|\n/g))||[];let E=!1;for(let H=0;H<T.length;H++){if(E&&!T[H].includes("TRACE_FUNC")){let W=`FUNC_${_}::${T[H].trim().split(" ")[1]}`;y&&(W+=`::${y}`),a("CPU",W);return}T[H].includes("TRACE_FUNC")&&(E=!0)}},p=_=>{(typeof o.env.trace>"u"?!o.env.wasm.trace:!o.env.trace)||l("BEGIN",_)},w=_=>{(typeof o.env.trace>"u"?!o.env.wasm.trace:!o.env.trace)||l("END",_)}},"./node_modules/onnxruntime-common/dist/esm/training-session-impl.js":(e,t,r)=>{r.r(t),r.d(t,{TrainingSession:()=>p});var o=r("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),a=r("./node_modules/onnxruntime-common/dist/esm/tensor.js");const l="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";class p{constructor(_,y,T){this.handler=_,this.hasOptimizerModel=y,this.hasEvalModel=T}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(_,y){const T=_.evalModel||"",E=_.optimizerModel||"",A=y||{},[H,W]=await(0,o.resolveBackendAndExecutionProviders)(A);if(H.createTrainingSessionHandler){const Y=await H.createTrainingSessionHandler(_.checkpointState,_.trainModel,T,E,W);return new p(Y,!!_.optimizerModel,!!_.evalModel)}else throw new Error(l)}typeNarrowingForRunStep(_,y,T,E,A){const H={};let W={};if(typeof T!="object"||T===null||T instanceof a.Tensor||Array.isArray(T))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Y=!0;if(typeof E=="object"){if(E===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(E instanceof a.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(E)){if(E.length===0)throw new TypeError("'fetches' cannot be an empty array.");Y=!1;for(const B of E){if(typeof B!="string")throw new TypeError("'fetches' must be a string array or an object.");if(y.indexOf(B)===-1)throw new RangeError(`'fetches' contains invalid output name: ${B}.`);H[B]=null}if(typeof A=="object"&&A!==null)W=A;else if(typeof A<"u")throw new TypeError("'options' must be an object.")}else{let B=!1;const F=Object.getOwnPropertyNames(E);for(const O of y)if(F.indexOf(O)!==-1){const P=E[O];(P===null||P instanceof a.Tensor)&&(B=!0,Y=!1,H[O]=P)}if(B){if(typeof A=="object"&&A!==null)W=A;else if(typeof A<"u")throw new TypeError("'options' must be an object.")}else W=E}}else if(typeof E<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const B of _)if(typeof T[B]>"u")throw new Error(`input '${B}' is missing in 'feeds'.`);if(Y)for(const B of y)H[B]=null;return[H,W]}convertHandlerReturnTypeToMapOfTensors(_){const y={};for(const T in _)if(Object.hasOwnProperty.call(_,T)){const E=_[T];E instanceof a.Tensor?y[T]=E:y[T]=new a.Tensor(E.type,E.data,E.dims)}return y}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(_,y,T){const[E,A]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,_,y,T),H=await this.handler.runTrainStep(_,E,A);return this.convertHandlerReturnTypeToMapOfTensors(H)}async runOptimizerStep(_){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(_||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(_,y,T){if(this.hasEvalModel){const[E,A]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,_,y,T),H=await this.handler.runEvalStep(_,E,A);return this.convertHandlerReturnTypeToMapOfTensors(H)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(_=!0){return this.handler.getParametersSize(_)}async loadParametersBuffer(_,y=!0){const T=await this.getParametersSize(y);if(_.length!==4*T)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(_,y)}async getContiguousParameters(_=!0){return this.handler.getContiguousParameters(_)}async release(){return this.handler.dispose()}}},"./node_modules/onnxruntime-common/dist/esm/training-session.js":(e,t,r)=>{r.r(t),r.d(t,{TrainingSession:()=>a});var o=r("./node_modules/onnxruntime-common/dist/esm/training-session-impl.js");const a=o.TrainingSession},"./node_modules/onnxruntime-common/dist/esm/version.js":(e,t,r)=>{r.r(t),r.d(t,{version:()=>o});const o="1.19.2"},"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs":(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>Ct,TRACE:()=>Ye,TRACE_FUNC_BEGIN:()=>We,TRACE_FUNC_END:()=>Ge,Tensor:()=>ce,TrainingSession:()=>Tt,default:()=>J2,env:()=>L,registerBackend:()=>W});/*!
 * ONNX Runtime Web v1.21.0-dev.20241024-d9ca84ef96
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var o=Object.defineProperty,a=Object.getOwnPropertyDescriptor,l=Object.getOwnPropertyNames,p=Object.prototype.hasOwnProperty,w=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(i,s)=>(typeof require<"u"?require:i)[s]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')}),_=(n,i)=>()=>(n&&(i=n(n=0)),i),y=(n,i)=>{for(var s in i)o(n,s,{get:i[s],enumerable:!0})},T=(n,i,s,u)=>{if(i&&typeof i=="object"||typeof i=="function")for(let d of l(i))!p.call(n,d)&&d!==s&&o(n,d,{get:()=>i[d],enumerable:!(u=a(i,d))||u.enumerable});return n},E=n=>T(o({},"__esModule",{value:!0}),n),A,H,W,Y,B,F=_(()=>{A=new Map,H=[],W=(n,i,s)=>{if(i&&typeof i.init=="function"&&typeof i.createInferenceSessionHandler=="function"){let u=A.get(n);if(u===void 0)A.set(n,{backend:i,priority:s});else{if(u.priority>s)return;if(u.priority===s&&u.backend!==i)throw new Error(`cannot register backend "${n}" using priority ${s}`)}if(s>=0){let d=H.indexOf(n);d!==-1&&H.splice(d,1);for(let f=0;f<H.length;f++)if(A.get(H[f]).priority<=s){H.splice(f,0,n);return}H.push(n)}return}throw new TypeError("not a valid backend")},Y=async n=>{let i=A.get(n);if(!i)return"backend not found.";if(i.initialized)return i.backend;if(i.aborted)return i.error;{let s=!!i.initPromise;try{return s||(i.initPromise=i.backend.init(n)),await i.initPromise,i.initialized=!0,i.backend}catch(u){return s||(i.error=`${u}`,i.aborted=!0),i.error}finally{delete i.initPromise}}},B=async n=>{let i=n.executionProviders||[],s=i.map(v=>typeof v=="string"?v:v.name),u=s.length===0?H:s,d,f=[],c=new Set;for(let v of u){let b=await Y(v);typeof b=="string"?f.push({name:v,err:b}):(d||(d=b),d===b&&c.add(v))}if(!d)throw new Error(`no available backend found. ERR: ${f.map(v=>`[${v.name}] ${v.err}`).join(", ")}`);for(let{name:v,err:b}of f)s.includes(v)&&console.warn(`removing requested execution provider "${v}" from session options because it is not available: ${b}`);let g=i.filter(v=>c.has(typeof v=="string"?v:v.name));return[d,new Proxy(n,{get:(v,b)=>b==="executionProviders"?g:Reflect.get(v,b)})]}}),O=_(()=>{F()}),P,j=_(()=>{P="1.20.0-dev.20241016-2b8fc5529b"}),V,z,q=_(()=>{j(),V="warning",z={wasm:{},webgl:{},webgpu:{},versions:{common:P},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);V=n}},get logLevel(){return V}},Object.defineProperty(z,"logLevel",{enumerable:!0})}),L,pe=_(()=>{q(),L=z}),fe,xe,$e=_(()=>{fe=(n,i)=>{let s=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);s.width=n.dims[3],s.height=n.dims[2];let u=s.getContext("2d");if(u!=null){let d,f;(i==null?void 0:i.tensorLayout)!==void 0&&i.tensorLayout==="NHWC"?(d=n.dims[2],f=n.dims[3]):(d=n.dims[3],f=n.dims[2]);let c=(i==null?void 0:i.format)!==void 0?i.format:"RGB",g=i==null?void 0:i.norm,v,b;g===void 0||g.mean===void 0?v=[255,255,255,255]:typeof g.mean=="number"?v=[g.mean,g.mean,g.mean,g.mean]:(v=[g.mean[0],g.mean[1],g.mean[2],0],g.mean[3]!==void 0&&(v[3]=g.mean[3])),g===void 0||g.bias===void 0?b=[0,0,0,0]:typeof g.bias=="number"?b=[g.bias,g.bias,g.bias,g.bias]:(b=[g.bias[0],g.bias[1],g.bias[2],0],g.bias[3]!==void 0&&(b[3]=g.bias[3]));let $=f*d,k=0,m=$,K=$*2,G=-1;c==="RGBA"?(k=0,m=$,K=$*2,G=$*3):c==="RGB"?(k=0,m=$,K=$*2):c==="RBG"&&(k=0,K=$,m=$*2);for(let X=0;X<f;X++)for(let ne=0;ne<d;ne++){let ie=(n.data[k++]-b[0])*v[0],ee=(n.data[m++]-b[1])*v[1],de=(n.data[K++]-b[2])*v[2],he=G===-1?255:(n.data[G++]-b[3])*v[3];u.fillStyle="rgba("+ie+","+ee+","+de+","+he+")",u.fillRect(ne,X,1,1)}if("toDataURL"in s)return s.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},xe=(n,i)=>{let s=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),u;if(s!=null){let d,f,c;(i==null?void 0:i.tensorLayout)!==void 0&&i.tensorLayout==="NHWC"?(d=n.dims[2],f=n.dims[1],c=n.dims[3]):(d=n.dims[3],f=n.dims[2],c=n.dims[1]);let g=i!==void 0&&i.format!==void 0?i.format:"RGB",v=i==null?void 0:i.norm,b,$;v===void 0||v.mean===void 0?b=[255,255,255,255]:typeof v.mean=="number"?b=[v.mean,v.mean,v.mean,v.mean]:(b=[v.mean[0],v.mean[1],v.mean[2],255],v.mean[3]!==void 0&&(b[3]=v.mean[3])),v===void 0||v.bias===void 0?$=[0,0,0,0]:typeof v.bias=="number"?$=[v.bias,v.bias,v.bias,v.bias]:($=[v.bias[0],v.bias[1],v.bias[2],0],v.bias[3]!==void 0&&($[3]=v.bias[3]));let k=f*d;if(i!==void 0&&(i.format!==void 0&&c===4&&i.format!=="RGBA"||c===3&&i.format!=="RGB"&&i.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let m=4,K=0,G=1,X=2,ne=3,ie=0,ee=k,de=k*2,he=-1;g==="RGBA"?(ie=0,ee=k,de=k*2,he=k*3):g==="RGB"?(ie=0,ee=k,de=k*2):g==="RBG"&&(ie=0,de=k,ee=k*2),u=s.createImageData(d,f);for(let _e=0;_e<f*d;K+=m,G+=m,X+=m,ne+=m,_e++)u.data[K]=(n.data[ie++]-$[0])*b[0],u.data[G]=(n.data[ee++]-$[1])*b[1],u.data[X]=(n.data[de++]-$[2])*b[2],u.data[ne]=he===-1?255:(n.data[he++]-$[3])*b[3]}else throw new Error("Can not access image data");return u}}),Ce,tt,Je,it,be,Q,ae=_(()=>{nt(),Ce=(n,i)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(i.height===void 0||i.width===void 0)throw new Error("Image height and width must be defined");if(i.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:s,width:u}=i,d=i.norm??{mean:255,bias:0},f,c;typeof d.mean=="number"?f=[d.mean,d.mean,d.mean,d.mean]:f=[d.mean[0],d.mean[1],d.mean[2],d.mean[3]??255],typeof d.bias=="number"?c=[d.bias,d.bias,d.bias,d.bias]:c=[d.bias[0],d.bias[1],d.bias[2],d.bias[3]??0];let g=i.format!==void 0?i.format:"RGBA",v=i.tensorFormat!==void 0&&i.tensorFormat!==void 0?i.tensorFormat:"RGB",b=s*u,$=v==="RGBA"?new Float32Array(b*4):new Float32Array(b*3),k=4,m=0,K=1,G=2,X=3,ne=0,ie=b,ee=b*2,de=-1;g==="RGB"&&(k=3,m=0,K=1,G=2,X=-1),v==="RGBA"?de=b*3:v==="RBG"?(ne=0,ee=b,ie=b*2):v==="BGR"&&(ee=0,ie=b,ne=b*2);for(let he=0;he<b;he++,m+=k,G+=k,K+=k,X+=k)$[ne++]=(n[m]+c[0])/f[0],$[ie++]=(n[K]+c[1])/f[1],$[ee++]=(n[G]+c[2])/f[2],de!==-1&&X!==-1&&($[de++]=(n[X]+c[3])/f[3]);return v==="RGBA"?new vt("float32",$,[1,4,s,u]):new vt("float32",$,[1,3,s,u])},tt=async(n,i)=>{let s=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,u=typeof ImageData<"u"&&n instanceof ImageData,d=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,f=typeof n=="string",c,g=i??{},v=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},b=$=>typeof HTMLCanvasElement<"u"&&$ instanceof HTMLCanvasElement||$ instanceof OffscreenCanvas?$.getContext("2d"):null;if(s){let $=v();$.width=n.width,$.height=n.height;let k=b($);if(k!=null){let m=n.height,K=n.width;if(i!==void 0&&i.resizedHeight!==void 0&&i.resizedWidth!==void 0&&(m=i.resizedHeight,K=i.resizedWidth),i!==void 0){if(g=i,i.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");g.tensorFormat="RGBA",g.height=m,g.width=K}else g.tensorFormat="RGBA",g.height=m,g.width=K;k.drawImage(n,0,0),c=k.getImageData(0,0,K,m).data}else throw new Error("Can not access image data")}else if(u){let $,k;if(i!==void 0&&i.resizedWidth!==void 0&&i.resizedHeight!==void 0?($=i.resizedHeight,k=i.resizedWidth):($=n.height,k=n.width),i!==void 0&&(g=i),g.format="RGBA",g.height=$,g.width=k,i!==void 0){let m=v();m.width=k,m.height=$;let K=b(m);if(K!=null)K.putImageData(n,0,0),c=K.getImageData(0,0,k,$).data;else throw new Error("Can not access image data")}else c=n.data}else if(d){if(i===void 0)throw new Error("Please provide image config with format for Imagebitmap");let $=v();$.width=n.width,$.height=n.height;let k=b($);if(k!=null){let m=n.height,K=n.width;return k.drawImage(n,0,0,K,m),c=k.getImageData(0,0,K,m).data,g.height=m,g.width=K,Ce(c,g)}else throw new Error("Can not access image data")}else{if(f)return new Promise(($,k)=>{let m=v(),K=b(m);if(!n||!K)return k();let G=new Image;G.crossOrigin="Anonymous",G.src=n,G.onload=()=>{m.width=G.width,m.height=G.height,K.drawImage(G,0,0,m.width,m.height);let X=K.getImageData(0,0,m.width,m.height);g.height=m.height,g.width=m.width,$(Ce(X.data,g))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return Ce(c,g);throw new Error("Input data provided is not supported - aborted tensor creation")},Je=(n,i)=>{let{width:s,height:u,download:d,dispose:f}=i,c=[1,u,s,4];return new vt({location:"texture",type:"float32",texture:n,dims:c,download:d,dispose:f})},it=(n,i)=>{let{dataType:s,dims:u,download:d,dispose:f}=i;return new vt({location:"gpu-buffer",type:s??"float32",gpuBuffer:n,dims:u,download:d,dispose:f})},be=(n,i)=>{let{dataType:s,dims:u,download:d,dispose:f}=i;return new vt({location:"ml-tensor",type:s??"float32",mlTensor:n,dims:u,download:d,dispose:f})},Q=(n,i,s)=>new vt({location:"cpu-pinned",type:n,data:i,dims:s??[i.length]})}),ye,Pe,Ze,me,Qe=_(()=>{ye=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Pe=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Ze=!1,me=()=>{if(!Ze){Ze=!0;let n=typeof BigInt64Array<"u"&&BigInt64Array.from,i=typeof BigUint64Array<"u"&&BigUint64Array.from,s=typeof Float16Array<"u"&&Float16Array.from;n&&(ye.set("int64",BigInt64Array),Pe.set(BigInt64Array,"int64")),i&&(ye.set("uint64",BigUint64Array),Pe.set(BigUint64Array,"uint64")),s?(ye.set("float16",Float16Array),Pe.set(Float16Array,"float16")):ye.set("float16",Uint16Array)}}}),et,Ie,rt=_(()=>{nt(),et=n=>{let i=1;for(let s=0;s<n.length;s++){let u=n[s];if(typeof u!="number"||!Number.isSafeInteger(u))throw new TypeError(`dims[${s}] must be an integer, got: ${u}`);if(u<0)throw new RangeError(`dims[${s}] must be a non-negative integer, got: ${u}`);i*=u}return i},Ie=(n,i)=>{switch(n.location){case"cpu":return new vt(n.type,n.data,i);case"cpu-pinned":return new vt({location:"cpu-pinned",data:n.data,type:n.type,dims:i});case"texture":return new vt({location:"texture",texture:n.texture,type:n.type,dims:i});case"gpu-buffer":return new vt({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:i});case"ml-tensor":return new vt({location:"ml-tensor",mlTensor:n.mlTensor,type:n.type,dims:i});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}}}),vt,nt=_(()=>{$e(),ae(),Qe(),rt(),vt=class{constructor(n,i,s){me();let u,d;if(typeof n=="object"&&"location"in n)switch(this.dataLocation=n.location,u=n.type,d=n.dims,n.location){case"cpu-pinned":{let c=ye.get(u);if(!c)throw new TypeError(`unsupported type "${u}" to create tensor from pinned buffer`);if(!(n.data instanceof c))throw new TypeError(`buffer should be of type ${c.name}`);this.cpuData=n.data;break}case"texture":{if(u!=="float32")throw new TypeError(`unsupported type "${u}" to create tensor from texture`);this.gpuTextureData=n.texture,this.downloader=n.download,this.disposer=n.dispose;break}case"gpu-buffer":{if(u!=="float32"&&u!=="float16"&&u!=="int32"&&u!=="int64"&&u!=="uint32"&&u!=="uint8"&&u!=="bool"&&u!=="uint4"&&u!=="int4")throw new TypeError(`unsupported type "${u}" to create tensor from gpu buffer`);this.gpuBufferData=n.gpuBuffer,this.downloader=n.download,this.disposer=n.dispose;break}case"ml-tensor":{if(u!=="float32"&&u!=="float16"&&u!=="int32"&&u!=="int64"&&u!=="uint32"&&u!=="uint64"&&u!=="int8"&&u!=="uint8"&&u!=="bool")throw new TypeError(`unsupported type "${u}" to create tensor from MLTensor`);this.mlTensorData=n.mlTensor,this.downloader=n.download,this.disposer=n.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let c,g;if(typeof n=="string")if(u=n,g=s,n==="string"){if(!Array.isArray(i))throw new TypeError("A string tensor's data must be a string array.");c=i}else{let v=ye.get(n);if(v===void 0)throw new TypeError(`Unsupported tensor type: ${n}.`);if(Array.isArray(i)){if(n==="float16"&&v===Uint16Array||n==="uint4"||n==="int4")throw new TypeError(`Creating a ${n} tensor from number array is not supported. Please use ${v.name} as data.`);n==="uint64"||n==="int64"?c=v.from(i,BigInt):c=v.from(i)}else if(i instanceof v)c=i;else if(i instanceof Uint8ClampedArray)if(n==="uint8")c=Uint8Array.from(i);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${u} tensor's data must be type of ${v}`)}else if(g=i,Array.isArray(n)){if(n.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let v=typeof n[0];if(v==="string")u="string",c=n;else if(v==="boolean")u="bool",c=Uint8Array.from(n);else throw new TypeError(`Invalid element type of data array: ${v}.`)}else if(n instanceof Uint8ClampedArray)u="uint8",c=Uint8Array.from(n);else{let v=Pe.get(n.constructor);if(v===void 0)throw new TypeError(`Unsupported type for tensor data: ${n.constructor}.`);u=v,c=n}if(g===void 0)g=[c.length];else if(!Array.isArray(g))throw new TypeError("A tensor's dims must be a number array");d=g,this.cpuData=c,this.dataLocation="cpu"}let f=et(d);if(this.cpuData&&f!==this.cpuData.length&&!((u==="uint4"||u==="int4")&&Math.ceil(f/2)===this.cpuData.length))throw new Error(`Tensor's size(${f}) does not match data length(${this.cpuData.length}).`);this.type=u,this.dims=d,this.size=f}static async fromImage(n,i){return tt(n,i)}static fromTexture(n,i){return Je(n,i)}static fromGpuBuffer(n,i){return it(n,i)}static fromMLTensor(n,i){return be(n,i)}static fromPinnedBuffer(n,i,s){return Q(n,i,s)}toDataURL(n){return fe(this,n)}toImageData(n){return xe(this,n)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(n){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let i=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=i,n&&this.disposer&&(this.disposer(),this.disposer=void 0),i}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(n){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Ie(this,n)}}}),ce,ze=_(()=>{nt(),ce=vt}),Ye,lt,We,Ge,ht=_(()=>{q(),Ye=(n,i)=>{(typeof z.trace>"u"?!z.wasm.trace:!z.trace)||console.timeStamp(`${n}::ORT::${i}`)},lt=(n,i)=>{var d;let s=((d=new Error().stack)==null?void 0:d.split(/\r\n|\r|\n/g))||[],u=!1;for(let f=0;f<s.length;f++){if(u&&!s[f].includes("TRACE_FUNC")){let c=`FUNC_${n}::${s[f].trim().split(" ")[1]}`;i&&(c+=`::${i}`),Ye("CPU",c);return}s[f].includes("TRACE_FUNC")&&(u=!0)}},We=n=>{(typeof z.trace>"u"?!z.wasm.trace:!z.trace)||lt("BEGIN",n)},Ge=n=>{(typeof z.trace>"u"?!z.wasm.trace:!z.trace)||lt("END",n)}}),bt,Ot=_(()=>{F(),ze(),ht(),bt=class O2{constructor(i){this.handler=i}async run(i,s,u){We();let d={},f={};if(typeof i!="object"||i===null||i instanceof ce||Array.isArray(i))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof ce)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let b of s){if(typeof b!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(b)===-1)throw new RangeError(`'fetches' contains invalid output name: ${b}.`);d[b]=null}if(typeof u=="object"&&u!==null)f=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else{let b=!1,$=Object.getOwnPropertyNames(s);for(let k of this.outputNames)if($.indexOf(k)!==-1){let m=s[k];(m===null||m instanceof ce)&&(b=!0,c=!1,d[k]=m)}if(b){if(typeof u=="object"&&u!==null)f=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else f=s}}else if(typeof s<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let b of this.inputNames)if(typeof i[b]>"u")throw new Error(`input '${b}' is missing in 'feeds'.`);if(c)for(let b of this.outputNames)d[b]=null;let g=await this.handler.run(i,d,f),v={};for(let b in g)if(Object.hasOwnProperty.call(g,b)){let $=g[b];$ instanceof ce?v[b]=$:v[b]=new ce($.type,$.data,$.dims)}return Ge(),v}async release(){return this.handler.dispose()}static async create(i,s,u,d){We();let f,c={};if(typeof i=="string"){if(f=i,typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(i instanceof Uint8Array){if(f=i,typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer){let $=i,k=0,m=i.byteLength;if(typeof s=="object"&&s!==null)c=s;else if(typeof s=="number"){if(k=s,!Number.isSafeInteger(k))throw new RangeError("'byteOffset' must be an integer.");if(k<0||k>=$.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${$.byteLength}).`);if(m=i.byteLength-k,typeof u=="number"){if(m=u,!Number.isSafeInteger(m))throw new RangeError("'byteLength' must be an integer.");if(m<=0||k+m>$.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${$.byteLength-k}].`);if(typeof d=="object"&&d!==null)c=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof u<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof s<"u")throw new TypeError("'options' must be an object.");f=new Uint8Array($,k,m)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[g,v]=await B(c),b=await g.createInferenceSessionHandler(f,v);return Ge(),new O2(b)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Ct,U=_(()=>{Ot(),Ct=bt}),se=_(()=>{}),J=_(()=>{}),ue=_(()=>{}),Me=_(()=>{}),dt,at,Wt=_(()=>{F(),ze(),dt="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",at=class D2{constructor(i,s,u){this.handler=i,this.hasOptimizerModel=s,this.hasEvalModel=u}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(i,s){let u=i.evalModel||"",d=i.optimizerModel||"",f=s||{},[c,g]=await B(f);if(c.createTrainingSessionHandler){let v=await c.createTrainingSessionHandler(i.checkpointState,i.trainModel,u,d,g);return new D2(v,!!i.optimizerModel,!!i.evalModel)}else throw new Error(dt)}typeNarrowingForRunStep(i,s,u,d,f){let c={},g={};if(typeof u!="object"||u===null||u instanceof ce||Array.isArray(u))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let v=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof ce)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");v=!1;for(let b of d){if(typeof b!="string")throw new TypeError("'fetches' must be a string array or an object.");if(s.indexOf(b)===-1)throw new RangeError(`'fetches' contains invalid output name: ${b}.`);c[b]=null}if(typeof f=="object"&&f!==null)g=f;else if(typeof f<"u")throw new TypeError("'options' must be an object.")}else{let b=!1,$=Object.getOwnPropertyNames(d);for(let k of s)if($.indexOf(k)!==-1){let m=d[k];(m===null||m instanceof ce)&&(b=!0,v=!1,c[k]=m)}if(b){if(typeof f=="object"&&f!==null)g=f;else if(typeof f<"u")throw new TypeError("'options' must be an object.")}else g=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let b of i)if(typeof u[b]>"u")throw new Error(`input '${b}' is missing in 'feeds'.`);if(v)for(let b of s)c[b]=null;return[c,g]}convertHandlerReturnTypeToMapOfTensors(i){let s={};for(let u in i)if(Object.hasOwnProperty.call(i,u)){let d=i[u];d instanceof ce?s[u]=d:s[u]=new ce(d.type,d.data,d.dims)}return s}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(i,s,u){let[d,f]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,i,s,u),c=await this.handler.runTrainStep(i,d,f);return this.convertHandlerReturnTypeToMapOfTensors(c)}async runOptimizerStep(i){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(i||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(i,s,u){if(this.hasEvalModel){let[d,f]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,i,s,u),c=await this.handler.runEvalStep(i,d,f);return this.convertHandlerReturnTypeToMapOfTensors(c)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(i=!0){return this.handler.getParametersSize(i)}async loadParametersBuffer(i,s=!0){let u=await this.getParametersSize(s);if(i.length!==4*u)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(i,s)}async getContiguousParameters(i=!0){return this.handler.getContiguousParameters(i)}async release(){return this.handler.dispose()}}}),Tt,St=_(()=>{Wt(),Tt=at}),Nt={};y(Nt,{InferenceSession:()=>Ct,TRACE:()=>Ye,TRACE_FUNC_BEGIN:()=>We,TRACE_FUNC_END:()=>Ge,Tensor:()=>ce,TrainingSession:()=>Tt,env:()=>L,registerBackend:()=>W});var Dt=_(()=>{O(),pe(),U(),ze(),se(),J(),ht(),ue(),Me(),St()}),gn=_(()=>{}),An={};y(An,{default:()=>mr});var pr,Xn,mr,Hr=_(()=>{var n;Cv(),Dn(),Rt(),pr="ort-wasm-proxy-worker",Xn=((n=globalThis.self)==null?void 0:n.name)===pr,Xn&&(self.onmessage=i=>{let{type:s,in:u}=i.data;try{switch(s){case"init-wasm":Qn(u.wasm).then(()=>{p_(u).then(()=>{postMessage({type:s})},d=>{postMessage({type:s,err:d})})},d=>{postMessage({type:s,err:d})});break;case"init-ep":{let{epName:d,env:f}=u;f_(f,d).then(()=>{postMessage({type:s})},c=>{postMessage({type:s,err:c})});break}case"copy-from":{let{buffer:d}=u,f=om(d);postMessage({type:s,out:f});break}case"create":{let{model:d,options:f}=u;h_(d,f).then(c=>{postMessage({type:s,out:c})},c=>{postMessage({type:s,err:c})});break}case"release":m_(u),postMessage({type:s});break;case"run":{let{sessionId:d,inputIndices:f,inputs:c,outputIndices:g,options:v}=u;__(d,f,c,g,new Array(g.length).fill(null),v).then(b=>{b.some($=>$[3]!=="cpu")?postMessage({type:s,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:s,out:b},w_([...c,...b]))},b=>{postMessage({type:s,err:b})});break}case"end-profiling":y_(u),postMessage({type:s});break;default:}}catch(d){postMessage({type:s,err:d})}}),mr=Xn?null:i=>new Worker(i??Ve,{type:"module",name:pr})}),ft={};y(ft,{default:()=>Re});var oe,Se,Re,Oe=_(()=>{var n;Se=(oe=import.meta.url,async function(i={}){function s(){return wn.buffer!=tn.buffer&&zr(),tn}function u(){return wn.buffer!=tn.buffer&&zr(),Pn}function d(){return wn.buffer!=tn.buffer&&zr(),Ke}function f(){return wn.buffer!=tn.buffer&&zr(),kt}function c(){return wn.buffer!=tn.buffer&&zr(),ln}function g(){return wn.buffer!=tn.buffer&&zr(),Gn}function v(){return wn.buffer!=tn.buffer&&zr(),xr}function b(){return wn.buffer!=tn.buffer&&zr(),lm}var $,k,m=Object.assign({},i),K=new Promise((h,x)=>{$=h,k=x}),G=typeof window=="object",X=typeof importScripts=="function",ne=X&&self.name=="em-pthread";m.mountExternalData=(h,x)=>{h.startsWith("./")&&(h=h.substring(2)),(m.Eb||(m.Eb=new Map)).set(h,x)},m.unmountExternalData=()=>{delete m.Eb};var ie=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let ee=()=>{let h=(I,N,Z)=>(...ge)=>{let Xe=ko,pt=N==null?void 0:N();ge=I(...ge);let zt=N==null?void 0:N();return pt!==zt&&(I=zt,Z(pt),N=Z=null),ko!=Xe?new Promise((Vt,rn)=>{B_={resolve:Vt,reject:rn}}):ge},x=I=>async(...N)=>{var Z;try{if(m.Fb)throw Error("Session already started");let ge=m.Fb={fc:N[0],errors:[]},Xe=await I(...N);if(m.Fb!==ge)throw Error("Session mismatch");(Z=m.Gb)==null||Z.flush();let pt=ge.errors;if(0<pt.length){let zt=await Promise.all(pt);if(zt=zt.filter(Vt=>Vt),0<zt.length)throw Error(zt.join(`
`))}return Xe}finally{m.Fb=null}};m._OrtCreateSession=h(m._OrtCreateSession,()=>m._OrtCreateSession,I=>m._OrtCreateSession=I),m._OrtRun=x(h(m._OrtRun,()=>m._OrtRun,I=>m._OrtRun=I)),m._OrtRunWithBinding=x(h(m._OrtRunWithBinding,()=>m._OrtRunWithBinding,I=>m._OrtRunWithBinding=I)),m._OrtBindInput=h(m._OrtBindInput,()=>m._OrtBindInput,I=>m._OrtBindInput=I),ee=void 0};m.jsepInit=(h,x)=>{if(ee==null||ee(),h==="webgpu"){[m.Gb,m.Ub,m.Yb,m.Nb,m.Xb,m.jb,m.Zb,m.bc,m.Vb,m.Wb,m.$b]=x;let I=m.Gb;m.jsepRegisterBuffer=(N,Z,ge,Xe)=>I.registerBuffer(N,Z,ge,Xe),m.jsepGetBuffer=N=>I.getBuffer(N),m.jsepCreateDownloader=(N,Z,ge)=>I.createDownloader(N,Z,ge),m.jsepOnCreateSession=N=>{I.onCreateSession(N)},m.jsepOnReleaseSession=N=>{I.onReleaseSession(N)},m.jsepOnRunStart=N=>I.onRunStart(N),m.cc=(N,Z)=>{I.upload(N,Z)}}else if(h==="webnn"){[m.Gb,m.ac,m.Ob,m.jsepEnsureTensor,m.dc,m.jsepDownloadTensor]=x,m.jsepReleaseTensorId=m.Ob;let I=m.Gb;m.jsepOnRunStart=N=>I.onRunStart(N),m.jsepRegisterMLContext=(N,Z)=>{I.registerMLContext(N,Z)},m.jsepOnReleaseSession=N=>{I.onReleaseSession(N)},m.jsepCreateMLTensorDownloader=(N,Z)=>I.createMLTensorDownloader(N,Z),m.jsepRegisterMLTensor=(N,Z,ge)=>I.registerMLTensor(N,Z,ge),m.qc=(N,Z,ge,Xe,pt)=>I.registerMLConstant(N,Z,ge,Xe,pt,m.Eb)}};var de,he,_e=Object.assign({},m),Fe="./this.program",De=(h,x)=>{throw x},st="";(G||X)&&(X?st=self.location.href:typeof document<"u"&&document.currentScript&&(st=document.currentScript.src),oe&&(st=oe),st=st.startsWith("blob:")?"":st.substr(0,st.replace(/[?#].*/,"").lastIndexOf("/")+1),X&&(he=h=>{var x=new XMLHttpRequest;return x.open("GET",h,!1),x.responseType="arraybuffer",x.send(null),new Uint8Array(x.response)}),de=(h,x,I)=>{var N=new XMLHttpRequest;N.open("GET",h,!0),N.responseType="arraybuffer",N.onload=()=>{N.status==200||N.status==0&&N.response?x(N.response):I()},N.onerror=I,N.send(null)});var Lt,jt=console.log.bind(console),pn=console.error.bind(console),un=jt,Jt=pn;if(Object.assign(m,_e),_e=null,ne){let h=function(x){try{var I=x.data,N=I.cmd;if(N==="load"){let Z=[];self.onmessage=ge=>Z.push(ge),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let ge of Z)h(ge);self.onmessage=h};for(let ge of I.handlers)m[ge]&&!m[ge].proxy||(m[ge]=(...Xe)=>{postMessage({Mb:"callHandler",oc:ge,args:Xe})},ge=="print"&&(un=m[ge]),ge=="printErr"&&(Jt=m[ge]));wn=I.wasmMemory,zr(),In(I.wasmModule)}else if(N==="run"){V_(I.pthread_ptr,0,0,1,0,0),z_(I.pthread_ptr),tS(),Yv(),Yn||(K1(),Yn=!0);try{nS(I.start_routine,I.arg)}catch(Z){if(Z!="unwind")throw Z}}else N==="cancel"?Cu()&&vm(-1):I.target!=="setimmediate"&&(N==="checkMailbox"?Yn&&dm():N&&(Jt(`worker: received unknown command ${N}`),Jt(I)))}catch(Z){throw X1(),Z}};var In,Yn=!1;Jt=function(...x){x=x.join(" "),console.error(x)},self.alert=function(...x){postMessage({Mb:"alert",text:x.join(" "),rc:Cu()})},m.instantiateWasm=(x,I)=>new Promise(N=>{In=Z=>{Z=new WebAssembly.Instance(Z,qv()),I(Z),N()}}),self.onunhandledrejection=x=>{throw x.reason||x},self.onmessage=h}m.wasmBinary&&(Lt=m.wasmBinary);var wn,Bn,Qt,tn,Pn,Ke,kt,ln,Gn,xr,Sr,Cs,lm,ui=!1;function zr(){var h=wn.buffer;m.HEAP8=tn=new Int8Array(h),m.HEAP16=Ke=new Int16Array(h),m.HEAPU8=Pn=new Uint8Array(h),m.HEAPU16=kt=new Uint16Array(h),m.HEAP32=ln=new Int32Array(h),m.HEAPU32=Gn=new Uint32Array(h),m.HEAPF32=xr=new Float32Array(h),m.HEAPF64=lm=new Float64Array(h),m.HEAP64=Sr=new BigInt64Array(h),m.HEAPU64=Cs=new BigUint64Array(h)}if(!ne){if(!((wn=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof ie))throw Jt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");zr()}var xa=[],$r=[],Xr=[],Ni=0,Ps=null;function um(){if(--Ni==0&&Ps){var h=Ps;Ps=null,h()}}function Su(h){throw Jt(h="Aborted("+h+")"),ui=!0,Qt=1,h=new WebAssembly.RuntimeError(h+". Build with -sASSERTIONS for more info."),k(h),h}var T_,jv=h=>h.startsWith("data:application/octet-stream;base64,"),Vv=h=>h.startsWith("file://");function Wv(h){if(h==T_&&Lt)return new Uint8Array(Lt);if(he)return he(h);throw"both async and sync fetching of the wasm failed"}function Gv(h,x,I){return function(N){if(!Lt&&(G||X)){if(typeof fetch=="function"&&!Vv(N))return fetch(N,{credentials:"same-origin"}).then(Z=>{if(!Z.ok)throw`failed to load wasm binary file at '${N}'`;return Z.arrayBuffer()}).catch(()=>Wv(N));if(de)return new Promise((Z,ge)=>{de(N,Xe=>Z(new Uint8Array(Xe)),ge)})}return Promise.resolve().then(()=>Wv(N))}(h).then(N=>WebAssembly.instantiate(N,x)).then(I,N=>{Jt(`failed to asynchronously prepare wasm: ${N}`),Su(N)})}function qv(){return{a:{O:eS,Aa:Z2,b:iS,aa:t1,B:i1,qa:o1,Y:a1,_:l1,ra:u1,oa:c1,ha:d1,na:p1,L:f1,Z:h1,W:m1,pa:g1,X:_1,wa:oS,F:sS,Q:aS,P:uS,E:dS,u:pS,q:fS,G:hS,A:bS,R:MS,ua:xS,ka:TS,U:SS,ba:ES,H:kS,ja:z_,ta:CS,t:PS,x:FS,n:IS,l:DS,c:O_,o:zS,j:BS,w:NS,p:US,g:jS,s:VS,m:WS,e:GS,k:qS,i:HS,h:KS,d:XS,ea:QS,fa:YS,ga:JS,ca:A1,da:F1,T:ZS,f:eE,D:tE,I:nE,M:rE,y:iE,sa:oE,V:sE,v:O1,z:aE,N:lE,S:uE,za:cE,ya:dE,la:L1,ma:R1,$:P_,C:B1,K:N1,ia:U1,J:j1,a:wn,xa:C_,va:G1,r:hE}}}var S_={867364:(h,x,I,N,Z)=>{if(m===void 0||!m.Eb)return 1;if((h=Vr(h>>>0)).startsWith("./")&&(h=h.substring(2)),!(h=m.Eb.get(h)))return 2;if(N>>>=0,(x>>>=0)+(I>>>=0)>h.byteLength)return 3;try{let ge=h.subarray(x,x+I);switch(Z){case 0:u().set(ge,N>>>0);break;case 1:m.cc(N,ge);break;default:return 4}return 0}catch{return 4}},868047:(h,x,I)=>{m.dc(h,u().subarray(x>>>0,x+I>>>0))},868110:()=>m.ac(),868151:h=>{m.Ob(h)},868187:()=>{m.Vb()},868218:()=>{m.Wb()},868247:()=>{m.$b()},868272:h=>m.Ub(h),868305:h=>m.Yb(h),868337:(h,x,I)=>{m.Nb(h,x,I,!0)},868376:(h,x,I)=>{m.Nb(h,x,I)},868409:()=>typeof wasmOffsetConverter<"u",868466:h=>{m.jb("Abs",h,void 0)},868517:h=>{m.jb("Neg",h,void 0)},868568:h=>{m.jb("Floor",h,void 0)},868621:h=>{m.jb("Ceil",h,void 0)},868673:h=>{m.jb("Reciprocal",h,void 0)},868731:h=>{m.jb("Sqrt",h,void 0)},868783:h=>{m.jb("Exp",h,void 0)},868834:h=>{m.jb("Erf",h,void 0)},868885:h=>{m.jb("Sigmoid",h,void 0)},868940:(h,x,I)=>{m.jb("HardSigmoid",h,{alpha:x,beta:I})},869019:h=>{m.jb("Log",h,void 0)},869070:h=>{m.jb("Sin",h,void 0)},869121:h=>{m.jb("Cos",h,void 0)},869172:h=>{m.jb("Tan",h,void 0)},869223:h=>{m.jb("Asin",h,void 0)},869275:h=>{m.jb("Acos",h,void 0)},869327:h=>{m.jb("Atan",h,void 0)},869379:h=>{m.jb("Sinh",h,void 0)},869431:h=>{m.jb("Cosh",h,void 0)},869483:h=>{m.jb("Asinh",h,void 0)},869536:h=>{m.jb("Acosh",h,void 0)},869589:h=>{m.jb("Atanh",h,void 0)},869642:h=>{m.jb("Tanh",h,void 0)},869694:h=>{m.jb("Not",h,void 0)},869745:(h,x,I)=>{m.jb("Clip",h,{min:x,max:I})},869814:h=>{m.jb("Clip",h,void 0)},869866:(h,x)=>{m.jb("Elu",h,{alpha:x})},869924:h=>{m.jb("Gelu",h,void 0)},869976:h=>{m.jb("Relu",h,void 0)},870028:(h,x)=>{m.jb("LeakyRelu",h,{alpha:x})},870092:(h,x)=>{m.jb("ThresholdedRelu",h,{alpha:x})},870162:(h,x)=>{m.jb("Cast",h,{to:x})},870220:h=>{m.jb("Add",h,void 0)},870271:h=>{m.jb("Sub",h,void 0)},870322:h=>{m.jb("Mul",h,void 0)},870373:h=>{m.jb("Div",h,void 0)},870424:h=>{m.jb("Pow",h,void 0)},870475:h=>{m.jb("Equal",h,void 0)},870528:h=>{m.jb("Greater",h,void 0)},870583:h=>{m.jb("GreaterOrEqual",h,void 0)},870645:h=>{m.jb("Less",h,void 0)},870697:h=>{m.jb("LessOrEqual",h,void 0)},870756:(h,x,I,N,Z)=>{m.jb("ReduceMean",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},870915:(h,x,I,N,Z)=>{m.jb("ReduceMax",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},871073:(h,x,I,N,Z)=>{m.jb("ReduceMin",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},871231:(h,x,I,N,Z)=>{m.jb("ReduceProd",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},871390:(h,x,I,N,Z)=>{m.jb("ReduceSum",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},871548:(h,x,I,N,Z)=>{m.jb("ReduceL1",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},871705:(h,x,I,N,Z)=>{m.jb("ReduceL2",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},871862:(h,x,I,N,Z)=>{m.jb("ReduceLogSum",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},872023:(h,x,I,N,Z)=>{m.jb("ReduceSumSquare",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},872187:(h,x,I,N,Z)=>{m.jb("ReduceLogSumExp",h,{keepDims:!!x,noopWithEmptyAxes:!!I,axes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},872351:h=>{m.jb("Where",h,void 0)},872404:(h,x,I)=>{m.jb("Transpose",h,{perm:x?Array.from(c().subarray(x>>>0,I>>>0)):[]})},872512:(h,x,I,N)=>{m.jb("DepthToSpace",h,{blocksize:x,mode:Vr(I),format:N?"NHWC":"NCHW"})},872645:(h,x,I,N)=>{m.jb("DepthToSpace",h,{blocksize:x,mode:Vr(I),format:N?"NHWC":"NCHW"})},872778:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je,Cn)=>{m.jb("ConvTranspose",h,{format:zt?"NHWC":"NCHW",autoPad:x,dilations:[I],group:N,kernelShape:[Z],pads:[ge,Xe],strides:[pt],wIsConst:()=>!!s()[Vt>>>0],outputPadding:rn?Array.from(c().subarray(rn>>>0,$n>>>0)):[],outputShape:Jn?Array.from(c().subarray(Jn>>>0,je>>>0)):[],activation:Vr(Cn)})},873179:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je)=>{m.jb("ConvTranspose",h,{format:pt?"NHWC":"NCHW",autoPad:x,dilations:Array.from(c().subarray(I>>>0,2+(I>>>0)>>>0)),group:N,kernelShape:Array.from(c().subarray(Z>>>0,2+(Z>>>0)>>>0)),pads:Array.from(c().subarray(ge>>>0,4+(ge>>>0)>>>0)),strides:Array.from(c().subarray(Xe>>>0,2+(Xe>>>0)>>>0)),wIsConst:()=>!!s()[zt>>>0],outputPadding:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],outputShape:$n?Array.from(c().subarray($n>>>0,Jn>>>0)):[],activation:Vr(je)})},873744:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je,Cn)=>{m.jb("ConvTranspose",h,{format:zt?"NHWC":"NCHW",autoPad:x,dilations:[I],group:N,kernelShape:[Z],pads:[ge,Xe],strides:[pt],wIsConst:()=>!!s()[Vt>>>0],outputPadding:rn?Array.from(c().subarray(rn>>>0,$n>>>0)):[],outputShape:Jn?Array.from(c().subarray(Jn>>>0,je>>>0)):[],activation:Vr(Cn)})},874145:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je)=>{m.jb("ConvTranspose",h,{format:pt?"NHWC":"NCHW",autoPad:x,dilations:Array.from(c().subarray(I>>>0,2+(I>>>0)>>>0)),group:N,kernelShape:Array.from(c().subarray(Z>>>0,2+(Z>>>0)>>>0)),pads:Array.from(c().subarray(ge>>>0,4+(ge>>>0)>>>0)),strides:Array.from(c().subarray(Xe>>>0,2+(Xe>>>0)>>>0)),wIsConst:()=>!!s()[zt>>>0],outputPadding:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],outputShape:$n?Array.from(c().subarray($n>>>0,Jn>>>0)):[],activation:Vr(je)})},874710:(h,x)=>{m.jb("GlobalAveragePool",h,{format:x?"NHWC":"NCHW"})},874801:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je)=>{m.jb("AveragePool",h,{format:je?"NHWC":"NCHW",auto_pad:x,ceil_mode:I,count_include_pad:N,storage_order:Z,dilations:ge?Array.from(c().subarray(ge>>>0,Xe>>>0)):[],kernel_shape:pt?Array.from(c().subarray(pt>>>0,zt>>>0)):[],pads:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],strides:$n?Array.from(c().subarray($n>>>0,Jn>>>0)):[]})},875216:(h,x)=>{m.jb("GlobalAveragePool",h,{format:x?"NHWC":"NCHW"})},875307:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je)=>{m.jb("AveragePool",h,{format:je?"NHWC":"NCHW",auto_pad:x,ceil_mode:I,count_include_pad:N,storage_order:Z,dilations:ge?Array.from(c().subarray(ge>>>0,Xe>>>0)):[],kernel_shape:pt?Array.from(c().subarray(pt>>>0,zt>>>0)):[],pads:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],strides:$n?Array.from(c().subarray($n>>>0,Jn>>>0)):[]})},875722:(h,x)=>{m.jb("GlobalMaxPool",h,{format:x?"NHWC":"NCHW"})},875809:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je)=>{m.jb("MaxPool",h,{format:je?"NHWC":"NCHW",auto_pad:x,ceil_mode:I,count_include_pad:N,storage_order:Z,dilations:ge?Array.from(c().subarray(ge>>>0,Xe>>>0)):[],kernel_shape:pt?Array.from(c().subarray(pt>>>0,zt>>>0)):[],pads:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],strides:$n?Array.from(c().subarray($n>>>0,Jn>>>0)):[]})},876220:(h,x)=>{m.jb("GlobalMaxPool",h,{format:x?"NHWC":"NCHW"})},876307:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je)=>{m.jb("MaxPool",h,{format:je?"NHWC":"NCHW",auto_pad:x,ceil_mode:I,count_include_pad:N,storage_order:Z,dilations:ge?Array.from(c().subarray(ge>>>0,Xe>>>0)):[],kernel_shape:pt?Array.from(c().subarray(pt>>>0,zt>>>0)):[],pads:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],strides:$n?Array.from(c().subarray($n>>>0,Jn>>>0)):[]})},876718:(h,x,I,N,Z)=>{m.jb("Gemm",h,{alpha:x,beta:I,transA:N,transB:Z})},876822:h=>{m.jb("MatMul",h,void 0)},876876:(h,x,I,N)=>{m.jb("ArgMax",h,{keepDims:!!x,selectLastIndex:!!I,axis:N})},876984:(h,x,I,N)=>{m.jb("ArgMin",h,{keepDims:!!x,selectLastIndex:!!I,axis:N})},877092:(h,x)=>{m.jb("Softmax",h,{axis:x})},877155:(h,x)=>{m.jb("Concat",h,{axis:x})},877215:(h,x,I,N,Z)=>{m.jb("Split",h,{axis:x,numOutputs:I,splitSizes:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},877355:h=>{m.jb("Expand",h,void 0)},877409:(h,x)=>{m.jb("Gather",h,{axis:Number(x)})},877480:(h,x)=>{m.jb("GatherElements",h,{axis:Number(x)})},877559:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn)=>{m.jb("Resize",h,{antialias:x,axes:I?Array.from(c().subarray(I>>>0,N>>>0)):[],coordinateTransformMode:Vr(Z),cubicCoeffA:ge,excludeOutside:Xe,extrapolationValue:pt,keepAspectRatioPolicy:Vr(zt),mode:Vr(Vt),nearestMode:Vr(rn)})},877905:(h,x,I,N,Z,ge,Xe)=>{m.jb("Slice",h,{starts:x?Array.from(c().subarray(x>>>0,I>>>0)):[],ends:N?Array.from(c().subarray(N>>>0,Z>>>0)):[],axes:ge?Array.from(c().subarray(ge>>>0,Xe>>>0)):[]})},878121:h=>{m.jb("Tile",h,void 0)},878173:(h,x,I)=>{m.jb("InstanceNormalization",h,{epsilon:x,format:I?"NHWC":"NCHW"})},878287:(h,x,I)=>{m.jb("InstanceNormalization",h,{epsilon:x,format:I?"NHWC":"NCHW"})},878401:h=>{m.jb("Range",h,void 0)},878454:(h,x)=>{m.jb("Einsum",h,{equation:Vr(x)})},878535:(h,x,I,N,Z)=>{m.jb("Pad",h,{mode:x,value:I,pads:N?Array.from(c().subarray(N>>>0,Z>>>0)):[]})},878662:(h,x,I,N,Z,ge)=>{m.jb("BatchNormalization",h,{epsilon:x,momentum:I,spatial:!!Z,trainingMode:!!N,format:ge?"NHWC":"NCHW"})},878831:(h,x,I,N,Z,ge)=>{m.jb("BatchNormalization",h,{epsilon:x,momentum:I,spatial:!!Z,trainingMode:!!N,format:ge?"NHWC":"NCHW"})},879e3:(h,x,I)=>{m.jb("CumSum",h,{exclusive:Number(x),reverse:Number(I)})},879097:(h,x,I)=>{m.jb("DequantizeLinear",h,{axis:x,blockSize:I})},879187:(h,x,I,N,Z,ge,Xe,pt,zt)=>{m.jb("Attention",h,{numHeads:x,isUnidirectional:I,maskFilterValue:N,scale:Z,doRotary:ge,qkvHiddenSizes:Xe?Array.from(c().subarray(Number(pt)>>>0,Number(pt)+Xe>>>0)):[],pastPresentShareBuffer:!!zt})},879459:h=>{m.jb("BiasAdd",h,void 0)},879514:h=>{m.jb("BiasSplitGelu",h,void 0)},879575:h=>{m.jb("FastGelu",h,void 0)},879631:(h,x,I,N,Z,ge,Xe,pt,zt,Vt,rn,$n,Jn,je,Cn,yr)=>{m.jb("Conv",h,{format:$n?"NHWC":"NCHW",auto_pad:x,dilations:I?Array.from(c().subarray(I>>>0,N>>>0)):[],group:Z,kernel_shape:ge?Array.from(c().subarray(ge>>>0,Xe>>>0)):[],pads:pt?Array.from(c().subarray(pt>>>0,zt>>>0)):[],strides:Vt?Array.from(c().subarray(Vt>>>0,rn>>>0)):[],w_is_const:()=>!!s()[Jn>>>0],activation:Vr(je),activation_params:Cn?Array.from(v().subarray(Cn>>>0,yr>>>0)):[]})},880127:h=>{m.jb("Gelu",h,void 0)},880179:(h,x,I,N,Z,ge,Xe,pt,zt)=>{m.jb("GroupQueryAttention",h,{numHeads:x,kvNumHeads:I,scale:N,softcap:Z,doRotary:ge,rotaryInterleaved:Xe,smoothSoftmax:pt,localWindowSize:zt})},880396:(h,x,I,N)=>{m.jb("LayerNormalization",h,{axis:x,epsilon:I,simplified:!!N})},880507:(h,x,I,N)=>{m.jb("LayerNormalization",h,{axis:x,epsilon:I,simplified:!!N})},880618:(h,x,I,N,Z,ge)=>{m.jb("MatMulNBits",h,{k:x,n:I,accuracyLevel:N,bits:Z,blockSize:ge})},880745:(h,x,I,N,Z,ge)=>{m.jb("MultiHeadAttention",h,{numHeads:x,isUnidirectional:I,maskFilterValue:N,scale:Z,doRotary:ge})},880904:(h,x)=>{m.jb("QuickGelu",h,{alpha:x})},880968:(h,x,I,N,Z)=>{m.jb("RotaryEmbedding",h,{interleaved:!!x,numHeads:I,rotaryEmbeddingDim:N,scale:Z})},881107:(h,x,I)=>{m.jb("SkipLayerNormalization",h,{epsilon:x,simplified:!!I})},881209:(h,x,I)=>{m.jb("SkipLayerNormalization",h,{epsilon:x,simplified:!!I})},881311:(h,x,I,N)=>{m.jb("GatherBlockQuantized",h,{gatherAxis:x,quantizeAxis:I,blockSize:N})},881432:h=>{m.Zb(h)},881466:(h,x)=>m.bc(h,x,m.Fb.fc,m.Fb.errors)};function Z2(h,x,I){return E1(async()=>{await m.Xb(h,x,I)})}function eS(){return typeof wasmOffsetConverter<"u"}function E_(h){this.name="ExitStatus",this.message=`Program terminated with exit(${h})`,this.status=h}var k_=h=>{h.terminate(),h.onmessage=()=>{}},Hv=h=>{$s.length==0&&(Zv(),Jv($s[0]));var x=$s.pop();if(!x)return 6;Sa.push(x),So[h.Ab]=x,x.Ab=h.Ab;var I={cmd:"run",start_routine:h.hc,arg:h.Qb,pthread_ptr:h.Ab};return x.postMessage(I,h.mc),0},Ta=0,fr=(h,x,...I)=>{for(var N=2*I.length,Z=q_(),ge=G_(8*N),Xe=ge>>>3,pt=0;pt<I.length;pt++){var zt=I[pt];typeof zt=="bigint"?(Sr[Xe+2*pt]=1n,Sr[Xe+2*pt+1]=zt):(Sr[Xe+2*pt]=0n,b()[Xe+2*pt+1>>>0]=zt)}return h=Q1(h,0,N,ge,x),bm(Z),h};function C_(h){if(ne)return fr(0,1,h);if(Qt=h,!(0<Ta)){for(var x of Sa)k_(x);for(x of $s)k_(x);$s=[],Sa=[],So=[],ui=!0}De(h,new E_(h))}function Kv(h){if(ne)return fr(1,0,h);P_(h)}var P_=h=>{if(Qt=h,ne)throw Kv(h),"unwind";C_(h)},$s=[],Sa=[],Xv=[],So={},Qv=h=>{var x=h.Ab;delete So[x],$s.push(h),Sa.splice(Sa.indexOf(h),1),h.Ab=0,W_(x)};function Yv(){Xv.forEach(h=>h())}var Jv=h=>new Promise(x=>{h.onmessage=Z=>{var ge=(Z=Z.data).cmd;if(Z.targetThread&&Z.targetThread!=Cu()){var Xe=So[Z.targetThread];Xe?Xe.postMessage(Z,Z.transferList):Jt(`Internal error! Worker sent a message "${ge}" to target pthread ${Z.targetThread}, but that thread no longer exists!`)}else ge==="checkMailbox"?dm():ge==="spawnThread"?Hv(Z):ge==="cleanupThread"?Qv(So[Z.thread]):ge==="killThread"?(Z=Z.thread,ge=So[Z],delete So[Z],k_(ge),W_(Z),Sa.splice(Sa.indexOf(ge),1),ge.Ab=0):ge==="cancelThread"?So[Z.thread].postMessage({cmd:"cancel"}):ge==="loaded"?(h.loaded=!0,x(h)):ge==="alert"?alert(`Thread ${Z.threadId}: ${Z.text}`):Z.target==="setimmediate"?h.postMessage(Z):ge==="callHandler"?m[Z.handler](...Z.args):ge&&Jt(`worker sent an unknown command ${ge}`)},h.onerror=Z=>{throw Jt(`worker sent an error! ${Z.filename}:${Z.lineno}: ${Z.message}`),Z};var I,N=[];for(I of[])m.hasOwnProperty(I)&&N.push(I);h.postMessage({cmd:"load",handlers:N,wasmMemory:wn,wasmModule:Bn})});function Zv(){var h=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});$s.push(h)}var cm=h=>{for(;0<h.length;)h.shift()(m)},tS=()=>{var h=Cu(),x=g()[h+52>>>2>>>0];h=g()[h+56>>>2>>>0],J1(x,x-h),bm(x)},nS=(h,x)=>{Ta=0,h=Z1(h,x),0<Ta?Qt=h:vm(h)};class rS{constructor(x){this.Jb=x-24}}function iS(h,x,I){var N=new rS(h>>>=0);throw x>>>=0,I>>>=0,g()[N.Jb+16>>>2>>>0]=0,g()[N.Jb+4>>>2>>>0]=x,g()[N.Jb+8>>>2>>>0]=I,h}function e1(h,x,I,N){return ne?fr(2,1,h,x,I,N):t1(h,x,I,N)}function t1(h,x,I,N){if(h>>>=0,x>>>=0,I>>>=0,N>>>=0,ie===void 0)return Jt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Z=[];return ne&&Z.length===0?e1(h,x,I,N):(h={hc:I,Ab:h,Qb:N,mc:Z},ne?(h.Mb="spawnThread",postMessage(h,Z),0):Hv(h))}var n1=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,r1=(h,x,I)=>{var N=(x>>>=0)+I;for(I=x;h[I]&&!(I>=N);)++I;if(16<I-x&&h.buffer&&n1)return n1.decode(h.buffer instanceof ie?h.slice(x,I):h.subarray(x,I));for(N="";x<I;){var Z=h[x++];if(128&Z){var ge=63&h[x++];if((224&Z)==192)N+=String.fromCharCode((31&Z)<<6|ge);else{var Xe=63&h[x++];65536>(Z=(240&Z)==224?(15&Z)<<12|ge<<6|Xe:(7&Z)<<18|ge<<12|Xe<<6|63&h[x++])?N+=String.fromCharCode(Z):(Z-=65536,N+=String.fromCharCode(55296|Z>>10,56320|1023&Z))}}else N+=String.fromCharCode(Z)}return N},Vr=(h,x)=>(h>>>=0)?r1(u(),h,x):"";function i1(h,x,I){return ne?fr(3,1,h,x,I):0}function o1(h,x){if(ne)return fr(4,1,h,x)}var $_=h=>{for(var x=0,I=0;I<h.length;++I){var N=h.charCodeAt(I);127>=N?x++:2047>=N?x+=2:55296<=N&&57343>=N?(x+=4,++I):x+=3}return x},s1=(h,x,I,N)=>{if(!(0<N))return 0;var Z=I>>>=0;N=I+N-1;for(var ge=0;ge<h.length;++ge){var Xe=h.charCodeAt(ge);if(55296<=Xe&&57343>=Xe&&(Xe=65536+((1023&Xe)<<10)|1023&h.charCodeAt(++ge)),127>=Xe){if(I>=N)break;x[I++>>>0]=Xe}else{if(2047>=Xe){if(I+1>=N)break;x[I++>>>0]=192|Xe>>6}else{if(65535>=Xe){if(I+2>=N)break;x[I++>>>0]=224|Xe>>12}else{if(I+3>=N)break;x[I++>>>0]=240|Xe>>18,x[I++>>>0]=128|Xe>>12&63}x[I++>>>0]=128|Xe>>6&63}x[I++>>>0]=128|63&Xe}}return x[I>>>0]=0,I-Z},Eu=(h,x,I)=>s1(h,u(),x,I);function a1(h,x){if(ne)return fr(5,1,h,x)}function l1(h,x,I){if(ne)return fr(6,1,h,x,I)}function u1(h,x,I){return ne?fr(7,1,h,x,I):0}function c1(h,x){if(ne)return fr(8,1,h,x)}function d1(h,x,I){if(ne)return fr(9,1,h,x,I)}function p1(h,x,I,N){if(ne)return fr(10,1,h,x,I,N)}function f1(h,x,I,N){if(ne)return fr(11,1,h,x,I,N)}function h1(h,x,I,N){if(ne)return fr(12,1,h,x,I,N)}function m1(h){if(ne)return fr(13,1,h)}function g1(h,x){if(ne)return fr(14,1,h,x)}function _1(h,x,I){if(ne)return fr(15,1,h,x,I)}var y1,As,oS=()=>{Su("")},Eo=h=>{for(var x="";u()[h>>>0];)x+=y1[u()[h++>>>0]];return x},A_={},F_={};function Ko(h,x,I={}){if(!("argPackAdvance"in x))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(N,Z,ge={}){var Xe=Z.name;if(!N)throw new As(`type "${Xe}" must have a positive integer typeid pointer`);if(F_.hasOwnProperty(N)){if(ge.Sb)return;throw new As(`Cannot register type '${Xe}' twice`)}F_[N]=Z,A_.hasOwnProperty(N)&&(Z=A_[N],delete A_[N],Z.forEach(pt=>pt()))}(h,x,I)}var w1=(h,x,I)=>{switch(x){case 1:return I?N=>s()[N>>>0]:N=>u()[N>>>0];case 2:return I?N=>d()[N>>>1>>>0]:N=>f()[N>>>1>>>0];case 4:return I?N=>c()[N>>>2>>>0]:N=>g()[N>>>2>>>0];case 8:return I?N=>Sr[N>>>3]:N=>Cs[N>>>3];default:throw new TypeError(`invalid integer width (${x}): ${h}`)}};function sS(h,x,I){I>>>=0,Ko(h>>>=0,{name:x=Eo(x>>>0),fromWireType:N=>N,toWireType:function(N,Z){if(typeof Z!="bigint"&&typeof Z!="number")throw Z=Z===null?"null":(N=typeof Z)=="object"||N==="array"||N==="function"?Z.toString():""+Z,new TypeError(`Cannot convert "${Z}" to ${this.name}`);return typeof Z=="number"&&(Z=BigInt(Z)),Z},argPackAdvance:Fs,readValueFromPointer:w1(x,I,x.indexOf("u")==-1),Db:null})}var Fs=8;function aS(h,x,I,N){Ko(h>>>=0,{name:x=Eo(x>>>0),fromWireType:function(Z){return!!Z},toWireType:function(Z,ge){return ge?I:N},argPackAdvance:Fs,readValueFromPointer:function(Z){return this.fromWireType(u()[Z>>>0])},Db:null})}var I_=[],Xo=[];function O_(h){9<(h>>>=0)&&--Xo[h+1]==0&&(Xo[h]=void 0,I_.push(h))}var Ui=h=>{if(!h)throw new As("Cannot use deleted val. handle = "+h);return Xo[h]},ji=h=>{switch(h){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let x=I_.pop()||Xo.length;return Xo[x]=h,Xo[x+1]=1,x}};function D_(h){return this.fromWireType(g()[h>>>2>>>0])}var lS={name:"emscripten::val",fromWireType:h=>{var x=Ui(h);return O_(h),x},toWireType:(h,x)=>ji(x),argPackAdvance:Fs,readValueFromPointer:D_,Db:null};function uS(h){return Ko(h>>>0,lS)}var cS=(h,x)=>{switch(x){case 4:return function(I){return this.fromWireType(v()[I>>>2>>>0])};case 8:return function(I){return this.fromWireType(b()[I>>>3>>>0])};default:throw new TypeError(`invalid float width (${x}): ${h}`)}};function dS(h,x,I){I>>>=0,Ko(h>>>=0,{name:x=Eo(x>>>0),fromWireType:N=>N,toWireType:(N,Z)=>Z,argPackAdvance:Fs,readValueFromPointer:cS(x,I),Db:null})}function pS(h,x,I,N,Z){if(h>>>=0,I>>>=0,x=Eo(x>>>0),Z===-1&&(Z=4294967295),Z=pt=>pt,N===0){var ge=32-8*I;Z=pt=>pt<<ge>>>ge}var Xe=x.includes("unsigned")?function(pt,zt){return zt>>>0}:function(pt,zt){return zt};Ko(h,{name:x,fromWireType:Z,toWireType:Xe,argPackAdvance:Fs,readValueFromPointer:w1(x,I,N!==0),Db:null})}function fS(h,x,I){function N(ge){var Xe=g()[ge>>>2>>>0];return ge=g()[ge+4>>>2>>>0],new Z(s().buffer,ge,Xe)}var Z=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][x];Ko(h>>>=0,{name:I=Eo(I>>>0),fromWireType:N,argPackAdvance:Fs,readValueFromPointer:N},{Sb:!0})}function hS(h,x){h>>>=0;var I=(x=Eo(x>>>0))==="std::string";Ko(h,{name:x,fromWireType:function(N){var Z=g()[N>>>2>>>0],ge=N+4;if(I)for(var Xe=ge,pt=0;pt<=Z;++pt){var zt=ge+pt;if(pt==Z||u()[zt>>>0]==0){if(Xe=Vr(Xe,zt-Xe),Vt===void 0)var Vt=Xe;else Vt+="\0",Vt+=Xe;Xe=zt+1}}else{for(Vt=Array(Z),pt=0;pt<Z;++pt)Vt[pt]=String.fromCharCode(u()[ge+pt>>>0]);Vt=Vt.join("")}return Co(N),Vt},toWireType:function(N,Z){Z instanceof ArrayBuffer&&(Z=new Uint8Array(Z));var ge=typeof Z=="string";if(!(ge||Z instanceof Uint8Array||Z instanceof Uint8ClampedArray||Z instanceof Int8Array))throw new As("Cannot pass non-string to std::string");var Xe=I&&ge?$_(Z):Z.length,pt=wm(4+Xe+1),zt=pt+4;if(g()[pt>>>2>>>0]=Xe,I&&ge)Eu(Z,zt,Xe+1);else if(ge)for(ge=0;ge<Xe;++ge){var Vt=Z.charCodeAt(ge);if(255<Vt)throw Co(zt),new As("String has UTF-16 code units that do not fit in 8 bits");u()[zt+ge>>>0]=Vt}else for(ge=0;ge<Xe;++ge)u()[zt+ge>>>0]=Z[ge];return N!==null&&N.push(Co,pt),pt},argPackAdvance:Fs,readValueFromPointer:D_,Db(N){Co(N)}})}var v1=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,mS=(h,x)=>{for(var I=h>>1,N=I+x/2;!(I>=N)&&f()[I>>>0];)++I;if(32<(I<<=1)-h&&v1)return v1.decode(u().slice(h,I));for(I="",N=0;!(N>=x/2);++N){var Z=d()[h+2*N>>>1>>>0];if(Z==0)break;I+=String.fromCharCode(Z)}return I},gS=(h,x,I)=>{if(I??(I=2147483647),2>I)return 0;var N=x;I=(I-=2)<2*h.length?I/2:h.length;for(var Z=0;Z<I;++Z){var ge=h.charCodeAt(Z);d()[x>>>1>>>0]=ge,x+=2}return d()[x>>>1>>>0]=0,x-N},_S=h=>2*h.length,yS=(h,x)=>{for(var I=0,N="";!(I>=x/4);){var Z=c()[h+4*I>>>2>>>0];if(Z==0)break;++I,65536<=Z?(Z-=65536,N+=String.fromCharCode(55296|Z>>10,56320|1023&Z)):N+=String.fromCharCode(Z)}return N},wS=(h,x,I)=>{if(x>>>=0,I??(I=2147483647),4>I)return 0;var N=x;I=N+I-4;for(var Z=0;Z<h.length;++Z){var ge=h.charCodeAt(Z);if(55296<=ge&&57343>=ge&&(ge=65536+((1023&ge)<<10)|1023&h.charCodeAt(++Z)),c()[x>>>2>>>0]=ge,(x+=4)+4>I)break}return c()[x>>>2>>>0]=0,x-N},vS=h=>{for(var x=0,I=0;I<h.length;++I){var N=h.charCodeAt(I);55296<=N&&57343>=N&&++I,x+=4}return x};function bS(h,x,I){if(h>>>=0,x>>>=0,I=Eo(I>>>=0),x===2)var N=mS,Z=gS,ge=_S,Xe=pt=>f()[pt>>>1>>>0];else x===4&&(N=yS,Z=wS,ge=vS,Xe=pt=>g()[pt>>>2>>>0]);Ko(h,{name:I,fromWireType:pt=>{for(var zt,Vt=g()[pt>>>2>>>0],rn=pt+4,$n=0;$n<=Vt;++$n){var Jn=pt+4+$n*x;$n!=Vt&&Xe(Jn)!=0||(rn=N(rn,Jn-rn),zt===void 0?zt=rn:(zt+="\0",zt+=rn),rn=Jn+x)}return Co(pt),zt},toWireType:(pt,zt)=>{if(typeof zt!="string")throw new As(`Cannot pass non-string to C++ string type ${I}`);var Vt=ge(zt),rn=wm(4+Vt+x);return g()[rn>>>2>>>0]=Vt/x,Z(zt,rn+4,Vt+x),pt!==null&&pt.push(Co,rn),rn},argPackAdvance:Fs,readValueFromPointer:D_,Db(pt){Co(pt)}})}function MS(h,x){Ko(h>>>=0,{Tb:!0,name:x=Eo(x>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var xS=()=>1;function TS(h){V_(h>>>0,!X,1,!G,131072,!1),Yv()}var b1=h=>{if(!ui)try{if(h(),!(0<Ta))try{ne?vm(Qt):P_(Qt)}catch(x){x instanceof E_||x=="unwind"||De(1,x)}}catch(x){x instanceof E_||x=="unwind"||De(1,x)}};function z_(h){h>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(c(),h>>>2,h).value.then(dm),h+=128,Atomics.store(c(),h>>>2,1))}var dm=()=>{var h=Cu();h&&(z_(h),b1(Y1))};function SS(h,x){(h>>>=0)==x>>>0?setTimeout(dm):ne?postMessage({targetThread:h,cmd:"checkMailbox"}):(h=So[h])&&h.postMessage({cmd:"checkMailbox"})}var L_=[];function ES(h,x,I,N,Z){for(x>>>=0,N/=2,L_.length=N,I=Z>>>0>>>3,Z=0;Z<N;Z++)L_[Z]=Sr[I+2*Z]?Sr[I+2*Z+1]:b()[I+2*Z+1>>>0];return(x?S_[x]:mE[h])(...L_)}function kS(h){h>>>=0,ne?postMessage({cmd:"cleanupThread",thread:h}):Qv(So[h])}function CS(h){}var R_=(h,x)=>{var I=F_[h];if(I===void 0)throw h=H1(h),I=Eo(h),Co(h),new As(`${x} has unknown type ${I}`);return I},M1=(h,x,I)=>{var N=[];return h=h.toWireType(N,I),N.length&&(g()[x>>>2>>>0]=ji(N)),h};function PS(h,x,I){return x>>>=0,I>>>=0,h=Ui(h>>>0),x=R_(x,"emval::as"),M1(x,I,h)}var pm=h=>{try{h()}catch(x){Su(x)}},Is=0,ko=null,x1=0,fm=[],T1={},S1={},$S=0,B_=null,AS=[];function E1(h){return function(x){if(!ui){if(Is===0){var I=!1,N=!1;x((Z=0)=>{if(!ui&&(x1=Z,I=!0,N)){Is=2,pm(()=>nb(ko)),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.resume(),Z=!1;try{var ge=function(){var zt=c()[ko+8>>>2>>>0];return zt=en[S1[zt]],--Ta,zt()}()}catch(zt){ge=zt,Z=!0}var Xe=!1;if(!ko){var pt=B_;pt&&(B_=null,(Z?pt.reject:pt.resolve)(ge),Xe=!0)}if(Z&&!Xe)throw ge}}),N=!0,I||(Is=1,ko=function(){var Z=wm(65548),ge=Z+12;g()[Z>>>2>>>0]=ge,g()[Z+4>>>2>>>0]=ge+65536,ge=fm[0];var Xe=T1[ge];return Xe===void 0&&(Xe=$S++,T1[ge]=Xe,S1[Xe]=ge),ge=Xe,c()[Z+8>>>2>>>0]=ge,Z}(),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.pause(),pm(()=>eb(ko)))}else Is===2?(Is=0,pm(rb),Co(ko),ko=null,AS.forEach(b1)):Su(`invalid state: ${Is}`);return x1}}(x=>{h().then(x)})}function FS(h){return h>>>=0,E1(()=>(h=Ui(h)).then(ji))}var hm=[];function IS(h,x,I,N){return I>>>=0,N>>>=0,(h=hm[h>>>0])(null,x=Ui(x>>>0),I,N)}var OS={},mm=h=>{var x=OS[h];return x===void 0?Eo(h):x};function DS(h,x,I,N,Z){return I>>>=0,N>>>=0,Z>>>=0,(h=hm[h>>>0])(x=Ui(x>>>0),x[I=mm(I)],N,Z)}var k1=()=>typeof globalThis=="object"?globalThis:Function("return this")();function zS(h){return(h>>>=0)==0?ji(k1()):(h=mm(h),ji(k1()[h]))}var LS=h=>{var x=hm.length;return hm.push(h),x},RS=(h,x)=>{for(var I=Array(h),N=0;N<h;++N)I[N]=R_(g()[x+4*N>>>2>>>0],"parameter "+N);return I},C1=(h,x)=>Object.defineProperty(x,"name",{value:h});function BS(h,x,I){var N=(x=RS(h,x>>>0)).shift();h--;var Z=`return function (obj, func, destructorsRef, args) {
`,ge=0,Xe=[];I===0&&Xe.push("obj");for(var pt=["retType"],zt=[N],Vt=0;Vt<h;++Vt)Xe.push("arg"+Vt),pt.push("argType"+Vt),zt.push(x[Vt]),Z+=`  var arg${Vt} = argType${Vt}.readValueFromPointer(args${ge?"+"+ge:""});
`,ge+=x[Vt].argPackAdvance;return Z+=`  var rv = ${I===1?"new func":"func.call"}(${Xe.join(", ")});
`,N.Tb||(pt.push("emval_returnValue"),zt.push(M1),Z+=`  return emval_returnValue(retType, destructorsRef, rv);
`),pt.push(Z+`};
`),h=function(rn){var $n=Function;if(!($n instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof $n} which is not a function`);var Jn=C1($n.name||"unknownFunctionName",function(){});return Jn.prototype=$n.prototype,Jn=new Jn,(rn=$n.apply(Jn,rn))instanceof Object?rn:Jn}(pt)(...zt),I=`methodCaller<(${x.map(rn=>rn.name).join(", ")}) => ${N.name}>`,LS(C1(I,h))}function NS(h){return h=mm(h>>>0),ji(m[h])}function US(h,x){return x>>>=0,h=Ui(h>>>0),x=Ui(x),ji(h[x])}function jS(h){9<(h>>>=0)&&(Xo[h+1]+=1)}function VS(){return ji([])}function WS(h){h=Ui(h>>>0);for(var x=Array(h.length),I=0;I<h.length;I++)x[I]=h[I];return ji(x)}function GS(h){return ji(mm(h>>>0))}function qS(){return ji({})}function HS(h){for(var x=Ui(h>>>=0);x.length;){var I=x.pop();x.pop()(I)}O_(h)}function KS(h,x,I){x>>>=0,I>>>=0,h=Ui(h>>>0),x=Ui(x),I=Ui(I),h[x]=I}function XS(h,x){return x>>>=0,h=(h=R_(h>>>0,"_emval_take_value")).readValueFromPointer(x),ji(h)}function QS(h,x){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),x>>>=0,h=new Date(1e3*h),c()[x>>>2>>>0]=h.getUTCSeconds(),c()[x+4>>>2>>>0]=h.getUTCMinutes(),c()[x+8>>>2>>>0]=h.getUTCHours(),c()[x+12>>>2>>>0]=h.getUTCDate(),c()[x+16>>>2>>>0]=h.getUTCMonth(),c()[x+20>>>2>>>0]=h.getUTCFullYear()-1900,c()[x+24>>>2>>>0]=h.getUTCDay(),h=(h.getTime()-Date.UTC(h.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,c()[x+28>>>2>>>0]=h}var ku=h=>h%4==0&&(h%100!=0||h%400==0),P1=[0,31,60,91,121,152,182,213,244,274,305,335],$1=[0,31,59,90,120,151,181,212,243,273,304,334];function YS(h,x){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),x>>>=0,h=new Date(1e3*h),c()[x>>>2>>>0]=h.getSeconds(),c()[x+4>>>2>>>0]=h.getMinutes(),c()[x+8>>>2>>>0]=h.getHours(),c()[x+12>>>2>>>0]=h.getDate(),c()[x+16>>>2>>>0]=h.getMonth(),c()[x+20>>>2>>>0]=h.getFullYear()-1900,c()[x+24>>>2>>>0]=h.getDay();var I=(ku(h.getFullYear())?P1:$1)[h.getMonth()]+h.getDate()-1|0;c()[x+28>>>2>>>0]=I,c()[x+36>>>2>>>0]=-60*h.getTimezoneOffset(),I=new Date(h.getFullYear(),6,1).getTimezoneOffset();var N=new Date(h.getFullYear(),0,1).getTimezoneOffset();h=0|(I!=N&&h.getTimezoneOffset()==Math.min(N,I)),c()[x+32>>>2>>>0]=h}function JS(h){h>>>=0;var x=new Date(c()[h+20>>>2>>>0]+1900,c()[h+16>>>2>>>0],c()[h+12>>>2>>>0],c()[h+8>>>2>>>0],c()[h+4>>>2>>>0],c()[h>>>2>>>0],0),I=c()[h+32>>>2>>>0],N=x.getTimezoneOffset(),Z=new Date(x.getFullYear(),6,1).getTimezoneOffset(),ge=new Date(x.getFullYear(),0,1).getTimezoneOffset(),Xe=Math.min(ge,Z);return 0>I?c()[h+32>>>2>>>0]=+(Z!=ge&&Xe==N):0<I!=(Xe==N)&&(Z=Math.max(ge,Z),x.setTime(x.getTime()+6e4*((0<I?Xe:Z)-N))),c()[h+24>>>2>>>0]=x.getDay(),I=(ku(x.getFullYear())?P1:$1)[x.getMonth()]+x.getDate()-1|0,c()[h+28>>>2>>>0]=I,c()[h>>>2>>>0]=x.getSeconds(),c()[h+4>>>2>>>0]=x.getMinutes(),c()[h+8>>>2>>>0]=x.getHours(),c()[h+12>>>2>>>0]=x.getDate(),c()[h+16>>>2>>>0]=x.getMonth(),c()[h+20>>>2>>>0]=x.getYear(),h=x.getTime(),BigInt(isNaN(h)?-1:h/1e3)}function A1(h,x,I,N,Z,ge,Xe){return ne?fr(16,1,h,x,I,N,Z,ge,Xe):-52}function F1(h,x,I,N,Z,ge){if(ne)return fr(17,1,h,x,I,N,Z,ge)}function ZS(h,x,I,N){h>>>=0,x>>>=0,I>>>=0,N>>>=0;var Z=new Date().getFullYear(),ge=new Date(Z,0,1),Xe=new Date(Z,6,1);Z=ge.getTimezoneOffset();var pt=Xe.getTimezoneOffset(),zt=Math.max(Z,pt);g()[h>>>2>>>0]=60*zt,c()[x>>>2>>>0]=+(Z!=pt),ge=(h=Vt=>Vt.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(ge),Xe=h(Xe),pt<Z?(Eu(ge,I,17),Eu(Xe,N,17)):(Eu(ge,N,17),Eu(Xe,I,17))}var N_=[],I1=(h,x)=>{N_.length=0;for(var I;I=u()[h++>>>0];){var N=I!=105;x+=(N&=I!=112)&&x%8?4:0,N_.push(I==112?g()[x>>>2>>>0]:I==106?Sr[x>>>3]:I==105?c()[x>>>2>>>0]:b()[x>>>3>>>0]),x+=N?8:4}return N_};function eE(h,x,I){return h>>>=0,x=I1(x>>>0,I>>>0),S_[h](...x)}function tE(h,x,I){return h>>>=0,x=I1(x>>>0,I>>>0),S_[h](...x)}var nE=()=>{},rE=()=>Date.now();function iE(h,x){return Jt(Vr(h>>>0,x>>>0))}var O1,oE=()=>{throw Ta+=1,"unwind"};function sE(){return 4294901760}O1=()=>performance.timeOrigin+performance.now();var aE=()=>navigator.hardwareConcurrency;function lE(){return Su("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function uE(h){h>>>=0;var x=u().length;if(h<=x||4294901760<h)return!1;for(var I=1;4>=I;I*=2){var N=x*(1+.2/I);N=Math.min(N,h+100663296);var Z=Math;N=Math.max(h,N);e:{Z=(Z.min.call(Z,4294901760,N+(65536-N%65536)%65536)-wn.buffer.byteLength+65535)/65536;try{wn.grow(Z),zr();var ge=1;break e}catch{}ge=void 0}if(ge)return!0}return!1}var gm=()=>(Su("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),xf={},D1=h=>{h.forEach(x=>{gm()})};function cE(){var h=Error().stack.toString().split(`
`);return h[0]=="Error"&&h.shift(),D1(h),xf.Pb=gm(),xf.ec=h,xf.Pb}function dE(h,x,I){if(h>>>=0,x>>>=0,xf.Pb==h)var N=xf.ec;else(N=Error().stack.toString().split(`
`))[0]=="Error"&&N.shift(),D1(N);for(var Z=3;N[Z]&&gm()!=h;)++Z;for(h=0;h<I&&N[h+Z];++h)c()[x+4*h>>>2>>>0]=gm();return h}var U_,j_={},z1=()=>{if(!U_){var h,x={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:Fe};for(h in j_)j_[h]===void 0?delete x[h]:x[h]=j_[h];var I=[];for(h in x)I.push(`${h}=${x[h]}`);U_=I}return U_};function L1(h,x){if(ne)return fr(18,1,h,x);h>>>=0,x>>>=0;var I=0;return z1().forEach((N,Z)=>{var ge=x+I;for(Z=g()[h+4*Z>>>2>>>0]=ge,ge=0;ge<N.length;++ge)s()[Z++>>>0]=N.charCodeAt(ge);s()[Z>>>0]=0,I+=N.length+1}),0}function R1(h,x){if(ne)return fr(19,1,h,x);h>>>=0,x>>>=0;var I=z1();g()[h>>>2>>>0]=I.length;var N=0;return I.forEach(Z=>N+=Z.length+1),g()[x>>>2>>>0]=N,0}function B1(h){return ne?fr(20,1,h):52}function N1(h,x,I,N){return ne?fr(21,1,h,x,I,N):52}function U1(h,x,I,N){return ne?fr(22,1,h,x,I,N):70}var pE=[null,[],[]];function j1(h,x,I,N){if(ne)return fr(23,1,h,x,I,N);x>>>=0,I>>>=0,N>>>=0;for(var Z=0,ge=0;ge<I;ge++){var Xe=g()[x>>>2>>>0],pt=g()[x+4>>>2>>>0];x+=8;for(var zt=0;zt<pt;zt++){var Vt=u()[Xe+zt>>>0],rn=pE[h];Vt===0||Vt===10?((h===1?un:Jt)(r1(rn,0)),rn.length=0):rn.push(Vt)}Z+=pt}return g()[N>>>2>>>0]=Z,0}var V1=[31,29,31,30,31,30,31,31,30,31,30,31],W1=[31,28,31,30,31,30,31,31,30,31,30,31],fE=(h,x)=>{s().set(h,x>>>0)};function G1(h,x,I,N){function Z(je,Cn,yr){for(je=typeof je=="number"?je.toString():je||"";je.length<Cn;)je=yr[0]+je;return je}function ge(je,Cn){return Z(je,Cn,"0")}function Xe(je,Cn){function yr(ob){return 0>ob?-1:0<ob?1:0}var Ea;return(Ea=yr(je.getFullYear()-Cn.getFullYear()))===0&&(Ea=yr(je.getMonth()-Cn.getMonth()))===0&&(Ea=yr(je.getDate()-Cn.getDate())),Ea}function pt(je){switch(je.getDay()){case 0:return new Date(je.getFullYear()-1,11,29);case 1:return je;case 2:return new Date(je.getFullYear(),0,3);case 3:return new Date(je.getFullYear(),0,2);case 4:return new Date(je.getFullYear(),0,1);case 5:return new Date(je.getFullYear()-1,11,31);case 6:return new Date(je.getFullYear()-1,11,30)}}function zt(je){var Cn=je.Bb;for(je=new Date(new Date(je.Cb+1900,0,1).getTime());0<Cn;){var yr=je.getMonth(),Ea=(ku(je.getFullYear())?V1:W1)[yr];if(!(Cn>Ea-je.getDate())){je.setDate(je.getDate()+Cn);break}Cn-=Ea-je.getDate()+1,je.setDate(1),11>yr?je.setMonth(yr+1):(je.setMonth(0),je.setFullYear(je.getFullYear()+1))}return yr=new Date(je.getFullYear()+1,0,4),Cn=pt(new Date(je.getFullYear(),0,4)),yr=pt(yr),0>=Xe(Cn,je)?0>=Xe(yr,je)?je.getFullYear()+1:je.getFullYear():je.getFullYear()-1}h>>>=0,x>>>=0,I>>>=0,N>>>=0;var Vt=g()[N+40>>>2>>>0];for(var rn in N={kc:c()[N>>>2>>>0],jc:c()[N+4>>>2>>>0],Hb:c()[N+8>>>2>>>0],Lb:c()[N+12>>>2>>>0],Ib:c()[N+16>>>2>>>0],Cb:c()[N+20>>>2>>>0],ub:c()[N+24>>>2>>>0],Bb:c()[N+28>>>2>>>0],sc:c()[N+32>>>2>>>0],ic:c()[N+36>>>2>>>0],lc:Vt?Vr(Vt):""},I=Vr(I),Vt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})I=I.replace(new RegExp(rn,"g"),Vt[rn]);var $n="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Jn="January February March April May June July August September October November December".split(" ");for(rn in Vt={"%a":je=>$n[je.ub].substring(0,3),"%A":je=>$n[je.ub],"%b":je=>Jn[je.Ib].substring(0,3),"%B":je=>Jn[je.Ib],"%C":je=>ge((je.Cb+1900)/100|0,2),"%d":je=>ge(je.Lb,2),"%e":je=>Z(je.Lb,2," "),"%g":je=>zt(je).toString().substring(2),"%G":zt,"%H":je=>ge(je.Hb,2),"%I":je=>((je=je.Hb)==0?je=12:12<je&&(je-=12),ge(je,2)),"%j":je=>{for(var Cn=0,yr=0;yr<=je.Ib-1;Cn+=(ku(je.Cb+1900)?V1:W1)[yr++]);return ge(je.Lb+Cn,3)},"%m":je=>ge(je.Ib+1,2),"%M":je=>ge(je.jc,2),"%n":()=>`
`,"%p":je=>0<=je.Hb&&12>je.Hb?"AM":"PM","%S":je=>ge(je.kc,2),"%t":()=>"	","%u":je=>je.ub||7,"%U":je=>ge(Math.floor((je.Bb+7-je.ub)/7),2),"%V":je=>{var Cn=Math.floor((je.Bb+7-(je.ub+6)%7)/7);if(2>=(je.ub+371-je.Bb-2)%7&&Cn++,Cn)Cn==53&&((yr=(je.ub+371-je.Bb)%7)==4||yr==3&&ku(je.Cb)||(Cn=1));else{Cn=52;var yr=(je.ub+7-je.Bb-1)%7;(yr==4||yr==5&&ku(je.Cb%400-1))&&Cn++}return ge(Cn,2)},"%w":je=>je.ub,"%W":je=>ge(Math.floor((je.Bb+7-(je.ub+6)%7)/7),2),"%y":je=>(je.Cb+1900).toString().substring(2),"%Y":je=>je.Cb+1900,"%z":je=>{var Cn=0<=(je=je.ic);return je=Math.abs(je)/60,(Cn?"+":"-")+("0000"+(je/60*100+je%60)).slice(-4)},"%Z":je=>je.lc,"%%":()=>"%"},I=I.replace(/%%/g,"\0\0"),Vt)I.includes(rn)&&(I=I.replace(new RegExp(rn,"g"),Vt[rn](N)));return rn=function(je){var Cn=Array($_(je)+1);return s1(je,Cn,0,Cn.length),Cn}(I=I.replace(/\0\0/g,"%")),rn.length>x?0:(fE(rn,h),rn.length-1)}function hE(h,x,I,N){return G1(h>>>0,x>>>0,I>>>0,N>>>0)}ne||function(){for(var h=m.numThreads-1;h--;)Zv();xa.unshift(()=>{Ni++,function(x){ne?x():Promise.all($s.map(Jv)).then(x)}(()=>um())})}();for(var q1=Array(256),_m=0;256>_m;++_m)q1[_m]=String.fromCharCode(_m);y1=q1,As=m.BindingError=class extends Error{constructor(h){super(h),this.name="BindingError"}},m.InternalError=class extends Error{constructor(h){super(h),this.name="InternalError"}},Xo.push(0,1,void 0,1,null,1,!0,1,!1,1),m.count_emval_handles=()=>Xo.length/2-5-I_.length;var mE=[C_,Kv,e1,i1,o1,a1,l1,u1,c1,d1,p1,f1,h1,m1,g1,_1,A1,F1,L1,R1,B1,N1,U1,j1],en=function(){function h(I,N){return en=I.exports,en=function(){var Z=en,ge={};for(let[Xe,pt]of Object.entries(Z))ge[Xe]=typeof pt=="function"?(...zt)=>{fm.push(Xe);try{return pt(...zt)}finally{ui||(fm.pop(),ko&&Is===1&&fm.length===0&&(Is=0,Ta+=1,pm(tb),typeof Fibers<"u"&&Fibers.tc()))}}:pt;return ge}(),en=function(){var Z=en,ge=pt=>zt=>pt(zt)>>>0,Xe=pt=>()=>pt()>>>0;return(Z=Object.assign({},Z)).Ca=ge(Z.Ca),Z.fb=Xe(Z.fb),Z.hb=ge(Z.hb),Z.emscripten_main_runtime_thread_id=Xe(Z.emscripten_main_runtime_thread_id),Z.sb=ge(Z.sb),Z.tb=Xe(Z.tb),Z}(),Xv.push(en.ib),$r.unshift(en.Ba),Bn=N,um(),en}var x=qv();if(Ni++,m.instantiateWasm)try{return m.instantiateWasm(x,h)}catch(I){Jt(`Module.instantiateWasm callback failed with error: ${I}`),k(I)}return T_||(T_=m.locateFile?jv("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":m.locateFile?m.locateFile("ort-wasm-simd-threaded.jsep.wasm",st):st+"ort-wasm-simd-threaded.jsep.wasm":new URL(r("./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"),r.b).href),function(I,N){var Z=T_;return Lt||typeof WebAssembly.instantiateStreaming!="function"||jv(Z)||Vv(Z)||typeof fetch!="function"?Gv(Z,I,N):fetch(Z,{credentials:"same-origin"}).then(ge=>WebAssembly.instantiateStreaming(ge,I).then(N,function(Xe){return Jt(`wasm streaming compile failed: ${Xe}`),Jt("falling back to ArrayBuffer instantiation"),Gv(Z,I,N)}))}(x,function(I){h(I.instance,I.module)}).catch(k),{}}(),H1=h=>(H1=en.Ca)(h),K1=()=>(K1=en.Da)();m._OrtInit=(h,x)=>(m._OrtInit=en.Ea)(h,x),m._OrtGetLastError=(h,x)=>(m._OrtGetLastError=en.Fa)(h,x),m._OrtCreateSessionOptions=(h,x,I,N,Z,ge,Xe,pt,zt,Vt)=>(m._OrtCreateSessionOptions=en.Ga)(h,x,I,N,Z,ge,Xe,pt,zt,Vt),m._OrtAppendExecutionProvider=(h,x)=>(m._OrtAppendExecutionProvider=en.Ha)(h,x),m._OrtAddFreeDimensionOverride=(h,x,I)=>(m._OrtAddFreeDimensionOverride=en.Ia)(h,x,I),m._OrtAddSessionConfigEntry=(h,x,I)=>(m._OrtAddSessionConfigEntry=en.Ja)(h,x,I),m._OrtReleaseSessionOptions=h=>(m._OrtReleaseSessionOptions=en.Ka)(h),m._OrtCreateSession=(h,x,I)=>(m._OrtCreateSession=en.La)(h,x,I),m._OrtReleaseSession=h=>(m._OrtReleaseSession=en.Ma)(h),m._OrtGetInputOutputCount=(h,x,I)=>(m._OrtGetInputOutputCount=en.Na)(h,x,I),m._OrtGetInputName=(h,x)=>(m._OrtGetInputName=en.Oa)(h,x),m._OrtGetOutputName=(h,x)=>(m._OrtGetOutputName=en.Pa)(h,x),m._OrtFree=h=>(m._OrtFree=en.Qa)(h),m._OrtCreateTensor=(h,x,I,N,Z,ge)=>(m._OrtCreateTensor=en.Ra)(h,x,I,N,Z,ge),m._OrtGetTensorData=(h,x,I,N,Z)=>(m._OrtGetTensorData=en.Sa)(h,x,I,N,Z),m._OrtReleaseTensor=h=>(m._OrtReleaseTensor=en.Ta)(h),m._OrtCreateRunOptions=(h,x,I,N)=>(m._OrtCreateRunOptions=en.Ua)(h,x,I,N),m._OrtAddRunConfigEntry=(h,x,I)=>(m._OrtAddRunConfigEntry=en.Va)(h,x,I),m._OrtReleaseRunOptions=h=>(m._OrtReleaseRunOptions=en.Wa)(h),m._OrtCreateBinding=h=>(m._OrtCreateBinding=en.Xa)(h),m._OrtBindInput=(h,x,I)=>(m._OrtBindInput=en.Ya)(h,x,I),m._OrtBindOutput=(h,x,I,N)=>(m._OrtBindOutput=en.Za)(h,x,I,N),m._OrtClearBoundOutputs=h=>(m._OrtClearBoundOutputs=en._a)(h),m._OrtReleaseBinding=h=>(m._OrtReleaseBinding=en.$a)(h),m._OrtRunWithBinding=(h,x,I,N,Z)=>(m._OrtRunWithBinding=en.ab)(h,x,I,N,Z),m._OrtRun=(h,x,I,N,Z,ge,Xe,pt)=>(m._OrtRun=en.bb)(h,x,I,N,Z,ge,Xe,pt),m._OrtEndProfiling=h=>(m._OrtEndProfiling=en.cb)(h),m._JsepOutput=(h,x,I)=>(m._JsepOutput=en.db)(h,x,I),m._JsepGetNodeName=h=>(m._JsepGetNodeName=en.eb)(h);var ym,Cu=()=>(Cu=en.fb)(),Co=m._free=h=>(Co=m._free=en.gb)(h),wm=m._malloc=h=>(wm=m._malloc=en.hb)(h),V_=(h,x,I,N,Z,ge)=>(V_=en.kb)(h,x,I,N,Z,ge),X1=()=>(X1=en.lb)(),Q1=(h,x,I,N,Z)=>(Q1=en.mb)(h,x,I,N,Z),W_=h=>(W_=en.nb)(h),vm=h=>(vm=en.ob)(h),Y1=()=>(Y1=en.pb)(),J1=(h,x)=>(J1=en.qb)(h,x),bm=h=>(bm=en.rb)(h),G_=h=>(G_=en.sb)(h),q_=()=>(q_=en.tb)(),Z1=m.dynCall_ii=(h,x)=>(Z1=m.dynCall_ii=en.vb)(h,x),eb=h=>(eb=en.wb)(h),tb=()=>(tb=en.xb)(),nb=h=>(nb=en.yb)(h),rb=()=>(rb=en.zb)();function ib(){0<Ni||(ne?($(m),ne||cm($r),startWorker(m)):(cm(xa),0<Ni||ym||(ym=!0,m.calledRun=!0,ui||(ne||cm($r),$(m),ne||cm(Xr)))))}return m.___start_em_js=881578,m.___stop_em_js=881800,m.stackSave=()=>q_(),m.stackRestore=h=>bm(h),m.stackAlloc=h=>G_(h),m.UTF8ToString=Vr,m.stringToUTF8=Eu,m.lengthBytesUTF8=$_,Ps=function h(){ym||ib(),ym||(Ps=h)},ib(),K}),Re=Se,((n=globalThis.self)==null?void 0:n.name)==="em-pthread"&&Se()}),Ve,ut,xt,yt,$t,_t,Ut,Gt,Rt=_(()=>{var n,i;gn(),Ve=import.meta.url??(typeof document<"u"?(n=document.currentScript)==null?void 0:n.src:typeof self<"u"?(i=self.location)==null?void 0:i.href:void 0),ut=typeof location>"u"?void 0:location.origin,xt=(s,u)=>{try{let d=u??Ve;return(d?new URL(s,d):new URL(s)).origin===ut}catch{return!1}},yt=async s=>{let u=await(await fetch(s,{credentials:"same-origin"})).blob();return URL.createObjectURL(u)},$t=(Hr(),E(An)).default,_t=async()=>{if(!Ve)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(xt(Ve))return[void 0,$t()];let s=await yt(Ve);return[s,$t(s)]},Ut=(Oe(),E(ft)).default,Gt=async(s,u,d)=>[void 0,Ut]}),Be,Ne,mt,Ht,cn,En,Qn,bn,Dn=_(()=>{Rt(),Ne=!1,mt=!1,Ht=!1,cn=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},En=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Qn=async n=>{if(Ne)return Promise.resolve();if(mt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ht)throw new Error("previous call to 'initializeWebAssembly()' failed.");mt=!0;let i=n.initTimeout,s=n.numThreads;if(!En())throw new Error("WebAssembly SIMD is not supported in the current environment.");let u=cn();s>1&&!u&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+s+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),n.numThreads=s=1);let d=n.wasmPaths,f=typeof d=="string"?d:void 0,c=d==null?void 0:d.mjs,g=(c==null?void 0:c.href)??c,v=d==null?void 0:d.wasm,b=(v==null?void 0:v.href)??v,$=n.wasmBinary,[k,m]=await Gt(g,f,s>1),K=!1,G=[];if(i>0&&G.push(new Promise(X=>{setTimeout(()=>{K=!0,X()},i)})),G.push(new Promise((X,ne)=>{let ie={numThreads:s};$?ie.wasmBinary=$:(b||f)&&(ie.locateFile=(ee,de)=>b??(f??de)+ee),m(ie).then(ee=>{mt=!1,Ne=!0,Be=ee,X(),k&&URL.revokeObjectURL(k)},ee=>{mt=!1,Ht=!0,ne(ee)})})),await Promise.race(G),K)throw new Error(`WebAssembly backend initializing failed due to timeout: ${i}ms`)},bn=()=>{if(Ne&&Be)return Be;throw new Error("WebAssembly is not initialized yet.")}}),xn,si,Zn,Ro=_(()=>{Dn(),xn=(n,i)=>{let s=bn(),u=s.lengthBytesUTF8(n)+1,d=s._malloc(u);return s.stringToUTF8(n,d,u),i.push(d),d},si=(n,i,s,u)=>{if(typeof n=="object"&&n!==null){if(s.has(n))throw new Error("Circular reference in options");s.add(n)}Object.entries(n).forEach(([d,f])=>{let c=i?i+d:d;if(typeof f=="object")si(f,c+".",s,u);else if(typeof f=="string"||typeof f=="number")u(c,f.toString());else if(typeof f=="boolean")u(c,f?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof f}`)})},Zn=n=>{let i=bn(),s=i.stackSave();try{let u=i.stackAlloc(8);i._OrtGetLastError(u,u+4);let d=i.HEAP32[u/4],f=i.HEAPU32[u/4+1],c=f?i.UTF8ToString(f):"";throw new Error(`${n} ERROR_CODE: ${d}, ERROR_MESSAGE: ${c}`)}finally{i.stackRestore(s)}}}),cs,Ji=_(()=>{Dn(),Ro(),cs=n=>{let i=bn(),s=0,u=[],d=n||{};try{if((n==null?void 0:n.logSeverityLevel)===void 0)d.logSeverityLevel=2;else if(typeof n.logSeverityLevel!="number"||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if((n==null?void 0:n.logVerbosityLevel)===void 0)d.logVerbosityLevel=0;else if(typeof n.logVerbosityLevel!="number"||!Number.isInteger(n.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);(n==null?void 0:n.terminate)===void 0&&(d.terminate=!1);let f=0;return(n==null?void 0:n.tag)!==void 0&&(f=xn(n.tag,u)),s=i._OrtCreateRunOptions(d.logSeverityLevel,d.logVerbosityLevel,!!d.terminate,f),s===0&&Zn("Can't create run options."),(n==null?void 0:n.extra)!==void 0&&si(n.extra,"",new WeakSet,(c,g)=>{let v=xn(c,u),b=xn(g,u);i._OrtAddRunConfigEntry(s,v,b)!==0&&Zn(`Can't set a run config entry: ${c} - ${g}.`)}),[s,u]}catch(f){throw s!==0&&i._OrtReleaseRunOptions(s),u.forEach(c=>i._free(c)),f}}}),ds,ps,fs,hs,ms,yo=_(()=>{Dn(),Ro(),ds=n=>{switch(n){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${n}`)}},ps=n=>{switch(n){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${n}`)}},fs=n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});let i=n.extra.session;i.use_ort_model_bytes_directly||(i.use_ort_model_bytes_directly="1"),n.executionProviders&&n.executionProviders.some(s=>(typeof s=="string"?s:s.name)==="webgpu")&&(n.enableMemPattern=!1)},hs=(n,i,s)=>{for(let u of i){let d=typeof u=="string"?u:u.name;switch(d){case"webnn":if(d="WEBNN",typeof u!="string"){let c=u==null?void 0:u.deviceType;if(c){let g=xn("deviceType",s),v=xn(c,s);bn()._OrtAddSessionConfigEntry(n,g,v)!==0&&Zn(`Can't set a session config entry: 'deviceType' - ${c}.`)}}break;case"webgpu":if(d="JS",typeof u!="string"){let c=u;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);let g=xn("preferredLayout",s),v=xn(c.preferredLayout,s);bn()._OrtAddSessionConfigEntry(n,g,v)!==0&&Zn(`Can't set a session config entry: 'preferredLayout' - ${c.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${d}`)}let f=xn(d,s);bn()._OrtAppendExecutionProvider(n,f)!==0&&Zn(`Can't append execution provider: ${d}.`)}},ms=n=>{let i=bn(),s=0,u=[],d=n||{};fs(d);try{let f=ds(d.graphOptimizationLevel??"all"),c=ps(d.executionMode??"sequential"),g=typeof d.logId=="string"?xn(d.logId,u):0,v=d.logSeverityLevel??2;if(!Number.isInteger(v)||v<0||v>4)throw new Error(`log serverity level is not valid: ${v}`);let b=d.logVerbosityLevel??0;if(!Number.isInteger(b)||b<0||b>4)throw new Error(`log verbosity level is not valid: ${b}`);let $=typeof d.optimizedModelFilePath=="string"?xn(d.optimizedModelFilePath,u):0;if(s=i._OrtCreateSessionOptions(f,!!d.enableCpuMemArena,!!d.enableMemPattern,c,!!d.enableProfiling,0,g,v,b,$),s===0&&Zn("Can't create session options."),d.executionProviders&&hs(s,d.executionProviders,u),d.enableGraphCapture!==void 0){if(typeof d.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`);let k=xn("enableGraphCapture",u),m=xn(d.enableGraphCapture.toString(),u);i._OrtAddSessionConfigEntry(s,k,m)!==0&&Zn(`Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`)}if(d.freeDimensionOverrides)for(let[k,m]of Object.entries(d.freeDimensionOverrides)){if(typeof k!="string")throw new Error(`free dimension override name must be a string: ${k}`);if(typeof m!="number"||!Number.isInteger(m)||m<0)throw new Error(`free dimension override value must be a non-negative integer: ${m}`);let K=xn(k,u);i._OrtAddFreeDimensionOverride(s,K,m)!==0&&Zn(`Can't set a free dimension override: ${k} - ${m}.`)}return d.extra!==void 0&&si(d.extra,"",new WeakSet,(k,m)=>{let K=xn(k,u),G=xn(m,u);i._OrtAddSessionConfigEntry(s,K,G)!==0&&Zn(`Can't set a session config entry: ${k} - ${m}.`)}),[s,u]}catch(f){throw s!==0&&i._OrtReleaseSessionOptions(s),u.forEach(c=>i._free(c)),f}}}),Zi,hi,zi,Bo,Ei,No,Uo,jo,nn=_(()=>{Zi=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${n}`)}},hi=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${n}`)}},zi=(n,i)=>{let s=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][n],u=typeof i=="number"?i:i.reduce((d,f)=>d*f,1);return s>0?Math.ceil(u*s):void 0},Bo=n=>{switch(n){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${n}`)}},Ei=n=>{switch(n){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${n}`)}},No=n=>n==="float32"||n==="float16"||n==="int32"||n==="int64"||n==="uint32"||n==="uint8"||n==="bool"||n==="uint4"||n==="int4",Uo=n=>n==="float32"||n==="float16"||n==="int32"||n==="int64"||n==="uint32"||n==="uint64"||n==="int8"||n==="uint8"||n==="bool",jo=n=>{switch(n){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${n}`)}}}),wo,gs=_(()=>{gn(),wo=async n=>{if(typeof n=="string"){let i=await fetch(n);if(!i.ok)throw new Error(`failed to load external data file: ${n}`);let s=i.headers.get("Content-Length"),u=s?parseInt(s,10):0;if(u<1073741824)return new Uint8Array(await i.arrayBuffer());{if(!i.body)throw new Error(`failed to load external data file: ${n}, no response body.`);let d=i.body.getReader(),f;try{f=new ArrayBuffer(u)}catch(g){if(g instanceof RangeError){let v=Math.ceil(u/65536);f=new WebAssembly.Memory({initial:v,maximum:v}).buffer}else throw g}let c=0;for(;;){let{done:g,value:v}=await d.read();if(g)break;let b=v.byteLength;new Uint8Array(f,c,b).set(v),c+=b}return new Uint8Array(f,0,u)}}else return n instanceof Blob?new Uint8Array(await n.arrayBuffer()):n instanceof Uint8Array?n:new Uint8Array(n)}}),_s,Vo,ys,ws,vo,vs,we,C=_(()=>{nn(),_s=["V","I","W","E","F"],Vo=(n,i)=>{console.log(`[${_s[n]},${new Date().toISOString()}]${i}`)},vo=(n,i)=>{ys=n,ws=i},vs=(n,i)=>{let s=Ei(n),u=Ei(ys);s>=u&&Vo(s,typeof i=="function"?i():i)},we=(...n)=>{ws&&vs(...n)}}),te,le=_(()=>{nn(),te=(n,i)=>new(Bo(i))(n)}),ve=_(()=>{}),Te,He,Mt,At,Pt,Bt,sn,zn,hn,er=_(()=>{C(),ve(),Te=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),He=[],Mt=n=>Math.ceil(n/16)*16,At=n=>{for(let i=0;i<He.length;i++){let s=He[i];if(n<=s)return s}return Math.ceil(n/16)*16},Pt=1,Bt=()=>Pt++,sn=async(n,i,s,u)=>{let d=Mt(s),f=n.device.createBuffer({size:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let c=n.getCommandEncoder();n.endComputePass(),c.copyBufferToBuffer(i,0,f,0,d),n.flush(),await f.mapAsync(GPUMapMode.READ);let g=f.getMappedRange();if(u){let v=u();return v.set(new Uint8Array(g,0,s)),v}else return new Uint8Array(g.slice(0,s))}finally{f.destroy()}},zn=class{constructor(n){this.backend=n,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[i]of Te)He.push(i),this.freeBuffers.set(i,[]),this.freeUniformBuffers.set(i,[]);this.sessionCount=0}upload(n,i){let s=i.buffer,u=i.byteOffset,d=i.byteLength,f=Mt(d),c=this.storageCache.get(n);if(!c)throw new Error("gpu data for uploading does not exist");if(c.originalSize!==d)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${d}`);let g=this.backend.device.createBuffer({mappedAtCreation:!0,size:f,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),v=g.getMappedRange();new Uint8Array(v).set(new Uint8Array(s,u,d)),g.unmap();let b=this.backend.getCommandEncoder();this.backend.endComputePass(),b.copyBufferToBuffer(g,0,c.gpuData.buffer,0,f),we("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${n})`),this.buffersForUploadingPending.push(g)}memcpy(n,i){let s=this.storageCache.get(n);if(!s)throw new Error("source gpu data for memcpy does not exist");let u=this.storageCache.get(i);if(!u)throw new Error("destination gpu data for memcpy does not exist");if(s.originalSize!==u.originalSize)throw new Error("inconsistent source and destination gpu data size");let d=Mt(s.originalSize),f=this.backend.getCommandEncoder();this.backend.endComputePass(),f.copyBufferToBuffer(s.gpuData.buffer,0,u.gpuData.buffer,0,d)}registerExternalBuffer(n,i,s){let u;if(s){if(u=s[0],n===s[1])return we("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${i}) => id=${u}, buffer is the same, skip.`),u;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else u=Bt();return this.storageCache.set(u,{gpuData:{id:u,type:0,buffer:n},originalSize:i}),we("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${i}) => id=${u}, registered.`),u}unregisterExternalBuffer(n){n!==void 0&&(this.storageCache.delete(n),we("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${n}`))}create(n,i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let s=At(n),u,d=(i&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,f=(i&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(d||f){let g=(d?this.freeBuffers:this.freeUniformBuffers).get(s);g?g.length>0?u=g.pop():u=this.backend.device.createBuffer({size:s,usage:i}):u=this.backend.device.createBuffer({size:s,usage:i})}else u=this.backend.device.createBuffer({size:s,usage:i});let c={id:Bt(),type:0,buffer:u};return this.storageCache.set(c.id,{gpuData:c,originalSize:n}),we("verbose",()=>`[WebGPU] GpuDataManager.create(size=${n}) => id=${c.id}`),c}get(n){var i;return(i=this.storageCache.get(n))==null?void 0:i.gpuData}release(n){let i=this.storageCache.get(n);if(!i){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return we("verbose",()=>`[WebGPU] GpuDataManager.release(id=${n}), gpuDataId=${i.gpuData.id}`),this.storageCache.delete(n),this.buffersPending.push(i.gpuData.buffer),i.originalSize}async download(n,i){let s=this.storageCache.get(n);if(!s)throw new Error("data does not exist");await sn(this.backend,s.gpuData.buffer,s.originalSize,i)}refreshPendingBuffers(){for(let n of this.buffersForUploadingPending)n.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let n of this.buffersPending){let i=Te.get(n.size);if((n.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let s=this.freeBuffers.get(n.size)||[];i===void 0||s.length>=i?n.destroy():s.push(n)}else if((n.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let s=this.freeUniformBuffers.get(n.size)||[];i===void 0||s.length>=i?n.destroy():s.push(n)}else n.destroy()}this.buffersPending=[]}else{let n=this.capturedPendingBuffers.get(this.backend.currentSessionId);n||(n=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,n));for(let i of this.buffersPending)n.push(i);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(n=>{n.forEach(i=>{i.destroy()})}),this.freeUniformBuffers.forEach(n=>{n.forEach(i=>{i.destroy()})}),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(n=>{n.forEach(i=>{i.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(n){let i=this.capturedPendingBuffers.get(n);i&&(i.forEach(s=>{s.destroy()}),this.capturedPendingBuffers.delete(n)),this.sessionCount-=1,this.sessionCount===0&&(we("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(s=>{s.gpuData.buffer.destroy()}),this.storageCache=new Map)}},hn=(...n)=>new zn(...n)}),gr,fn,Ln=_(()=>{gr=class{constructor(n){Object.assign(this,n)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(n=>`${this[n]}`).join(";")),this.key}},fn=n=>new gr(n)}),Nr,Kr,Ae,_r,kr,mi,Li,Zt=_(()=>{Nr=class{static calcMatMulShape(n,i){return n[1]!==i[0]?void 0:[n[0],i[1]]}},Kr=class{static calcShape(n,i,s=!1){let u=n.length,d=i.length;if(u===0)return i;if(d===0)return n;let f=Math.max(n.length,i.length),c=new Array(f);if(s){if(u<2||d<2)return;let g=Nr.calcMatMulShape([n[u-2],n[u-1]],[i[d-2],i[d-1]]);if(g===void 0)return;[c[f-2],c[f-1]]=g}for(let g=s?3:1;g<=f;g++){let v=u-g<0?1:n[u-g],b=d-g<0?1:i[d-g];if(v!==b&&v>1&&b>1)return;let $=Math.max(v,b);if(v&&b)c[f-g]=Math.max(v,b);else{if($>1)return;c[f-g]=0}}return c}static isValidBroadcast(n,i){let s=n.length,u=i.length;if(s>u)return!1;for(let d=1;d<=s;d++)if(n[s-d]!==1&&n[s-d]!==i[u-d])return!1;return!0}},Ae=class ng{static size(i){return ng.getSizeFromDimensionRange(i,0,i.length)}static convertShape(i,s=4){let u=i.length;if(u===0)return[];let d=new Array(u),f=u-1;for(;f>=0;){if(i[f]%s===0){d[f]=i[f]/s;break}if(s%i[f]!==0)throw new Error("cannot convert shape");d[f]=1,s/=i[f],f--}for(f--;f>=0;f--)d[f]=i[f];return d}static sizeFromDimension(i,s){if(s<0||s>i.length)throw new Error(`invalid dimension of ${s} for sizeFromDimension as Tensor has ${i.length} dimensions.`);return ng.getSizeFromDimensionRange(i,s,i.length)}static sizeToDimension(i,s){if(s<0||s>i.length)throw new Error(`invalid dimension of ${s} for sizeToDimension as Tensor has ${i.length} dimensions.`);return ng.getSizeFromDimensionRange(i,0,s)}static getSizeFromDimensionRange(i,s,u){let d=1;for(let f=s;f<u;f++){if(i[f]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");d*=i[f]}return d}static computeStrides(i){let s=i.length;if(s===0)return[];if(s===1)return[1];let u=new Array(s);u[s-1]=1,u[s-2]=i[s-1];for(let d=s-3;d>=0;--d)u[d]=u[d+1]*i[d+1];return u}static normalizeAxis(i,s){if(i<-s&&i>=s)throw new Error("unsupported axis for this operation.");return i<0?i+s:i}static normalizeAxes(i,s){return i.map(u=>this.normalizeAxis(u,s??i.length))}static sortBasedOnPerm(i,s){return s?s.map(u=>i[u]):i.slice().reverse()}static padShape(i,s){let u=i.length;return i.map((d,f)=>d+s[f]+s[f+u])}static areEqual(i,s){return i.length!==s.length?!1:i.every((u,d)=>u===s[d])}},_r=class Uf{static adjustPoolAttributes(i,s,u,d,f,c){if(!i&&u.length!==s.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(i)for(let g=0;g<s.length-2;g++)g>=u.length?u.push(s[g+2]):u[g]=s[g+2];for(let g=0;g<u.length;g++)if(g<d.length){if(d[g]<0)throw new Error("strides should be greater than or equal to 1")}else d.push(1);for(let g=0;g<u.length;g++)if(g<f.length){if(f[g]<0)throw new Error("dilations should be greater than or equal to 1")}else f.push(1);for(let g=0;g<u.length*2;g++)if(g<c.length){if(c[g]<0)throw new Error("pad should be greater than or equal to 1")}else c.push(0);for(let g=0;g<u.length;g++){if(u[g]<=0)throw new Error("kernel shapes need to be greater than 0");if(c[g]>=u[g]||c[g+u.length]>=u[g])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(i,s,u,d,f,c,g){if(g){if(f.length!==2*(i.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(s.length!==i.length-2)throw new Error("length of strides should be the length of data dimensions");if(d.length!==i.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let v=0;v<i.length-2;v++)Uf.adjustPadAndReturnShape(i[v+(c?1:2)],s[v],u[v],d[v],f,v,v+i.length-2,g)}}static computePoolOutputShape(i,s,u,d,f,c,g){if(s.length<=0)throw new Error("input shape must be of size greater than 0");let v=[s[0],s[1]];return Uf.computeShapeHelper(i,s,v,u,d,f,c,g),v}static computeConvOutputShape(i,s,u,d,f,c,g){if(i.length<=0||s.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let v=[i[0],s[0]];return Uf.computeShapeHelper(!1,i,v,u,d,f,c,g),v}static computeShapeHelper(i,s,u,d,f,c,g,v){if(i)for(let b=0;b<s.length-2;b++)u.push(1);else for(let b=0;b<s.length-2;b++)u.push(Uf.adjustPadAndReturnShape(s[b+2],d[b],f[b],c[b],g,b,b+s.length-2,v))}static adjustPadAndReturnShape(i,s,u,d,f,c,g,v){let b=u*(d-1)+1;if(v&&v!=="NOTSET")switch(v){case"VALID":return f[c]=0,f[g]=0,Math.floor((i-b)/s+1);case"SAME_LOWER":case"SAME_UPPER":if(u!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let $=((i+s-1)/s-1)*s+d-i;return f[c]=Math.floor(v==="SAME_LOWER"?($+1)/2:$/2),f[g]=$-f[c],Math.floor((i+$-d)/s+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((i+f[c]+f[g]-b)/s+1)}},kr=class{static getShapeOfGemmResult(n,i,s,u,d){if(n.length!==2||s.length!==2)throw new Error("shape need to be of size 2");let f,c,g;i?(f=n[1],c=n[0]):(f=n[0],c=n[1]);let v=-1;if(u?(g=s[0],v=1):(g=s[1],v=0),s[v]!==c)throw new Error("dimension mismatch");if(f<=0||g<=0||c<=0)throw new Error("invalid shape specified");if(d&&!Kr.isValidBroadcast(d,[f,g]))throw new Error("gemm: invalid bias shape for broadcast");return[f,g,c]}},mi=-34028234663852886e22,Li=34028234663852886e22}),Ir,lr,vn,Nn,Ft,Mn,bo,eo,Ri,Kt,na,ot,Yt,qa,Ha,dc,Wo,yn=_(()=>{nn(),Zt(),Ir=64,lr=(n,i)=>{if(i===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(n){case 10:return i>1?`vec${i}<f16>`:"f16";case 1:return i>1?`vec${i}<f32>`:"f32";case 6:return i>1?`vec${i}<i32>`:"i32";case 12:return i>1?`vec${i}<u32>`:"u32";case 7:if(i>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(i>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(i!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${n}`)}},vn=(n,i=1)=>{let s=lr(n,i);return typeof s=="string"?s:s[0]},Nn=(n,i=1)=>{let s=lr(n,i);return typeof s=="string"?s:s[1]},Ft=(...n)=>{let i=[];return n.forEach(s=>{s.length!==0&&i.push({type:12,data:s},{type:12,data:Ae.computeStrides(s)})}),i},Mn=n=>n%4===0?4:n%2===0?2:1,bo=(n="f32",i,s="0")=>!i||i===1?`${n}(${s})`:`vec${i}<${n}>(${s})`,eo=(n,i,s)=>n==="f32"?s:i===1?`f32(${s})`:`vec${i}<f32>(${s})`,Ri=(n,i)=>i===4?`(${n}.x + ${n}.y + ${n}.z + ${n}.w)`:i===2?`(${n}.x + ${n}.y)`:i===3?`(${n}.x + ${n}.y + ${n}.z)`:n,Kt=(n,i,s,u)=>n.startsWith("uniforms.")&&s>4?typeof i=="string"?u==="f16"?`${n}[(${i}) / 8][(${i}) % 8 / 4][(${i}) % 8 % 4]`:`${n}[(${i}) / 4][(${i}) % 4]`:u==="f16"?`${n}[${Math.floor(i/8)}][${Math.floor(i%8/4)}][${i%8%4}]`:`${n}[${Math.floor(i/4)}][${i%4}]`:s>1?`${n}[${i}]`:n,na=(n,i,s,u,d)=>{let f=typeof s=="number",c=f?s:s.length,g=[...new Array(c).keys()],v=c<2?"u32":c<=4?`vec${c}<u32>`:`array<u32, ${c}>`,b=lr(i,d),$=typeof b=="string"?b:b[1],k=typeof b=="string"?b:b[0],m={indices:v,value:$,storage:k,tensor:i},K=Ke=>typeof Ke=="string"?Ke:`${Ke}u`,G={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},X=f?"uniforms.":"",ne=`${X}${n}_shape`,ie=`${X}${n}_strides`,ee="";for(let Ke=0;Ke<c-1;Ke++)ee+=`
    let dim${Ke} = current / ${Kt(ie,Ke,c)};
    let rest${Ke} = current % ${Kt(ie,Ke,c)};
    indices[${Ke}] = dim${Ke};
    current = rest${Ke};
    `;ee+=`indices[${c-1}] = current;`;let de=c<2?"":`
  fn o2i_${n}(offset: u32) -> ${m.indices} {
    var indices: ${m.indices};
    var current = offset;
    ${ee}
    return indices;
  }`,he=Ke=>(G.offsetToIndices=!0,c<2?Ke:`o2i_${n}(${Ke})`),_e=[];if(c>=2)for(let Ke=c-1;Ke>=0;Ke--)_e.push(`${Kt(ie,Ke,c)} * (indices[${Ke}])`);let Fe=c<2?"":`
  fn i2o_${n}(indices: ${m.indices}) -> u32 {
    return ${_e.join("+")};
  }`,De=Ke=>(G.indicesToOffset=!0,c<2?Ke:`i2o_${n}(${Ke})`),st=(...Ke)=>c===0?"0u":`${m.indices}(${Ke.map(K).join(",")})`,Lt=(Ke,kt)=>c<2?`${Ke}`:`${Kt(Ke,kt,c)}`,jt=(Ke,kt,ln)=>c<2?`${Ke}=${ln};`:`${Kt(Ke,kt,c)}=${ln};`,pn={},un=(Ke,kt)=>{G.broadcastedIndicesToOffset=!0;let ln=`${kt.name}broadcastedIndicesTo${n}Offset`;if(ln in pn)return`${ln}(${Ke})`;let Gn=[];for(let xr=c-1;xr>=0;xr--){let Sr=kt.indicesGet("outputIndices",xr+kt.rank-c);Gn.push(`${Lt(ie,xr)} * (${Sr} % ${Lt(ne,xr)})`)}return pn[ln]=`fn ${ln}(outputIndices: ${kt.type.indices}) -> u32 {
             return ${Gn.length>0?Gn.join("+"):"0u"};
           }`,`${ln}(${Ke})`},Jt=(Ke,kt)=>(()=>{if(m.storage===m.value)return`${n}[${Ke}]=${kt};`;if(m.storage==="vec2<u32>"&&m.value==="i32")return`${n}[${Ke}]=vec2<u32>(u32(${kt}), select(0u, 0xFFFFFFFFu, ${kt} < 0));`;if(m.storage==="vec2<u32>"&&m.value==="u32")return`${n}[${Ke}]=vec2<u32>(u32(${kt}), 0u);`;if(m.storage==="u32"&&m.value==="vec4<bool>")return`${n}[${Ke}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${kt}));`;throw new Error(`not supported combination of storage type ${m.storage} and value type ${m.value} yet`)})(),In=Ke=>(()=>{if(m.storage===m.value)return`${n}[${Ke}]`;if(m.storage==="vec2<u32>"&&m.value==="i32")return`i32(${n}[${Ke}].x)`;if(m.storage==="vec2<u32>"&&m.value==="u32")return`u32(${n}[${Ke}].x)`;if(m.storage==="u32"&&m.value==="vec4<bool>")return`vec4<bool>(bool(${n}[${Ke}] & 0xFFu), bool(${n}[${Ke}] & 0xFF00u), bool(${n}[${Ke}] & 0xFF0000u), bool(${n}[${Ke}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${m.storage} and value type ${m.value} yet`)})(),Yn=c<2?"":`
  fn get_${n}ByIndices(indices: ${m.indices}) -> ${$} {
    return ${In(`i2o_${n}(indices)`)};
  }`,wn=c<2?"":(()=>{let Ke=g.map(ln=>`d${ln}: u32`).join(", "),kt=g.map(ln=>`d${ln}`).join(", ");return`
  fn get_${n}(${Ke}) -> ${$} {
    return get_${n}ByIndices(${st(kt)});
  }`})(),Bn=(...Ke)=>{if(Ke.length!==c)throw new Error(`indices length must be ${c}`);let kt=Ke.map(K).join(",");return c===0?In("0u"):c===1?In(kt[0]):(G.get=!0,G.getByIndices=!0,G.indicesToOffset=!0,`get_${n}(${kt})`)},Qt=Ke=>c<2?In(Ke):(G.getByIndices=!0,G.indicesToOffset=!0,`get_${n}ByIndices(${Ke})`),tn=c<2?"":`
  fn set_${n}ByIndices(indices: ${m.indices}, value: ${$}) {
    ${Jt(`i2o_${n}(indices)`,"value")}
  }`,Pn=c<2?"":(()=>{let Ke=g.map(ln=>`d${ln}: u32`).join(", "),kt=g.map(ln=>`d${ln}`).join(", ");return`
  fn set_${n}(${Ke}, value: ${$}) {
    set_${n}ByIndices(${st(kt)}, value);
  }`})();return{impl:()=>{let Ke=[],kt=!1;return G.offsetToIndices&&(Ke.push(de),kt=!0),G.indicesToOffset&&(Ke.push(Fe),kt=!0),G.broadcastedIndicesToOffset&&(Object.values(pn).forEach(ln=>Ke.push(ln)),kt=!0),G.set&&(Ke.push(Pn),kt=!0),G.setByIndices&&(Ke.push(tn),kt=!0),G.get&&(Ke.push(wn),kt=!0),G.getByIndices&&(Ke.push(Yn),kt=!0),!f&&kt&&Ke.unshift(`const ${ne} = ${m.indices}(${s.join(",")});`,`const ${ie} = ${m.indices}(${Ae.computeStrides(s).join(",")});`),Ke.join(`
`)},type:m,offsetToIndices:he,indicesToOffset:De,broadcastedIndicesToOffset:un,indices:st,indicesGet:Lt,indicesSet:jt,set:(...Ke)=>{if(Ke.length!==c+1)throw new Error(`indices length must be ${c}`);let kt=Ke[c];if(typeof kt!="string")throw new Error("value must be string");let ln=Ke.slice(0,c).map(K).join(",");return c===0?Jt("0u",kt):c===1?Jt(ln[0],kt):(G.set=!0,G.setByIndices=!0,G.indicesToOffset=!0,`set_${n}(${ln}, ${kt})`)},setByOffset:Jt,setByIndices:(Ke,kt)=>c<2?Jt(Ke,kt):(G.setByIndices=!0,G.indicesToOffset=!0,`set_${n}ByIndices(${Ke}, ${kt});`),get:Bn,getByOffset:In,getByIndices:Qt,usage:u,name:n,strides:ie,shape:ne,rank:c}},ot=(n,i,s,u=1)=>na(n,i,s,"input",u),Yt=(n,i,s,u=1)=>na(n,i,s,"output",u),qa=(n,i,s,u=1)=>na(n,i,s,"internal",u),Ha=class{constructor(n,i){this.normalizedDispatchGroup=n,this.limits=i,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(n){return`if (global_idx >= ${typeof n=="number"?`${n}u`:n}) { return; }`}mainStart(n=Ir){let i=typeof n=="number"?n:n[0],s=typeof n=="number"?1:n[1],u=typeof n=="number"?1:n[2];if(i>this.limits.maxComputeWorkgroupSizeX||s>this.limits.maxComputeWorkgroupSizeY||u>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${i}, ${s}, ${u}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(i*s*u>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${i}, ${s}, ${u}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let d=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,f=d?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,c=d?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${i*s*u}u + local_idx;`;return`@compute @workgroup_size(${i}, ${s}, ${u})
  fn main(${f}) {
    ${c}
  `}appendVariableUniforms(n){n.rank!==0&&(n.shape.startsWith("uniforms.")&&this.uniforms.push({name:n.shape.replace("uniforms.",""),type:"u32",length:n.rank}),n.strides.startsWith("uniforms.")&&this.uniforms.push({name:n.strides.replace("uniforms.",""),type:"u32",length:n.rank}))}declareVariable(n,i){if(n.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(n),this.appendVariableUniforms(n);let s=n.usage==="input"?"read":"read_write",u=n.type.storage;return`@group(0) @binding(${i}) var<storage, ${s}> ${n.name}: array<${u}>;`}declareVariables(...n){return n.map(i=>this.declareVariable(i,this.variableIndex++)).join(`
`)}registerInternalVariable(n){if(n.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(n),this.appendVariableUniforms(n)}registerInternalVariables(...n){return n.forEach(i=>this.registerInternalVariable(i)),this}registerUniform(n,i,s=1){return this.uniforms.push({name:n,type:i,length:s}),this}registerUniforms(n){return this.uniforms=this.uniforms.concat(n),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let n=[];for(let{name:i,type:s,length:u}of this.uniforms)if(u&&u>4)s==="f16"?n.push(`@align(16) ${i}:array<mat2x4<${s}>, ${Math.ceil(u/8)}>`):n.push(`${i}:array<vec4<${s}>, ${Math.ceil(u/4)}>`);else{let d=u==null||u===1?s:`vec${u}<${s}>`;n.push(`${i}:${d}`)}return`
      struct Uniforms { ${n.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(n=>n.impl()).join(`
`)+this.internalVariables.map(n=>n.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let n=i=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(i)];return this.uniforms.map(i=>[n(i.type),i.length??1])}},dc=(n,i)=>new Ha(n,i),Wo=(n,i)=>{let s=n.length,u=[];for(let d=0;d<s;d++){let f=s-1-d,c=n[f]||1;(i[i.length-1-d]||1)>1&&c===1&&u.unshift(f)}return u}}),pc,Ka,Mo,fc,Eh,Zr,kh,hc,Bi=_(()=>{nn(),Zt(),Ln(),yn(),pc=n=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.")},Ka=(n,i)=>i&&i.length!==n?[...new Array(n).keys()].reverse():i,Mo=(n,i)=>Ae.sortBasedOnPerm(n,Ka(n.length,i)),fc=(n,i,s,u)=>{let d=`fn perm(i: ${u.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`;for(let f=0;f<i;++f)d+=s.indicesSet("a",n[f],`i[${f}]`);return d+="return a;}"},Eh=(n,i)=>{let s=[],u=[];for(let d=0;d<n.length;++d)n[d]!==1&&s.push(n[d]),n[i[d]]!==1&&u.push(i[d]);return{newShape:s,newPerm:u}},Zr=(n,i)=>{let s=n.dataType,u=n.dims.length,d=Ka(u,i),f=Mo(n.dims,d),{newShape:c,newPerm:g}=Eh(n.dims,d),v=Ae.areEqual(g,[2,3,1]),b=Ae.areEqual(g,[3,1,2]),$=c.length===2&&g[0]>g[1]||v||b,k=$?c:n.dims,m=f;$&&(k=v?[c[0],c[1]*c[2]]:b?[c[0]*c[1],c[2]]:c,m=[k[1],k[0]]);let K=ot("a",s,k.length),G=Yt("output",s,m.length),X=16,ne;return $?ne=ie=>`
  ${ie.registerUniform("output_size","u32").declareVariables(K,G)}
  var<workgroup> tile : array<array<${G.type.value}, ${X+1}>, ${X}>;
  ${ie.mainStart([X,X,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${X} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${X}u + local_id.x;
    let input_row = workgroup_id_x * ${X}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${K.getByIndices(`${K.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${X}u + local_id.x;
    let output_row = workgroup_id_y * ${X}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${G.setByIndices(`${G.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`:ne=ie=>`
  ${ie.registerUniform("output_size","u32").declareVariables(K,G)}

  ${fc(d,u,K,G)}

  ${ie.mainStart()}
    ${ie.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${G.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${G.setByOffset("global_idx",K.getByIndices("aIndices"))}
  }`,{name:$?"TransposeShared":"Transpose",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>{let ie=Ae.size(f);return{outputs:[{dims:f,dataType:n.dataType}],dispatchGroup:$?{x:Math.ceil(m[1]/X),y:Math.ceil(m[0]/X)}:{x:Math.ceil(ie/64)},programUniforms:[{type:12,data:ie},...Ft(k,m)]}},getShaderSource:ne}},kh=(n,i)=>{pc(n.inputs),n.compute(Zr(n.inputs[0],i.perm))},hc=n=>fn({perm:n.perm})}),mc,gc,_c,yc,wc,Xa,vc,bc,Qa,Mc,gi,Ya,xc,Tc,Ja,Sc,Ec,Za,kc,Cc,el,Ch=_(()=>{nn(),Zt(),yn(),cl(),Bi(),mc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},gc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},_c={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},yc={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},wc=(n,i)=>{let s=[];for(let u=i-n;u<i;++u)s.push(u);return s},Xa=(n,i)=>{let s=[],u=n.length;for(let f=0;f<u;f++)i.indexOf(f)===-1&&s.push(n[f]);let d=i.map(f=>n[f]);return[s,d]},vc=(n,i)=>{let s=n.length+i.length,u=[],d=0;for(let f=0;f<s;f++)i.indexOf(f)===-1?u.push(n[d++]):u.push(1);return u},bc=(n,i)=>{for(let s=0;s<n.length;++s)if(n[n.length-s-1]!==i-1-s)return!1;return!0},Qa=(n,i)=>{let s=[];if(!bc(n,i)){for(let u=0;u<i;++u)n.indexOf(u)===-1&&s.push(u);n.forEach(u=>s.push(u))}return s},Mc=(n,i,s,u,d,f,c)=>{let g=s[0].dims,v=Ae.size(f),b=Ae.size(c),$=ot("_A",s[0].dataType,g),k=Yt("output",d,f),m=32,K=`
          var<workgroup> aBestValues : array<f32, ${m}>;
       `;return{name:n,shaderCache:i,getShaderSource:G=>`
        ${G.registerUniform("reduceSize","u32").declareVariables($,k)}
        ${K}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${G.mainStart(m)}

          let outputIndex = global_idx / ${m};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${_c[u]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${m}) {
           let candidate = f32(${$.getByOffset("offset + k")});
           bestValue = ${mc[u]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${m}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${gc[u]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${k.setByOffset("outputIndex",`${u==="mean"?`${k.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${k.type.storage}(${yc[u]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:f,dataType:d}],dispatchGroup:{x:v},programUniforms:[{type:12,data:b}]})}},gi=(n,i,s,u)=>{let d=n.inputs.length===1?s:nl(n.inputs,s),f=d.axes;f.length===0&&!d.noopWithEmptyAxes&&(f=n.inputs[0].dims.map((K,G)=>G));let c=Ae.normalizeAxes(f,n.inputs[0].dims.length),g=c,v=n.inputs[0],b=Qa(g,n.inputs[0].dims.length);b.length>0&&(v=n.compute(Zr(n.inputs[0],b),{inputs:[0],outputs:[-1]})[0],g=wc(g.length,v.dims.length));let[$,k]=Xa(v.dims,g),m=$;d.keepDims&&(m=vc($,c)),n.compute(Mc(i,{hint:d.cacheKey,inputDependencies:["type"]},[v],u,n.inputs[0].dataType,m,k),{inputs:[v]})},Ya=(n,i)=>{gi(n,"ReduceMeanShared",i,"mean")},xc=(n,i)=>{gi(n,"ReduceL1Shared",i,"l1")},Tc=(n,i)=>{gi(n,"ReduceL2Shared",i,"l2")},Ja=(n,i)=>{gi(n,"ReduceLogSumExpShared",i,"logSumExp")},Sc=(n,i)=>{gi(n,"ReduceMaxShared",i,"max")},Ec=(n,i)=>{gi(n,"ReduceMinShared",i,"min")},Za=(n,i)=>{gi(n,"ReduceProdShared",i,"prod")},kc=(n,i)=>{gi(n,"ReduceSumShared",i,"sum")},Cc=(n,i)=>{gi(n,"ReduceSumSquareShared",i,"sumSquare")},el=(n,i)=>{gi(n,"ReduceLogSumShared",i,"logSum")}}),_i,tl,ra,nl,ai,Pc,$c,rl,Ac,Fc,il,Ic,Oc,ol,Dc,yi,sl,zc,Lc,al,Rc,Bc,ll,Nc,Uc,ul,cl=_(()=>{nn(),Zt(),Ln(),yn(),Ch(),_i=n=>{if(!n||n.length===0||n.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(n.length===2&&n[1].dims.length!==1)throw new Error("Invalid axes input dims.")},tl=n=>["","",`var value = ${n.getByIndices("input_indices")};`,""],ra=(n,i,s,u,d,f,c=!1,g=!1)=>{let v=[],b=s[0].dims,$=b.length,k=Ae.normalizeAxes(d,$),m=!g&&k.length===0;b.forEach((X,ne)=>{m||k.indexOf(ne)>=0?c&&v.push(1):v.push(X)});let K=v.length,G=Ae.size(v);return{name:n,shaderCache:i,getShaderSource:X=>{let ne=[],ie=ot("_A",s[0].dataType,$),ee=Yt("output",f,K),de=u(ie,ee,k),he=de[2];for(let _e=0,Fe=0;_e<$;_e++)m||k.indexOf(_e)>=0?(c&&Fe++,he=`for(var j${_e}: u32 = 0; j${_e} < ${b[_e]}; j${_e}++) {
                  ${de[2].includes("last_index")?`let last_index = j${_e};`:""}
                  ${ie.indicesSet("input_indices",_e,`j${_e}`)}
                  ${he}
                }`):(ne.push(`${ie.indicesSet("input_indices",_e,ee.indicesGet("output_indices",Fe))};`),Fe++);return`

        ${X.registerUniform("output_size","u32").declareVariables(ie,ee)}

        ${X.mainStart()}
          ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${ie.type.indices};
          let output_indices = ${ee.offsetToIndices("global_idx")};

          ${ne.join(`
`)}
          ${de[0]}       // init ops for reduce max/min
          ${de[1]}
          ${he}
          ${de[3]}
          ${de.length===4?ee.setByOffset("global_idx","value"):de.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:v,dataType:f}],dispatchGroup:{x:Math.ceil(G/64)},programUniforms:[{type:12,data:G},...Ft(b,v)]})}},nl=(n,i)=>{let s=[];return n[1].dims[0]>0&&n[1].getBigInt64Array().forEach(u=>s.push(Number(u))),fn({axes:s,keepDims:i.keepDims,noopWithEmptyAxes:i.noopWithEmptyAxes})},ai=(n,i,s,u)=>{let d=n.inputs,f=d.length===1?s:nl(d,s);n.compute(ra(i,{hint:f.cacheKey,inputDependencies:["rank"]},[d[0]],f.noopWithEmptyAxes&&f.axes.length===0?tl:u,f.axes,d[0].dataType,f.keepDims,f.noopWithEmptyAxes),{inputs:[0]})},Pc=(n,i)=>{_i(n.inputs),ai(n,"ReduceLogSum",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,"value = log(value);"])},$c=(n,i)=>{_i(n.inputs),ai(n,"ReduceL1",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += abs(${s.getByIndices("input_indices")});`,""])},rl=(n,i)=>{_i(n.inputs),ai(n,"ReduceL2",i,(s,u)=>[`var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Ac=(n,i)=>{_i(n.inputs),ai(n,"ReduceLogSumExp",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += exp(${s.getByIndices("input_indices")});`,"value = log(value);"])},Fc=(n,i)=>{_i(n.inputs),ai(n,"ReduceMax",i,(s,u,d)=>{let f=[];for(let c=0;c<s.rank;c++)(d.indexOf(c)>=0||d.length===0)&&f.push(s.indicesSet("input_indices",c,0));return[`${f.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = max(value, ${s.getByIndices("input_indices")});`,""]})},il=(n,i)=>{_i(n.inputs),ai(n,"ReduceMean",i,(s,u,d)=>{let f=1;for(let c=0;c<s.rank;c++)(d.indexOf(c)>=0||d.length===0)&&(f*=n.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${s.getByIndices("input_indices")});`,`let value = ${u.type.value}(sum / ${f});`]})},Ic=(n,i)=>{_i(n.inputs),ai(n,"ReduceMin",i,(s,u,d)=>{let f=[];for(let c=0;c<s.rank;c++)(d.indexOf(c)>=0||d.length===0)&&f.push(`input_indices[${c}] = 0;`);return[`${f.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = min(value, ${s.getByIndices("input_indices")});`,""]})},Oc=(n,i)=>{_i(n.inputs),ai(n,"ReduceProd",i,(s,u)=>[`var value = ${u.type.storage}(1);`,"",`value *= ${s.getByIndices("input_indices")};`,""])},ol=(n,i)=>{_i(n.inputs),ai(n,"ReduceSum",i,(s,u)=>[`var value = ${u.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,""])},Dc=(n,i)=>{_i(n.inputs),ai(n,"ReduceSumSquare",i,(s,u)=>[`var t = ${u.type.value}(0); var value = ${u.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += t * t;`,""])},yi=(n,i,s)=>{if(i.length===0)return s;let u=1,d=1;for(let f=0;f<i.length;f++)i.indexOf(f)===-1?u*=n[f]:d*=n[f];return d<32&&u>1024},sl=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?il(n,i):Ya(n,i)},zc=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?$c(n,i):xc(n,i)},Lc=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?rl(n,i):Tc(n,i)},al=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Ac(n,i):Ja(n,i)},Rc=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Fc(n,i):Sc(n,i)},Bc=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Ic(n,i):Ec(n,i)},ll=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Oc(n,i):Za(n,i)},Nc=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?ol(n,i):kc(n,i)},Uc=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Dc(n,i):Cc(n,i)},ul=(n,i)=>{yi(n.inputs[0].dims,i.axes,i.noopWithEmptyAxes)?Pc(n,i):el(n,i)}}),dl,pl,jc,fl,Vc=_(()=>{nn(),Ln(),cl(),dl=n=>{if(!n||n.length===0||n.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(n[0].dataType!==1)throw new Error("Invalid input type.")},pl=(n,i)=>{dl(n.inputs);let s=(u,d,f)=>{let c=[];for(let g=0;g<u.rank;g++)(f.indexOf(g)>=0||f.length===0)&&c.push(`input_indices[${g}] = 0;`);return[`${c.join(`
`)}`,`var value = ${u.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${u.getByIndices("input_indices")} ${i.selectLastIndex>0?"<=":"<"} value) {
         value = ${u.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};n.compute(ra("ArgMin",{hint:i.cacheKey,inputDependencies:["rank"]},[n.inputs[0]],s,[i.axis],7,i.keepDims),{inputs:[0]})},jc=(n,i)=>{dl(n.inputs);let s=(u,d,f)=>{let c=[];for(let g=0;g<u.rank;g++)(f.indexOf(g)>=0||f.length===0)&&c.push(`input_indices[${g}] = 0;`);return[`${c.join(`
`)}`,`var value = ${u.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${u.getByIndices("input_indices")} ${i.selectLastIndex>0?">=":">"} value) {
         value = ${u.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};n.compute(ra("argMax",{hint:i.cacheKey,inputDependencies:["rank"]},[n.inputs[0]],s,[i.axis],7,i.keepDims),{inputs:[0]})},fl=n=>fn(n)}),Wc,ia,hl,Gc,qc,Go,Hc,Kc,oa=_(()=>{nn(),Zt(),ve(),yn(),Wc=(n,i)=>{let s=n[0],u=n[1],d=n[2],f=n[3],c=n[4],g=n[5];if(c&&g)throw new Error("Attention cannot have both past and attention_bias");if(s.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let v=s.dims[0],b=s.dims[1],$=s.dims[2];if(d.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(u.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(u.dims[0]!==$)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(d.dims[0]!==u.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let k=d.dims[0]/3,m=k,K=m;if(i.qkvHiddenSizes.length>0){if(i.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let de of i.qkvHiddenSizes)if(de%i.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");k=i.qkvHiddenSizes[0],m=i.qkvHiddenSizes[1],K=i.qkvHiddenSizes[2]}let G=b;if(k!==m)throw new Error("qkv_hidden_sizes first element should be same as the second");if(d.dims[0]!==k+m+K)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let X=0;if(c){if(m!==K)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(c.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(c.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(c.dims[1]!==v)throw new Error('Input "past" second dimension must be batch_size');if(c.dims[2]!==i.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(c.dims[4]!==m/i.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');i.pastPresentShareBuffer||(X=c.dims[3])}let ne=G+X,ie=-1,ee=0;if(f)throw new Error("Mask not supported");if(c)throw new Error("past is not supported");if(g){if(g.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(g.dims[0]!==v||g.dims[1]!==i.numHeads||g.dims[2]!==b||g.dims[3]!==ne)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:v,sequenceLength:b,pastSequenceLength:X,kvSequenceLength:G,totalSequenceLength:ne,maxSequenceLength:ie,inputHiddenSize:$,hiddenSize:k,vHiddenSize:K,headSize:Math.floor(k/i.numHeads),vHeadSize:Math.floor(K/i.numHeads),numHeads:i.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:i.maskFilterValue,maskType:ee,scale:i.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ia=(n,i,s)=>i&&n?`
      let total_sequence_length_input = u32(${i.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${n==null?void 0:n.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${s?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,hl=(n,i,s,u,d,f,c,g)=>{let v=Mn(c?1:f),b=64,$=f/v;$<b&&(b=32);let k=Math.ceil(f/v/b),m=[{type:12,data:i},{type:12,data:s},{type:12,data:u},{type:12,data:d},{type:12,data:$},{type:12,data:k}],K=vn(n.dataType,v),G=Nn(1,v),X=["type"];c&&X.push("type"),g&&X.push("type");let ne=ie=>{let ee=Yt("x",n.dataType,n.dims,v),de=[ee],he=c?ot("seq_lens",c.dataType,c.dims):void 0;he&&de.push(he);let _e=g?ot("total_sequence_length_input",g.dataType,g.dims):void 0;_e&&de.push(_e);let Fe=Nn(n.dataType),De=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${b}>;
  var<workgroup> thread_sum: array<f32, ${b}>;
  ${ie.registerUniforms(De).declareVariables(...de)}
  ${ie.mainStart([b,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${ia(he,_e,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${b}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${c?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${G}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${G}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(v){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${v}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${b}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${G}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${G}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(v){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${v}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${b}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${ee.type.value}(${Fe}(1.0) / ${Fe}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${G}(x[offset + i]);
        x[offset + i] = ${ee.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${c?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${ee.type.value}(${Fe}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${b};${K};${v}`,inputDependencies:X},getShaderSource:ne,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(f/b),y:d,z:i*s},programUniforms:m})}},Gc=(n,i,s,u,d,f,c,g,v)=>{let b=c+f.kvSequenceLength,$=[f.batchSize,f.numHeads,f.sequenceLength,b],k=n>1&&u,m=f.kvNumHeads?f.kvNumHeads:f.numHeads,K=k?[f.batchSize,m,b,f.headSize]:void 0,G=f.nReps?f.nReps:1,X=f.scale===0?1/Math.sqrt(f.headSize):f.scale,ne=Mn(f.headSize),ie=f.headSize/ne,ee=12,de={x:Math.ceil(b/ee),y:Math.ceil(f.sequenceLength/ee),z:f.batchSize*f.numHeads},he=[{type:12,data:f.sequenceLength},{type:12,data:ie},{type:12,data:b},{type:12,data:f.numHeads},{type:12,data:f.headSize},{type:1,data:X},{type:12,data:c},{type:12,data:f.kvSequenceLength},{type:12,data:G}],_e=k&&u&&Ae.size(u.dims)>0,Fe=["type","type"];_e&&Fe.push("type"),d&&Fe.push("type"),g&&Fe.push("type"),v&&Fe.push("type");let De=[{dims:$,dataType:i.dataType,gpuDataType:0}];k&&De.push({dims:K,dataType:i.dataType,gpuDataType:0});let st=Lt=>{let jt=ot("q",i.dataType,i.dims,ne),pn=ot("key",s.dataType,s.dims,ne),un=[jt,pn];if(_e){let tn=ot("past_key",u.dataType,u.dims,ne);un.push(tn)}d&&un.push(ot("attention_bias",d.dataType,d.dims));let Jt=g?ot("seq_lens",g.dataType,g.dims):void 0;Jt&&un.push(Jt);let In=v?ot("total_sequence_length_input",v.dataType,v.dims):void 0;In&&un.push(In);let Yn=Yt("output",i.dataType,$),wn=[Yn];k&&wn.push(Yt("present_key",i.dataType,K,ne));let Bn=Nn(1,ne),Qt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${ee}u;

  var<workgroup> tileQ: array<${jt.type.storage}, ${ee*ee}>;
  var<workgroup> tileK: array<${jt.type.storage}, ${ee*ee}>;
  ${Lt.registerUniforms(Qt).declareVariables(...un,...wn)}
  ${Lt.mainStart([ee,ee,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${G===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${G===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${ia(Jt,In,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${_e&&k?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${k?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${Bn}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${_e&&k?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${k?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${Bn}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(ne){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${ne}`)}})()};
        output[outputIdx] = ${Yn.type.value} (sum * uniforms.alpha) + ${d?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${ne};${d!==void 0};${u!==void 0};${n}`,inputDependencies:Fe},getRunData:()=>({outputs:De,dispatchGroup:de,programUniforms:he}),getShaderSource:st}},qc=(n,i,s,u,d,f,c=void 0,g=void 0)=>{let v=f+d.kvSequenceLength,b=d.nReps?d.nReps:1,$=d.vHiddenSize*b,k=n>1&&u,m=d.kvNumHeads?d.kvNumHeads:d.numHeads,K=k?[d.batchSize,m,v,d.headSize]:void 0,G=[d.batchSize,d.sequenceLength,$],X=12,ne={x:Math.ceil(d.vHeadSize/X),y:Math.ceil(d.sequenceLength/X),z:d.batchSize*d.numHeads},ie=[{type:12,data:d.sequenceLength},{type:12,data:v},{type:12,data:d.vHeadSize},{type:12,data:d.numHeads},{type:12,data:d.headSize},{type:12,data:$},{type:12,data:f},{type:12,data:d.kvSequenceLength},{type:12,data:b}],ee=k&&u&&Ae.size(u.dims)>0,de=["type","type"];ee&&de.push("type"),c&&de.push("type"),g&&de.push("type");let he=[{dims:G,dataType:i.dataType,gpuDataType:0}];k&&he.push({dims:K,dataType:i.dataType,gpuDataType:0});let _e=Fe=>{let De=ot("probs",i.dataType,i.dims),st=ot("v",s.dataType,s.dims),Lt=[De,st];ee&&Lt.push(ot("past_value",u.dataType,u.dims));let jt=c?ot("seq_lens",c.dataType,c.dims):void 0;c&&Lt.push(jt);let pn=g?ot("total_sequence_length_input",g.dataType,g.dims):void 0;g&&Lt.push(pn);let un=[Yt("output",i.dataType,G)];k&&un.push(Yt("present_value",i.dataType,K));let Jt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${X}u;
  var<workgroup> tileQ: array<${De.type.value}, ${X*X}>;
  var<workgroup> tileV: array<${De.type.value}, ${X*X}>;
  ${Fe.registerUniforms(Jt).declareVariables(...Lt,...un)}
  ${Fe.mainStart([X,X,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${b===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${b===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${ia(jt,pn,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${ee&&k?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${k?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${De.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${ee&&k?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${k?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${u!==void 0};${n}`,inputDependencies:de},getRunData:()=>({outputs:he,dispatchGroup:ne,programUniforms:ie}),getShaderSource:_e}},Go=(n,i,s,u,d,f,c,g,v,b,$=void 0,k=void 0)=>{let m=Math.min(n.outputCount,1+(c?1:0)+(g?1:0)),K=m>1?b.pastSequenceLength:0,G=K+b.kvSequenceLength,X=v&&Ae.size(v.dims)>0?v:void 0,ne=[i,s];m>1&&c&&Ae.size(c.dims)>0&&ne.push(c),X&&ne.push(X),$&&ne.push($),k&&ne.push(k);let ie=n.compute(Gc(m,i,s,c,X,b,K,$,k),{inputs:ne,outputs:m>1?[-1,1]:[-1]})[0];n.compute(hl(ie,b.batchSize,b.numHeads,K,b.sequenceLength,G,$,k),{inputs:$&&k?[ie,$,k]:[ie],outputs:[]});let ee=[ie,u];m>1&&g&&Ae.size(g.dims)>0&&ee.push(g),$&&ee.push($),k&&ee.push(k),n.compute(qc(m,ie,u,g,b,K,$,k),{inputs:ee,outputs:m>1?[0,2]:[0]})},Hc=(n,i)=>{let s=[i.batchSize,i.numHeads,i.sequenceLength,i.headSize],u=i.sequenceLength,d=i.inputHiddenSize,f=i.headSize,c=12,g={x:Math.ceil(i.headSize/c),y:Math.ceil(i.sequenceLength/c),z:i.batchSize*i.numHeads},v=[n.inputs[0],n.inputs[1],n.inputs[2]],b=[{type:12,data:u},{type:12,data:d},{type:12,data:f},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:12,data:i.hiddenSize},{type:12,data:i.hiddenSize+i.hiddenSize+i.vHiddenSize}],$=k=>{let m=Yt("output_q",v[0].dataType,s),K=Yt("output_k",v[0].dataType,s),G=Yt("output_v",v[0].dataType,s),X=ot("input",v[0].dataType,v[0].dims),ne=ot("weight",v[1].dataType,v[1].dims),ie=ot("bias",v[2].dataType,v[2].dims),ee=X.type.storage,de=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${c}u;
  var<workgroup> tileInput: array<${ee}, ${c*c}>;
  var<workgroup> tileWeightQ: array<${ee}, ${c*c}>;
  var<workgroup> tileWeightK: array<${ee}, ${c*c}>;
  var<workgroup> tileWeightV: array<${ee}, ${c*c}>;
  ${k.registerUniforms(de).declareVariables(X,ne,ie,m,K,G)}
  ${k.mainStart([c,c,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${ee}(0);
    var valueK = ${ee}(0);
    var valueV = ${ee}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return n.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:n.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:n.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:n.inputs[0].dataType,gpuDataType:0}],dispatchGroup:g,programUniforms:b}),getShaderSource:$},{inputs:v,outputs:[-1,-1,-1]})},Kc=(n,i)=>{let s=Wc(n.inputs,i),[u,d,f]=Hc(n,s);return Go(n,u,d,f,n.inputs[4],void 0,void 0,void 0,n.inputs[5],s)}}),Xc,Qc,ml,Yc,Ph=_(()=>{Dt(),nn(),Zt(),Ln(),yn(),Xc=(n,i)=>{if(!n||n.length!==5)throw new Error("BatchNormalization requires 5 inputs");let s=(u,d,f)=>{let c=d.length;if(c!==u.length)throw new Error(`${f}: num dimensions != ${c}`);d.forEach((g,v)=>{if(g!==u[v])throw new Error(`${f}: dim[${v}] do not match`)})};if(n[0].dims.length>1){let u=i.format==="NHWC"?i.spatial?n[0].dims.slice(-1):n[0].dims.slice(-1).concat(n[0].dims.slice(1,n[0].dims.length-1)):n[0].dims.slice(1,i.spatial?2:void 0);s(n[1].dims,u,"Invalid input scale"),s(n[2].dims,u,"Invalid input B"),s(n[3].dims,u,"Invalid input mean"),s(n[4].dims,u,"Invalid input var")}else s(n[1].dims,[1],"Invalid input scale"),s(n[2].dims,[1],"Invalid input B"),s(n[3].dims,[1],"Invalid input mean"),s(n[4].dims,[1],"Invalid input var")},Qc=(n,i)=>{let{epsilon:s,spatial:u,format:d}=i,f=n[0].dims,c=u?Mn(f[f.length-1]):1,g=d==="NHWC"&&f.length>1?c:1,v=Ae.size(f)/c,b=u,$=b?f.length:f,k=ot("x",n[0].dataType,n[0].dims,c),m=ot("scale",n[1].dataType,n[1].dims,g),K=ot("bias",n[2].dataType,n[2].dims,g),G=ot("inputMean",n[3].dataType,n[3].dims,g),X=ot("inputVar",n[4].dataType,n[4].dims,g),ne=Yt("y",n[0].dataType,$,c),ie=()=>{let de="";if(u)de=`let cOffset = ${f.length===1?"0u":d==="NHWC"?`outputIndices[${f.length-1}] / ${c}`:"outputIndices[1]"};`;else if(d==="NCHW")de=`
            ${ne.indicesSet("outputIndices","0","0")}
            let cOffset = ${ne.indicesToOffset("outputIndices")};`;else{de=`var cIndices = ${m.type.indices}(0);
                       cIndices[0] = outputIndices[${f.length-1}];`;for(let he=1;he<m.rank;he++)de+=`cIndices[${he}] = outputIndices[${he}];`;de+=`let cOffset = ${m.indicesToOffset("cIndices")};`}return de},ee=de=>`
  const epsilon = ${s};
  ${de.registerUniform("outputSize","u32").declareVariables(k,m,K,G,X,ne)}
  ${de.mainStart()}
  ${de.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${ne.offsetToIndices(`global_idx * ${c}`)};
    ${ie()}
    let scale = ${m.getByOffset("cOffset")};
    let bias = ${K.getByOffset("cOffset")};
    let inputMean = ${G.getByOffset("cOffset")};
    let inputVar = ${X.getByOffset("cOffset")};
    let x = ${k.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${ne.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${i.epsilon}_${i.format}_${u}_${c}`,inputDependencies:b?["rank","type","type","type","type"]:void 0},getShaderSource:ee,getRunData:()=>({outputs:[{dims:n[0].dims,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:b?[{type:12,data:v},...Ft(f)]:[{type:12,data:v}]})}},ml=n=>fn(n),Yc=(n,i)=>{let{inputs:s,outputCount:u}=n,d=ml({...i,outputCount:u});if(L.webgpu.validateInputContent&&Xc(s,d),i.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");n.compute(Qc(s,d))}}),gl,Jc,Zc,$h=_(()=>{Zt(),yn(),gl=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(n[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Jc=n=>{let i=n[0].dims,s=n[0].dims[2],u=Ae.size(i)/4,d=n[0].dataType,f=ot("input",d,i,4),c=ot("bias",d,[s],4),g=ot("residual",d,i,4),v=Yt("output",d,i,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:b=>`
  const channels = ${s}u / 4;
  ${b.declareVariables(f,c,g,v)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes(u)}
    let value = ${f.getByOffset("global_idx")}
      + ${c.getByOffset("global_idx % channels")} + ${g.getByOffset("global_idx")};
    ${v.setByOffset("global_idx","value")}
  }`}},Zc=n=>{gl(n.inputs),n.compute(Jc(n.inputs))}}),ed,kn,td,nd,rd,id,_l,od,sd,ad,ld,yl,ud,cd,wl,dd,bs,vl,sa,pd,bl,fd,hd,Ml,md,gd,aa,_d,yd,xl,Tl,wd,Sl,vd,bd,El,kl,Cl,Pl,Md,$l,xd,Td,Al,Sd,Fl=_(()=>{nn(),Zt(),Ln(),yn(),ed=(n,i,s,u,d,f,c)=>{let g=Math.ceil(i/4),v="";typeof d=="string"?v=`${d}(a)`:v=d("a");let b=ot("inputData",s,[g],4),$=Yt("outputData",u,[g],4),k=[{name:"vec_size",type:"u32"}];return c&&k.push(...c),`
      ${n.registerUniforms(k).declareVariables(b,$)}

  ${f??""}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${b.getByOffset("global_idx")};
    ${$.setByOffset("global_idx",v)}
  }`},kn=(n,i,s,u,d,f=n.dataType,c,g)=>{let v=[{type:12,data:Math.ceil(Ae.size(n.dims)/4)}];return c&&v.push(...c),{name:i,shaderCache:{hint:d,inputDependencies:["type"]},getShaderSource:b=>ed(b,Ae.size(n.dims),n.dataType,f,s,u,g),getRunData:b=>({outputs:[{dims:n.dims,dataType:f}],dispatchGroup:{x:Math.ceil(Ae.size(b[0].dims)/64/4)},programUniforms:v})}},td=n=>{n.compute(kn(n.inputs[0],"Abs","abs"))},nd=n=>{n.compute(kn(n.inputs[0],"Acos","acos"))},rd=n=>{n.compute(kn(n.inputs[0],"Acosh","acosh"))},id=n=>{n.compute(kn(n.inputs[0],"Asin","asin"))},_l=n=>{n.compute(kn(n.inputs[0],"Asinh","asinh"))},od=n=>{n.compute(kn(n.inputs[0],"Atan","atan"))},sd=n=>{n.compute(kn(n.inputs[0],"Atanh","atanh"))},ad=n=>fn(n),ld=(n,i)=>{let s;switch(i.to){case 10:s="vec4<f16>";break;case 1:s="vec4<f32>";break;case 12:s="vec4<u32>";break;case 6:s="vec4<i32>";break;case 9:s="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${i.to}`)}n.compute(kn(n.inputs[0],"Cast",s,void 0,i.cacheKey,i.to))},yl=n=>{let i,s,u=n.length>=2&&n[1].data!==0,d=n.length>=3&&n[2].data!==0;switch(n[0].dataType){case 1:i=u?n[1].getFloat32Array()[0]:-34028234663852886e22,s=d?n[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:i=u?n[1].getUint16Array()[0]:64511,s=d?n[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return fn({min:i,max:s})},ud=(n,i)=>{let s=i||yl(n.inputs),u=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"Clip",d=>`clamp(${d}, vec4<${u}>(uniforms.min), vec4<${u}>(uniforms.max))`,void 0,s.cacheKey,void 0,[{type:n.inputs[0].dataType,data:s.min},{type:n.inputs[0].dataType,data:s.max}],[{name:"min",type:u},{name:"max",type:u}]),{inputs:[0]})},cd=n=>{n.compute(kn(n.inputs[0],"Ceil","ceil"))},wl=n=>{n.compute(kn(n.inputs[0],"Cos","cos"))},dd=n=>{n.compute(kn(n.inputs[0],"Cosh","cosh"))},bs=n=>fn(n),vl=(n,i)=>{let s=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"Elu",u=>`elu_vf32(${u})`,`
  const elu_alpha_ = ${s}(${i.alpha});

  fn elu_f32(a: ${s}) -> ${s} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${s}>) -> vec4<${s}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,i.cacheKey))},sa=(n="f32")=>`
const r0: ${n} = 0.3275911;
const r1: ${n} = 0.254829592;
const r2: ${n} = -0.284496736;
const r3: ${n} = 1.421413741;
const r4: ${n} = -1.453152027;
const r5: ${n} = 1.061405429;

fn erf_vf32(v: vec4<${n}>) -> vec4<${n}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,pd=n=>{let i=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"Erf",s=>`erf_vf32(${s})`,sa(i)))},bl=n=>{n.compute(kn(n.inputs[0],"Exp","exp"))},fd=n=>{n.compute(kn(n.inputs[0],"Floor","floor"))},hd=n=>{let i=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"Gelu",s=>`0.5 * ${s} * (1.0 + erf_vf32(${s} * 0.7071067811865475))`,sa(i)))},Ml=(n,i)=>{let s=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"LeakyRelu",u=>`select(leaky_relu_alpha_ * ${u}, ${u}, ${u} >= vec4<${s}>(0.0))`,`const leaky_relu_alpha_ = ${s}(${i.alpha});`,i.cacheKey))},md=n=>{n.compute(kn(n.inputs[0],"Not",i=>`!${i}`))},gd=n=>{n.compute(kn(n.inputs[0],"Neg",i=>`-${i}`))},aa=n=>{n.compute(kn(n.inputs[0],"Reciprocal",i=>`1.0/${i}`))},_d=n=>{let i=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"Relu",s=>`select(vec4<${i}>(0.0), ${s}, ${s} > vec4<${i}>(0.0))`))},yd=n=>{n.compute(kn(n.inputs[0],"Sigmoid",i=>`(1.0 / (1.0 + exp(-${i})))`))},xl=n=>fn(n),Tl=(n,i)=>{let s=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"HardSigmoid",u=>`max(vec4<${s}>(0.0), min(vec4<${s}>(1.0), ${i.alpha} * ${u} + vec4<${s}>(${i.beta})))`,void 0,i.cacheKey))},wd=n=>{n.compute(kn(n.inputs[0],"Sin","sin"))},Sl=n=>{n.compute(kn(n.inputs[0],"Sinh","sinh"))},vd=n=>{n.compute(kn(n.inputs[0],"Sqrt","sqrt"))},bd=n=>{n.compute(kn(n.inputs[0],"Tan","tan"))},El=n=>`sign(${n}) * (1 - exp(-2 * abs(${n}))) / (1 + exp(-2 * abs(${n})))`,kl=n=>{n.compute(kn(n.inputs[0],"Tanh",El))},Cl=(n="f32")=>`
const fast_gelu_a: ${n} = 0.5;
const fast_gelu_b: ${n} = 0.7978845608028654;
const fast_gelu_c: ${n} = 0.035677408136300125;

fn tanh_v(v: vec4<${n}>) -> vec4<${n}> {
  return ${El("v")};
}
`,Pl=n=>`(fast_gelu_a + fast_gelu_a * tanh_v(${n} * (fast_gelu_c * ${n} * ${n} + fast_gelu_b))) * ${n}`,Md=n=>{let i=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"FastGelu",Pl,Cl(i),void 0,n.inputs[0].dataType))},$l=(n,i)=>{let s=Nn(n.inputs[0].dataType);return n.compute(kn(n.inputs[0],"ThresholdedRelu",u=>`select(vec4<${s}>(0.0), ${u}, ${u} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${s}>(${i.alpha});`,i.cacheKey)),0},xd=n=>{n.compute(kn(n.inputs[0],"Log","log"))},Td=(n,i)=>`
const alpha = vec4<${n}>(${i});
const one = ${n}(1.0);
const zero = ${n}(0.0);

fn quick_gelu_impl(x: vec4<${n}>) -> vec4<${n}> {
  let v = x *alpha;
  var x1 : vec4<${n}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Al=n=>`quick_gelu_impl(${n})`,Sd=(n,i)=>{let s=Nn(n.inputs[0].dataType);n.compute(kn(n.inputs[0],"QuickGelu",Al,Td(s,i.alpha),i.cacheKey,n.inputs[0].dataType))}}),Il,Ed,kd,Cd=_(()=>{Zt(),yn(),Fl(),Il=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(n[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ed=n=>{let i=n[0].dims.slice();i[2]=i[2]/2;let s=ot("input",n[0].dataType,n[0].dims,4),u=ot("bias",n[0].dataType,[n[0].dims[2]],4),d=Yt("output",n[0].dataType,i,4),f=Ae.size(i)/4,c=vn(n[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:g=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${n[0].dims[2]/4/2}u;

  ${g.declareVariables(s,u,d)}

  ${sa(c)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(f)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${d.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},kd=n=>{Il(n.inputs),n.compute(Ed(n.inputs))}}),Pd,$d,li,Ad,Fd,Ol,Id,Od,Dd,zd,la,Ld,Rd,Ah=_(()=>{nn(),Zt(),yn(),Pd=(n,i,s,u,d,f,c,g,v,b,$,k)=>{let m,K;typeof g=="string"?m=K=(ee,de)=>`${g}((${ee}),(${de}))`:typeof g=="function"?m=K=g:(m=g.scalar,K=g.vector);let G=Yt("outputData",$,u.length,4),X=ot("aData",v,i.length,4),ne=ot("bData",b,s.length,4),ie;if(d)if(f){let ee=Ae.size(i)===1,de=Ae.size(s)===1,he=i.length>0&&i[i.length-1]%4===0,_e=s.length>0&&s[s.length-1]%4===0;ee||de?ie=G.setByOffset("global_idx",K(ee?`${X.type.value}(${X.getByOffset("0")}.x)`:X.getByOffset("global_idx"),de?`${ne.type.value}(${ne.getByOffset("0")}.x)`:ne.getByOffset("global_idx"))):ie=`
            let outputIndices = ${G.offsetToIndices("global_idx * 4u")};
            let offsetA = ${X.broadcastedIndicesToOffset("outputIndices",G)};
            let offsetB = ${ne.broadcastedIndicesToOffset("outputIndices",G)};
            ${G.setByOffset("global_idx",K(c||he?X.getByOffset("offsetA / 4u"):`${X.type.value}(${X.getByOffset("offsetA / 4u")}[offsetA % 4u])`,c||_e?ne.getByOffset("offsetB / 4u"):`${ne.type.value}(${ne.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else ie=G.setByOffset("global_idx",K(X.getByOffset("global_idx"),ne.getByOffset("global_idx")));else{if(!f)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let ee=(de,he,_e="")=>{let Fe=`aData[indexA${he}][componentA${he}]`,De=`bData[indexB${he}][componentB${he}]`;return`
            let outputIndices${he} = ${G.offsetToIndices(`global_idx * 4u + ${he}u`)};
            let offsetA${he} = ${X.broadcastedIndicesToOffset(`outputIndices${he}`,G)};
            let offsetB${he} = ${ne.broadcastedIndicesToOffset(`outputIndices${he}`,G)};
            let indexA${he} = offsetA${he} / 4u;
            let indexB${he} = offsetB${he} / 4u;
            let componentA${he} = offsetA${he} % 4u;
            let componentB${he} = offsetB${he} % 4u;
            ${de}[${he}] = ${_e}(${m(Fe,De)});
          `};$===9?ie=`
            var data = vec4<u32>(0);
            ${ee("data",0,"u32")}
            ${ee("data",1,"u32")}
            ${ee("data",2,"u32")}
            ${ee("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:ie=`
            ${ee("outputData[global_idx]",0)}
            ${ee("outputData[global_idx]",1)}
            ${ee("outputData[global_idx]",2)}
            ${ee("outputData[global_idx]",3)}
          `}return`
        ${n.registerUniform("vec_size","u32").declareVariables(X,ne,G)}

        ${k??""}

        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${ie}
      }`},$d=(n,i,s,u,d,f,c=s.dataType)=>{let g=!Ae.areEqual(s.dims,u.dims),v=s.dims,b=Ae.size(s.dims),$=!1,k=!1,m=[g];if(g){let K=Kr.calcShape(s.dims,u.dims,!1);if(!K)throw new Error("Can't perform binary op on the given tensors");v=K,b=Ae.size(v);let G=Ae.size(s.dims)===1,X=Ae.size(u.dims)===1,ne=s.dims.length>0&&s.dims[s.dims.length-1]%4===0,ie=u.dims.length>0&&u.dims[u.dims.length-1]%4===0;m.push(G),m.push(X),m.push(ne),m.push(ie);let ee=1;for(let de=1;de<v.length;de++){let he=s.dims[s.dims.length-de]??1,_e=u.dims[u.dims.length-de]??1;if(he===_e)ee*=he;else break}ee%4===0?(k=!0,$=!0):(G||X||ne||ie)&&($=!0)}else $=!0;return m.push($),{name:n,shaderCache:{hint:i+m.map(K=>K.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:K=>Pd(K,s.dims,u.dims,v,$,g,k,d,s.dataType,u.dataType,c,f),getRunData:()=>({outputs:[{dims:v,dataType:c}],dispatchGroup:{x:Math.ceil(b/64/4)},programUniforms:[{type:12,data:Math.ceil(Ae.size(v)/4)},...Ft(s.dims,u.dims,v)]})}},li=(n,i,s,u,d,f)=>{n.compute($d(i,d??"",n.inputs[0],n.inputs[1],s,u,f))},Ad=n=>{li(n,"Add",(i,s)=>`${i}+${s}`)},Fd=n=>{li(n,"Div",(i,s)=>`${i}/${s}`)},Ol=n=>{li(n,"Equal",{scalar:(i,s)=>`u32(${i}==${s})`,vector:(i,s)=>`vec4<u32>(${i}==${s})`},void 0,void 0,9)},Id=n=>{li(n,"Mul",(i,s)=>`${i}*${s}`)},Od=n=>{let i=ot("input",n.inputs[0].dataType,n.inputs[0].dims).type.value;li(n,"Pow",{scalar:(s,u)=>`pow_custom(${s},${u})`,vector:(s,u)=>`pow_vector_custom(${s},${u})`},`
    fn pow_custom(a : ${i}, b : ${i}) -> ${i} {
      if (b == ${i}(0.0)) {
        return ${i}(1.0);
      } else if (a < ${i}(0.0) && f32(b) != floor(f32(b))) {
        return ${i}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${i}(1.0), round(f32(abs(b) % ${i}(2.0))) != 1.0) * ${i}(${i==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${i}>, b : vec4<${i}>) -> vec4<${i}> {
      // TODO: implement vectorized pow
      return vec4<${i}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Dd=n=>{li(n,"Sub",(i,s)=>`${i}-${s}`)},zd=n=>{li(n,"Greater",{scalar:(i,s)=>`u32(${i}>${s})`,vector:(i,s)=>`vec4<u32>(${i}>${s})`},void 0,void 0,9)},la=n=>{li(n,"Less",{scalar:(i,s)=>`u32(${i}<${s})`,vector:(i,s)=>`vec4<u32>(${i}<${s})`},void 0,void 0,9)},Ld=n=>{li(n,"GreaterOrEqual",{scalar:(i,s)=>`u32(${i}>=${s})`,vector:(i,s)=>`vec4<u32>(${i}>=${s})`},void 0,void 0,9)},Rd=n=>{li(n,"LessOrEqual",{scalar:(i,s)=>`u32(${i}<=${s})`,vector:(i,s)=>`vec4<u32>(${i}<=${s})`},void 0,void 0,9)}}),Bd,Nd,Dl,Ud,jd,zl,Fh=_(()=>{nn(),Zt(),Ln(),yn(),Bd=(n,i)=>{if(!n||n.length<1)throw new Error("too few inputs");let s=0,u=n[s],d=u.dataType,f=u.dims.length;n.forEach((c,g)=>{if(g!==s){if(c.dataType!==d)throw new Error("input tensors should be one type");if(c.dims.length!==f)throw new Error("input tensors should have the same shape");c.dims.forEach((v,b)=>{if(b!==i&&v!==u.dims[b])throw new Error("non concat dimensions must match")})}})},Nd=(n,i)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${n}u>(${i});
    for (var i: u32 = 0u; i < ${n}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${n}u;
  }`,Dl=(n,i)=>{let s=n.length,u=[];for(let d=0;d<s;++d){let f=i.setByOffset("global_idx",n[d].getByIndices("indices"));s===1?u.push(f):d===0?u.push(`if (inputIndex == ${d}u) { ${f} }`):d===s-1?u.push(`else { ${f} }`):u.push(`else if (inputIndex == ${d}) { ${f} }`)}return u.join(`
`)},Ud=(n,i,s,u)=>{let d=Ae.size(s),f=new Array(n.length),c=new Array(n.length),g=0,v=[],b=[],$=[{type:12,data:d}];for(let X=0;X<n.length;++X)g+=n[X].dims[i],f[X]=g,b.push(n[X].dims.length),c[X]=ot(`input${X}`,u,b[X]),v.push("rank"),$.push({type:12,data:f[X]});for(let X=0;X<n.length;++X)$.push(...Ft(n[X].dims));$.push(...Ft(s));let k=Yt("output",u,s.length),m=k.indicesGet("indices",i),K=Array.from(Array(f.length).keys()).map(X=>`uniforms.sizeInConcatAxis${X}`).join(","),G=X=>`

  ${(()=>{X.registerUniform("outputSize","u32");for(let ne=0;ne<n.length;ne++)X.registerUniform(`sizeInConcatAxis${ne}`,"u32");return X.declareVariables(...c,k)})()}

  ${Nd(f.length,K)}

  ${X.mainStart()}
    ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${k.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${m});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${f.length}u>(${K});
      ${m} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Dl(c,k)}
  }`;return{name:"Concat",shaderCache:{hint:`${i}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:s,dataType:u}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:$}),getShaderSource:G}},jd=(n,i)=>{let s=n.inputs,u=s[0].dims,d=Ae.normalizeAxis(i.axis,u.length);Bd(s,d);let f=u.slice();f[d]=s.reduce((g,v)=>g+(v.dims.length>d?v.dims[d]:0),0);let c=s.filter(g=>Ae.size(g.dims)>0);n.compute(Ud(c,d,f,s[0].dataType),{inputs:c})},zl=n=>fn({axis:n.axis})}),to,no,ro,ua,io=_(()=>{nn(),Zt(),to=(n,i,s="f32")=>{switch(n.activation){case"Relu":return`value = max(value, ${i}(0.0));`;case"Sigmoid":return`value = (${i}(1.0) / (${i}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${i}(${s}(uniforms.clip_min)), ${i}(${s}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${i}(0.0), min(${i}(1.0), ${s}(uniforms.alpha) * value + ${s}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${s}(uniforms.alpha) * value, value, value >= ${i}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${n.activation}`)}},no=(n,i)=>{n.activation==="Clip"?i.push({type:1,data:n.clipMax},{type:1,data:n.clipMin}):n.activation==="HardSigmoid"?i.push({type:1,data:n.alpha},{type:1,data:n.beta}):n.activation==="LeakyRelu"&&i.push({type:1,data:n.alpha})},ro=(n,i)=>{n.activation==="Clip"?i.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):n.activation==="HardSigmoid"?i.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):n.activation==="LeakyRelu"&&i.push({name:"alpha",type:"f32"})},ua=n=>{let i=(n==null?void 0:n.activation)||"";if(i==="HardSigmoid"){let[s,u]=(n==null?void 0:n.activation_params)||[.2,.5];return{activation:i,alpha:s,beta:u}}else if(i==="Clip"){let[s,u]=(n==null?void 0:n.activation_params)||[mi,Li];return{activation:i,clipMax:u,clipMin:s}}else if(i==="LeakyRelu"){let[s]=(n==null?void 0:n.activation_params)||[.01];return{activation:i,alpha:s}}return{activation:i}}}),Or,ca,da=_(()=>{Or=(n,i)=>{switch(n){case 1:return i;case 2:return`vec2<${i}>`;case 3:return`vec3<${i}>`;case 4:return`vec4<${i}>`;default:throw new Error(`${n}-component is not supported.`)}},ca=n=>`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Ll,Rl=_(()=>{Ll=n=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${n}.x), i32(${n}.y), i32(${n}.z), 1));
}
`}),Vd,Wd,Ms,Bl,Gd,pa,qd,Nl,fa=_(()=>{nn(),Zt(),yn(),io(),da(),Vd=(n,i)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${i?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${i?", batchIndices":""});
        `,Wd=(n,i)=>n?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${i===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${i===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${i===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Ms=(n,i,s="f32",u,d=!1,f=32,c=!1,g=32)=>{let v=i[1]*n[1],b=i[0]*n[0],$=d?v:f,k=d?f:v,m=$/i[0],K=f/i[1];if(!((d&&m===4&&n[1]===4||!d&&(m===3||m===4))&&$%i[0]===0&&f%i[1]===0&&n[0]===4))throw new Error(`If transposeA ${d} is true, innerElementSize ${m} and workPerThread[1] ${n[1]} must be 4.
      Otherwise, innerElementSize ${m} must be 3 or 4.
  tileAWidth ${$} must be divisible by workgroupSize[0]${i[0]}. tileInner ${f} must be divisible by workgroupSize[1] ${i[1]}. colPerThread ${n[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${m}<${s}>, ${$/m}>, ${k}>;
var<workgroup> mm_Bsub: array<array<vec4<${s}>, ${b/n[0]}>, ${f}>;

const rowPerThread = ${n[1]};
const colPerThread = ${n[0]};
const innerElementSize = ${m};
const tileInner = ${f};

@compute @workgroup_size(${i[0]}, ${i[1]}, ${i[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${c?"0":"i32(globalId.z)"};
  ${u?`let batchIndices = ${u.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${v};

  let num_tiles = ${c?`${Math.ceil(g/f)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${c?`i32(globalId.z) * ${g}`:"0"};

  var acc: array<vec4<${s}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${K};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Vd(d,u)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${K}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${u?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${m===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Wd(d,m)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Bl=(n,i)=>n?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${i?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${i?", batchIndices":""});
            `,Gd=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",pa=(n,i,s="f32",u,d=!1,f=32,c=!1,g=32,v=!1)=>{let b=n[1]*i[1],$=n[0]*i[0],k=d?b:f,m=d?f:b;if(!(m%i[1]===0&&k%i[0]===0&&f%i[1]===0))throw new Error(`tileAHight ${m} must be divisible by workgroupSize[1]${i[1]}, tileAWidth ${k} must be divisible by workgroupSize[0]${i[0]}, tileInner ${f} must be divisible by workgroupSize[1]${i[1]}`);let K=m/i[1],G=k/i[0],X=f/i[1],ne=v?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${b};
    let globalColStart = i32(workgroupId.x) * ${$};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${m}; inputRow = inputRow + ${i[1]}) {
        for (var inputCol = localCol; inputCol < ${k}; inputCol = inputCol + ${i[0]}) {
          ${Bl(d,u)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${f}; inputRow = inputRow + ${i[1]}) {
            for (var inputCol = localCol; inputCol < ${$}; inputCol = inputCol + ${i[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${u?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${s}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${i[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${d?`mm_Asub[k][localRow + innerRow * ${i[1]}];`:`mm_Asub[localRow + innerRow * ${i[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${i[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${i[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${b};

let tileRowA = i32(localId.y) * ${K};
let tileColA = i32(localId.x) * ${G};
let tileRowB = i32(localId.y) * ${X};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${K}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${G}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Bl(d,u)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${X}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${u?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${s}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Gd(d)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${s}, ${k}>, ${m}>;
  var<workgroup> mm_Bsub : array<array<${s}, ${$}>, ${f}>;
  const rowPerThread = ${n[1]};
  const colPerThread = ${n[0]};
  const tileInner = ${f};

@compute @workgroup_size(${i[0]}, ${i[1]}, ${i[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${c?"0":"i32(globalId.z)"};
    ${u?`let batchIndices = ${u.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${c?`${Math.ceil(g/f)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${c?`i32(globalId.z) * ${g}`:"0"};

    var acc : array<array<${s}, colPerThread>, rowPerThread>;
    ${ne}
  }
`},qd=(n,i,s,u,d,f=!1)=>{let[c,g,v]=d,[b,$,k,m]=u,K=Wo(c,v),G=Wo(g,v),X=vn(u[0].type.tensor),ne=()=>{let ee=$.rank,de=b.rank,he=`var aIndices: ${$.type.indices};`;for(let _e=ee-2-1,Fe=de-1;_e>=0;_e--,Fe--)he+=`
aIndices[${_e}] = ${de>1?`batchIndices[${Fe}]`:"batchIndices"};`;return K.forEach(_e=>{he+=`
aIndices[${_e}] = 0;`}),he+=`
aIndices[${ee-2}] = u32(row);
                   aIndices[${ee-1}] = u32(colIn);`,he},ie=()=>{let ee=k.rank,de=b.rank,he=`var bIndices: ${k.type.indices};`;for(let _e=ee-2-1,Fe=de-1;_e>=0;_e--,Fe--)he+=`
bIndices[${_e}] = ${de>1?`batchIndices[${Fe}]`:"batchIndices"};`;return G.forEach(_e=>{he+=`
bIndices[${_e}] = 0;`}),he+=`
bIndices[${ee-2}] = u32(row);
                   bIndices[${ee-1}] = u32(colIn);`,he};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${b.type.indices}) -> ${Or(n,X)} {
      var value = ${Or(n,X)}(0.0);
      let col = colIn * ${n};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${ne()}
        value = ${$.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${b.type.indices}) -> ${Or(n,X)} {
      var value = ${Or(n,X)}(0.0);
      let col = colIn * ${n};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${ie()}
        value = ${k.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Or(n,X)}) {
      let col = colIn * ${n};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${i?`value = value + ${f?"bias[colIn]":`${Or(n,X)}(bias[row])`};`:""}
        ${s}
        ${m.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Nl=(n,i,s,u,d=!1,f)=>{let c=n[0].dims,g=n[1].dims,v=c.slice(0,-2),b=g.slice(0,-2),$=u?u.slice(0,-2):s.slice(0,-2),k=Ae.size($),m=c[c.length-2],K=c[c.length-1],G=g[g.length-1],X=K%4===0&&G%4===0,ne=m<=8?[4,1,1]:[4,4,1],ie=[8,8,1],ee=[Math.ceil(G/ie[0]/ne[0]),Math.ceil(m/ie[1]/ne[1]),Math.ceil(k/ie[2]/ne[2])],de=X?4:1,he=[...v,m,K/de],_e=he.length,Fe=[...b,K,G/de],De=Fe.length,st=[k,m,G/de],Lt=[{type:6,data:m},{type:6,data:G},{type:6,data:K}];no(i,Lt),Lt.push(...Ft($,he,Fe));let jt=["rank","rank"],pn=n.length>2;pn&&(Lt.push(...Ft(n[2].dims)),jt.push("rank")),Lt.push(...Ft(st));let un=Jt=>{let In=$.length,Yn=qa("batchDims",n[0].dataType,In,1),wn=vn(n[0].dataType),Bn=ot("a",n[0].dataType,_e,de),Qt=ot("b",n[1].dataType,De,de),tn=Yt("result",n[0].dataType,st.length,de),Pn=[Bn,Qt];if(pn){let xr=d?de:1;Pn.push(ot("bias",n[2].dataType,n[2].dims.length,xr))}let Ke=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];ro(i,Ke);let kt=vn(tn.type.tensor),ln=to(i,tn.type.value,kt),Gn=qd(de,pn,ln,[Yn,Bn,Qt,tn],[v,b,$],d);return`
  ${Jt.registerUniforms(Ke).registerInternalVariables(Yn).declareVariables(...Pn,tn)}
  ${Gn}
  ${X?Ms(ne,ie,wn,Yn):pa(ne,ie,wn,Yn)}
                   `};return{name:"MatMul",shaderCache:{hint:`${ne};${i.activation};${X};${d}`,inputDependencies:jt},getRunData:()=>({outputs:[{dims:f?f(s):s,dataType:n[0].dataType}],dispatchGroup:{x:ee[0],y:ee[1],z:ee[2]},programUniforms:Lt}),getShaderSource:un}}}),Ul,Hd,Ih=_(()=>{nn(),C(),yn(),io(),da(),Rl(),fa(),Ul=(n,i,s,u,d=!1,f,c=4,g=4,v=4,b="f32")=>{let $=Lt=>{switch(Lt){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${b}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Lt} is not supported.`)}},k=Lt=>{switch(Lt){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Lt} is not supported.`)}},m=n?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,K=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,G=n?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",X=n?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",ne=n?"row":"col",ie=n?"col":"row",ee=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${ne} / outWidth;
    let outCol = ${ne} % outWidth;

    let WRow = ${ie} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${ie} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${ie} % inChannels;
    var resData = ${Or(c,b)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${G} && xCol >= 0 && xCol < ${X}) {
      ${m}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${$(c)}
    }
    return resData;`,de=n?i&&u?`
    let col = colIn * ${c};
    ${ee}`:`
    let col = colIn * ${c};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${ee}
    }
    return ${Or(c,b)}(0.0);`:u&&s?`
    let col = colIn * ${c};
    ${ee}`:`
    let col = colIn * ${c};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${ee}
    }
    return ${Or(c,b)}(0.0);`,he=`${k(g)}`,_e=Or(v,b),Fe=Or(n?c:g,b),De=Or(n?g:c,b),st=to(f,_e,b);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Fe} {
      ${n?de:he}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${De} {
      ${n?he:de}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_e}) {
      let col = colIn * ${v};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${K}
      ${ca(d)}
      ${st}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Hd=(n,i,s,u,d,f,c,g,v)=>{let b=i.format==="NHWC",$=b?n[0].dims[3]:n[0].dims[1],k=s[0],m=b?s[2]:s[3],K=b?s[1]:s[2],G=b?s[3]:s[1],X=b&&($%4===0||$%3===0)&&G%4===0,ne=b?G:m*K,ie=b?m*K:G,ee=[8,8,1],de=u<=8?[4,1,1]:[4,4,1],he=[Math.ceil(ne/ee[0]/de[0]),Math.ceil(ie/ee[1]/de[1]),Math.ceil(k/ee[2]/de[2])];we("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${he}`);let _e=X?b&&$%4!==0?3:4:1,Fe=ee[1]*de[1],De=ee[0]*de[0],st=Math.max(ee[0]*_e,ee[1]),Lt=u%Fe===0,jt=d%De===0,pn=f%st===0,un=X?[_e,4,4]:[1,1,1],Jt=[{type:6,data:u},{type:6,data:d},{type:6,data:f},{type:6,data:[i.pads[0],i.pads[1]]},{type:6,data:i.strides},{type:6,data:i.dilations}];no(i,Jt),Jt.push(...Ft(n[0].dims,n[1].dims));let In=["rank","rank"];c&&(Jt.push(...Ft(n[2].dims)),In.push("rank")),Jt.push(...Ft(s));let Yn=wn=>{let Bn=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];ro(i,Bn);let Qt=X?4:1,tn=vn(n[0].dataType),Pn=`
      fn setOutputAtIndex(flatIndex : i32, value : ${X?`vec4<${tn}>`:tn}) {
        result[flatIndex] = ${X?`vec4<${tn}>`:tn}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${X?`vec4<${tn}>`:tn}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${X?"/ 4":""}, value);
      }`,Ke=ot("x",n[0].dataType,n[0].dims.length,_e===3?1:_e),kt=ot("w",n[1].dataType,n[1].dims.length,Qt),ln=[Ke,kt],Gn=Yt("result",n[0].dataType,s.length,Qt);if(c){let xr=ot("bias",n[2].dataType,n[2].dims.length,Qt);ln.push(xr),Pn+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${X?`vec4<${tn}>`:tn} {
          return bias[coords.${b?"w":"y"}${X?"/ 4":""}];
        }`}return`
        ${Ll("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${wn.registerUniforms(Bn).declareVariables(...ln,Gn)}
        ${Pn}
        ${Ul(b,Lt,jt,pn,c,i,un[0],un[1],un[2],tn)}
        ${X?Ms(de,ee,tn,void 0,!b,st):pa(de,ee,tn,void 0,!b,st,!1,void 0,g)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${i.cacheKey};${_e};${X};${Lt};${jt};${pn};${Fe};${De};${st}`,inputDependencies:In},getRunData:()=>({outputs:[{dims:v?v(s):s,dataType:n[0].dataType}],dispatchGroup:{x:he[0],y:he[1],z:he[2]},programUniforms:Jt}),getShaderSource:Yn}}}),jl,Vl,xs,oo,Wl,Kd,Xd,Qd,Yd=_(()=>{nn(),C(),Zt(),yn(),io(),da(),jl=n=>{let i=1;for(let s=0;s<n.length;s++)i*=n[s];return i},Vl=n=>typeof n=="number"?[n,n,n]:n,xs=(n,i)=>i<=1?n:n+(n-1)*(i-1),oo=(n,i,s,u=1)=>{let d=xs(i,u);return Math.floor((n[0]*(s-1)-s+d)/2)},Wl=(n,i,s,u,d)=>{d==null&&(d=oo(n,i[0],u[0]));let f=[0,0,0,s];for(let c=0;c<3;c++)n[c]+2*d>=i[c]&&(f[c]=Math.trunc((n[c]-i[c]+2*d)/u[c]+1));return f},Kd=(n,i,s,u,d,f,c,g,v,b)=>{let $,k,m,K;if(n==="VALID"&&(n=0),typeof n=="number"){$={top:n,bottom:n,left:n,right:n,front:n,back:n};let G=Wl([i,s,u,1],[g,v,b],1,[d,f,c],n);k=G[0],m=G[1],K=G[2]}else if(Array.isArray(n)){if(!n.every((X,ne,ie)=>X===ie[0]))throw Error(`Unsupported padding parameter: ${n}`);$={top:n[0],bottom:n[1],left:n[2],right:n[3],front:n[4],back:n[5]};let G=Wl([i,s,u,1],[g,v,b],1,[d,f,c],n[0]);k=G[0],m=G[1],K=G[2]}else if(n==="SAME_UPPER"){k=Math.ceil(i/d),m=Math.ceil(s/f),K=Math.ceil(u/c);let G=(k-1)*d+g-i,X=(m-1)*f+v-s,ne=(K-1)*c+b-u,ie=Math.floor(G/2),ee=G-ie,de=Math.floor(X/2),he=X-de,_e=Math.floor(ne/2),Fe=ne-_e;$={top:de,bottom:he,left:_e,right:Fe,front:ie,back:ee}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:$,outDepth:k,outHeight:m,outWidth:K}},Xd=(n,i,s,u,d,f=!1,c="channelsLast")=>{let g,v,b,$,k;if(c==="channelsLast")[g,v,b,$,k]=n;else if(c==="channelsFirst")[g,k,v,b,$]=n;else throw new Error(`Unknown dataFormat ${c}`);let[m,,K,G,X]=i,[ne,ie,ee]=Vl(s),[de,he,_e]=Vl(u),Fe=xs(K,de),De=xs(G,he),st=xs(X,_e),{padInfo:Lt,outDepth:jt,outHeight:pn,outWidth:un}=Kd(d,v,b,$,ne,ie,ee,Fe,De,st),Jt=f?m*k:m,In=[0,0,0,0,0];return c==="channelsFirst"?In=[g,Jt,jt,pn,un]:c==="channelsLast"&&(In=[g,jt,pn,un,Jt]),{batchSize:g,dataFormat:c,inDepth:v,inHeight:b,inWidth:$,inChannels:k,outDepth:jt,outHeight:pn,outWidth:un,outChannels:Jt,padInfo:Lt,strideDepth:ne,strideHeight:ie,strideWidth:ee,filterDepth:K,filterHeight:G,filterWidth:X,effectiveFilterDepth:Fe,effectiveFilterHeight:De,effectiveFilterWidth:st,dilationDepth:de,dilationHeight:he,dilationWidth:_e,inShape:n,outShape:In,filterShape:i}},Qd=(n,i,s,u,d,f)=>{let c=f==="channelsLast";c?n[0].dims[3]:n[0].dims[1];let g=[64,1,1],v={x:s.map((ne,ie)=>ie)},b=[Math.ceil(jl(v.x.map(ne=>s[ne]))/g[0]),1,1];we("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${b}`);let $=1,k=Ae.size(s),m=[{type:12,data:k},{type:12,data:u},{type:12,data:d},{type:12,data:i.strides},{type:12,data:i.dilations}];no(i,m),m.push(...Ft(n[0].dims,n[1].dims));let K=["rank","rank"],G=n.length===3;G&&(m.push(...Ft(n[2].dims)),K.push("rank")),m.push(...Ft(s));let X=ne=>{let ie=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:u.length},{name:"pads",type:"u32",length:d.length},{name:"strides",type:"u32",length:i.strides.length},{name:"dilations",type:"u32",length:i.dilations.length}];ro(i,ie);let ee=1,de=vn(n[0].dataType),he=ot("x",n[0].dataType,n[0].dims.length,$),_e=ot("W",n[1].dataType,n[1].dims.length,ee),Fe=[he,_e],De=Yt("result",n[0].dataType,s.length,ee),st="";if(G){let pn=ot("bias",n[2].dataType,n[2].dims.length,ee);Fe.push(pn),st+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${de} {
          return bias[${c?Kt("coords",4,5):Kt("coords",1,5)}];
        }`}let Lt=Or($,de),jt=to(i,Lt,de);return`
            ${st}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${he.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${_e.getByIndices("aIndices")};
            }
          ${ne.registerUniforms(ie).declareVariables(...Fe,De)}
          ${ne.mainStart()}
          ${ne.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${De.offsetToIndices("global_idx")};
              let batch = ${Kt("coords",0,he.rank)};
              let d2 = ${c?Kt("coords",he.rank-1,he.rank):Kt("coords",1,he.rank)};
              let xFRCCorner = vec3<u32>(${c?Kt("coords",1,he.rank):Kt("coords",2,he.rank)},
              ${c?Kt("coords",2,he.rank):Kt("coords",3,he.rank)},
              ${c?Kt("coords",3,he.rank):Kt("coords",4,he.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${c?Kt("uniforms.x_shape",1,he.rank):Kt("uniforms.x_shape",2,he.rank)};
              let xShapeZ = ${c?Kt("uniforms.x_shape",2,he.rank):Kt("uniforms.x_shape",3,he.rank)};
              let xShapeW = ${c?Kt("uniforms.x_shape",3,he.rank):Kt("uniforms.x_shape",4,he.rank)};
              let xShapeU = ${c?Kt("uniforms.x_shape",4,he.rank):Kt("uniforms.x_shape",1,he.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${c?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${c?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${c?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${c?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${G?"value = value + getBiasByOutputCoords(coords)":""};
              ${jt}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${i.cacheKey};${c};${$};${G}`,inputDependencies:K},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:m}),getShaderSource:X}}}),Jd,Zd,Oh=_(()=>{nn(),Zt(),yn(),io(),Jd=(n,i,s,u)=>{let d=n.length>2,f=d?"value += b[output_channel];":"",c=n[0].dims,g=n[1].dims,v=i.format==="NHWC",b=v?s[3]:s[1],$=b/i.group,k=v&&$>=4?Mn(b):1,m=Ae.size(s)/k,K=[{type:12,data:m},{type:12,data:i.dilations},{type:12,data:[i.strides[0],i.strides[1]]},{type:12,data:[i.pads[0],i.pads[1]]},{type:12,data:$}];no(i,K),K.push(...Ft(c,[g[0],g[1],g[2],g[3]/k]));let G=d?["rank","rank","rank"]:["rank","rank"];K.push(...Ft([s[0],s[1],s[2],s[3]/k]));let X=ne=>{let ie=Yt("output",n[0].dataType,s.length,k),ee=vn(ie.type.tensor),de=to(i,ie.type.value,ee),he=ot("x",n[0].dataType,c.length),_e=ot("w",n[1].dataType,g.length,k),Fe=[he,_e];d&&Fe.push(ot("b",n[2].dataType,n[2].dims,k));let De=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:i.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];ro(i,De);let st=v?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${he.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${_e.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${he.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${_e.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${ne.registerUniforms(De).declareVariables(...Fe,ie)}

  ${ne.mainStart()}
    ${ne.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${ie.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${v?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${v?1:2}], outputIndices[${v?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${k} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${v?2:1}];

    var value: ${ie.type.value} = ${ie.type.value}(0);
    ${st}
    ${f}
    ${de}
    ${ie.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${i.cacheKey}_${k}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:u?u(s):s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:K}),getShaderSource:X}},Zd=(n,i,s,u)=>{let d=n.length>2,f=Mn(s[3]),c=Mn(s[2]),g=Ae.size(s)/f/c,v=[n[0].dims[0],n[0].dims[1],n[0].dims[2],n[0].dims[3]/f],b=[n[1].dims[0],n[1].dims[1],n[1].dims[2],n[1].dims[3]/f],$=[s[0],s[1],s[2],s[3]/f],k=[{type:12,data:g},{type:6,data:[i.strides[0],i.strides[1]]},{type:6,data:[i.pads[0],i.pads[1]]}];no(i,k),k.push(...Ft(v,b,$));let m=(c-1)*i.strides[1]+b[1],K=G=>{let X=Yt("output",n[0].dataType,$.length,f),ne=vn(X.type.tensor),ie=to(i,X.type.value,ne),ee=ot("x",n[0].dataType,v.length,f),de=ot("w",n[1].dataType,b.length,f),he=[ee,de];d&&he.push(ot("b",n[2].dataType,n[2].dims,f));let _e=d?"value += b[output_channel];":"",Fe=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return ro(i,Fe),`
  ${G.registerUniforms(Fe).declareVariables(...he,X)}
  ${G.mainStart()}
    ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${c}u;
    let col = (index1 % width1) * ${c}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${ee.type.value}, ${m}>;
    var values: array<${X.type.value}, ${c}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${b[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${m}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${ee.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${ee.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${b[1]}; w_width++) {
          let w_val = ${de.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${c}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${c}u; i++) {
      var value = values[i];
      ${_e}
      ${ie}
      ${X.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${i.cacheKey};${f};${c};${m};${b[0]};${b[1]}`,inputDependencies:d?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:u?u(s):s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:k}),getShaderSource:K}}}),Gl,ha,ep,tp=_(()=>{nn(),Zt(),fa(),yn(),io(),Gl=(n,i,s,u,d=!1,f)=>{let c=n[0].dims,g=n[1].dims,v=c[c.length-2],b=g[g.length-1],$=c[c.length-1],k=Mn(b),m=Mn($),K=Mn(v),G=Ae.size(s)/k/K,X=n.length>2,ne=u?u.slice(0,-2):s.slice(0,-2),ie=[Ae.size(ne),v,b],ee=[{type:12,data:G},{type:12,data:v},{type:12,data:b},{type:12,data:$}];no(i,ee),ee.push(...Ft(ne,c,g)),X&&ee.push(...Ft(n[2].dims)),ee.push(...Ft(ie));let de=he=>{let _e=qa("batch_dims",n[0].dataType,ne.length),Fe=ot("a",n[0].dataType,c.length,m),De=ot("b",n[1].dataType,g.length,k),st=Yt("output",n[0].dataType,ie.length,k),Lt=vn(st.type.tensor),jt=to(i,st.type.value,Lt),pn=[Fe,De],un="";if(X){let Pn=d?k:1;pn.push(ot("bias",n[2].dataType,n[2].dims.length,Pn)),un=`${d?`value += bias[col / ${Pn}];`:`value += ${st.type.value}(bias[row + i]);`}`}let Jt=c.slice(0,-2),In=g.slice(0,-2),Yn=Wo(Jt,ne),wn=Wo(In,ne),Bn=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];ro(i,Bn);let Qt=(Pn,Ke)=>{let kt=Pn.rank,ln=Pn.name;if(kt===2)return`var ${ln}_indices = ${Pn.type.indices}(0u, 0u);`;let Gn=_e.rank,xr=`var ${ln}_indices: ${Pn.type.indices};`;for(let Sr=kt-2-1,Cs=Gn-1;Sr>=0;Sr--,Cs--)xr+=`
${ln}_indices[${Sr}] = ${Gn>1?`batch_indices[${Cs}]`:"batch_indices"};`;return Ke.forEach(Sr=>{xr+=`
${ln}_indices[${Sr}] = 0;`}),xr+=`${ln}_indices[${kt-2}] = 0u;
                     ${ln}_indices[${kt-1}] = 0u;`,xr},tn=()=>{let Pn=`var a_data: ${Fe.type.value};`;for(let Ke=0;Ke<m;Ke++)Pn+=`
              let b_data${Ke} = b[(b_offset + (k + ${Ke}) * uniforms.N + col) / ${k}];`;for(let Ke=0;Ke<K;Ke++){Pn+=`a_data = a[(a_offset + (row + ${Ke}) * uniforms.K + k) / ${m}];`;for(let kt=0;kt<m;kt++)Pn+=`
            values[${Ke}] = fma(${De.type.value}(a_data${m===1?"":`[${kt}]`}), b_data${kt}, values[${Ke}]);
`}return Pn};return`
  ${he.registerUniforms(Bn).registerInternalVariables(_e).declareVariables(...pn,st)}
  ${he.mainStart()}
    ${he.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${k})) * ${k};
    var index1 = global_idx / (uniforms.N / ${k});
    let stride1 = uniforms.M / ${K};
    let row = (index1 % stride1) * ${K};
    let batch = index1 / stride1;

    ${s.length===2?"":`let batch_indices = ${_e.offsetToIndices("batch")};`}
    ${Qt(Fe,Yn)}
    let a_offset = ${Fe.indicesToOffset("a_indices")};
    ${Qt(De,wn)}
    let b_offset = ${De.indicesToOffset("b_indices")};
    var values: array<${st.type.value}, ${K}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${m}) {
      ${tn()}
    }
    for (var i = 0u; i < ${K}u; i++) {
      var value = values[i];
      ${un}
      ${jt}
      let cur_indices = ${st.type.indices}(batch, row + i, col);
      let offset = ${st.indicesToOffset("cur_indices")};
      ${st.setByOffset(`offset / ${k}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${i.activation};${k};${m};${K};${d}`,inputDependencies:X?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:f?f(s):s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(G/64)},programUniforms:ee}),getShaderSource:de}},ha=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.")},ep=n=>{ha(n.inputs);let i=Kr.calcShape(n.inputs[0].dims,n.inputs[1].dims,!0);if(!i)throw new Error("Can't use matmul on the given tensors");let s=i[i.length-1],u=n.inputs[0].dims[n.inputs[0].dims.length-1];s<8&&u<8?n.compute(Gl(n.inputs,{activation:""},i)):n.compute(Nl(n.inputs,{activation:""},i))}}),np,xo,rp,ma,ql,Hl,ga,ip,Kl,Dh=_(()=>{Zt(),Ih(),Yd(),fa(),Oh(),io(),tp(),Bi(),np=(n,i,s,u,d,f)=>{let c=n[0],g=n.slice(f?1:2,f?3:4),v=g.length,b=i[0],$=i.slice(2).map((m,K)=>m+(m-1)*(s[K]-1)),k=g.map((m,K)=>m+u[K]+u[K+v]).map((m,K)=>Math.floor((m-$[K]+d[K])/d[K]));return k.splice(0,0,c),k.splice(f?3:1,0,b),k},xo=[2,3,1,0],rp=(n,i)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length>5)throw new Error("greater than 5D is not supported");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let s=n[0].dims[i.format==="NHWC"?n[0].dims.length-1:1],u=n[1].dims[1]*i.group;if(s!==u)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let d=n[0].dims.length-2;if(i.dilations.length!==d)throw new Error(`dilations should be ${d}D`);if(i.strides.length!==d)throw new Error(`strides should be ${d}D`);if(i.pads.length!==d*2)throw new Error(`pads should be ${d*2}D`);if(i.kernelShape.length!==0&&i.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape")},ma=(n,i)=>{let s=n.kernelShape.slice();s.length<i[1].dims.length-2&&s.push(...Array(i[1].dims.length-2-s.length).fill(0));for(let f=2;f<i[1].dims.length;++f)s[f-2]===0&&(s[f-2]=i[1].dims[f]);let u=n.pads.slice();_r.adjustPadsBasedOnAutoPad(i[0].dims,n.strides,n.dilations,s,u,n.format==="NHWC",n.autoPad);let d=Object.assign({},n);return Object.assign(d,{kernelShape:s,pads:u}),d},ql=n=>{let i=ua(n),s=n.format,u=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],d=n.dilations,f=n.group,c=n.kernel_shape,g=n.pads,v=n.strides,b=n.w_is_const();return{autoPad:u,format:s,dilations:d,group:f,kernelShape:c,pads:g,strides:v,wIsConst:b,...i,cacheKey:`${n.format};${i.activation};`}},Hl=(n,i,s,u)=>{let d=s.format==="NHWC",f=np(i[0].dims,i[1].dims,s.dilations,s.pads,s.strides,d);if(s.group!==1){let Fe=[i[0]];if(d){let De=n.kernelCustomData.wT??n.compute(Zr(i[1],xo),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=De),Fe.push(De)}else Fe.push(i[1]);i.length===3&&Fe.push(i[2]),!n.adapterInfo.isArchitecture("ampere")&&d&&i[1].dims[0]===s.group&&i[1].dims[1]===1&&s.dilations[0]===1&&s.dilations[1]===1?n.compute(Zd(Fe,s,f,u),{inputs:Fe}):n.compute(Jd(Fe,s,f,u),{inputs:Fe});return}let c=i.length===3,g=i[0].dims[d?1:2],v=i[0].dims[d?2:3],b=i[0].dims[d?3:1],$=i[1].dims[2],k=i[1].dims[3],m=f[d?1:2],K=f[d?2:3],G=f[d?3:1],X=d&&$===g&&k===v&&s.pads[0]===0&&s.pads[1]===0;if(X||$===1&&k===1&&s.dilations[0]===1&&s.dilations[1]===1&&s.strides[0]===1&&s.strides[1]===1&&s.pads[0]===0&&s.pads[1]===0){let Fe=f[0],De,st,Lt,jt=[];if(d){let Jt=n.kernelCustomData.wT??n.compute(Zr(i[1],xo),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];if(s.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=Jt),X){let In=g*v*b;De=i[0].reshape([1,Fe,In]),st=Jt.reshape([1,In,G]),Lt=[1,Fe,G]}else De=i[0].reshape([Fe,g*v,b]),st=Jt.reshape([1,b,G]),Lt=[Fe,m*K,G];jt.push(De),jt.push(st)}else De=i[0].reshape([Fe,b,g*v]),st=i[1].reshape([1,G,b]),Lt=[Fe,G,m*K],jt.push(st),jt.push(De);c&&jt.push(i[2]);let pn=Lt[2],un=jt[0].dims[jt[0].dims.length-1];pn<8&&un<8?n.compute(Gl(jt,s,f,Lt,d,u),{inputs:jt}):n.compute(Nl(jt,s,f,Lt,d,u),{inputs:jt});return}let ne=!0,ie=n.kernelCustomData.wT??n.compute(Zr(i[1],xo),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=ie);let ee=[i[0],ie];c&&ee.push(i[2]);let de=d?m*K:G,he=d?G:m*K,_e=$*k*b;n.compute(Hd(ee,s,f,de,he,_e,c,ne,u),{inputs:ee})},ga=(n,i)=>{let s=i.format==="NHWC",u=[n.inputs[0].reshape(s?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&u.push(n.inputs[2]);let d=[0,i.pads[0],0,i.pads[1]],f=[1].concat(i.strides),c=[1].concat(i.dilations),g=[1].concat(i.kernelShape),v=ma({...i,pads:d,strides:f,dilations:c,kernelShape:g},u);Hl(n,u,v,b=>s?[b[0],b[2],b[3]]:[b[0],b[1],b[3]])},ip=(n,i,s)=>{let u=s.format==="NHWC"?"channelsLast":"channelsFirst",d=ma(s,i),f=s.autoPad==="NOTSET"?s.pads:s.autoPad,c=Xd(i[0].dims,i[1].dims,s.strides,s.dilations,f,!1,u);n.compute(Qd(i,d,c.outShape,[c.filterDepth,c.filterHeight,c.filterWidth],[c.padInfo.front,c.padInfo.top,c.padInfo.left],u))},Kl=(n,i)=>{if(rp(n.inputs,i),n.inputs[0].dims.length===3)ga(n,i);else if(n.inputs[0].dims.length===5)ip(n,n.inputs,i);else{let s=ma(i,n.inputs);Hl(n,n.inputs,s)}}}),zh,op,Lh=_(()=>{nn(),C(),yn(),io(),da(),Rl(),fa(),zh=(n,i=!1,s,u,d=4)=>{let f=ne=>{switch(ne){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${u}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${ne} is not supported.`)}},c=n?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,g=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,v=n?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",b=n?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",$=n?"row":"col",k=n?"col":"row",m=`
      let inChannels = ${n?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${$} / outWidth;
      let outCol = ${$} % outWidth;

      let WRow = ${k} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${k} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${v}) || fract(xR) > 0.0) {
        return ${u}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${b}) || fract(xC) > 0.0) {
        return ${u}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${k} % inChannels;
      ${c}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${d}];`,K=n?`
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${m}
      }
      return ${u}(0.0);`:`
      let col = colIn * ${d};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${m}
      }
      return ${u}(0.0);`,G=`
      let col = colIn * ${d};
      let inChannels = ${n?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${n?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${f(d)}
      }
      return ${u}(0.0);
      `,X=to(s,u);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${u} {
    ${n?K:G}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${u} {
    ${n?G:K}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${u}) {
    let col = colIn * ${d};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${g}
      ${ca(i)}
      ${X}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${d}] = value;
    }
  }`},op=(n,i,s,u,d,f,c,g)=>{let v=i.format==="NHWC",b=v?n[0].dims[3]:n[0].dims[1],$=s[0],k=v?s[2]:s[3],m=v?s[1]:s[2],K=v?s[3]:s[1],G=v&&b%4===0&&b%3&&K%4===0,X=v?K:k*m,ne=v?k*m:K,ie=[8,8,1],ee=u<=8?[4,1,1]:[4,4,1],de=[Math.ceil(X/ie[0]/ee[0]),Math.ceil(ne/ie[1]/ee[1]),Math.ceil($/ie[2]/ee[2])];we("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${de}`);let he=G?4:1,_e=Math.max(ie[0]*he,ie[1]),Fe=G?4:1,De=[i.kernelShape[v?1:2],i.kernelShape[v?2:3]],st=[De[0]+(i.dilations[0]<=1?0:(De[0]-1)*(i.dilations[0]-1)),De[1]+(i.dilations[1]<=1?0:(De[1]-1)*(i.dilations[1]-1))],Lt=[st[0]-1-Math.floor((i.pads[0]+i.pads[2])/2),st[1]-1-Math.floor((i.pads[1]+i.pads[3])/2)],jt=[{type:6,data:u},{type:6,data:d},{type:6,data:f},{type:6,data:i.strides},{type:6,data:i.dilations},{type:6,data:De},{type:6,data:Lt}];no(i,jt),jt.push(...Ft(n[0].dims,n[1].dims));let pn=["rank","rank"];c&&(jt.push(...Ft(n[2].dims)),pn.push("rank")),jt.push(...Ft(s));let un=Jt=>{let In=ot("x",n[0].dataType,n[0].dims.length,Fe),Yn=ot("w",n[1].dataType,n[1].dims.length,1),wn=Yt("result",n[0].dataType,s.length,Fe),Bn=[In,Yn],Qt="";if(c){let Ke=ot("bias",n[2].dataType,n[2].dims.length,Fe);Bn.push(Ke),Qt+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${Ke.type.value} {
            return bias[coords.${v?"w":"y"}${G?"/ 4":""}];
          }`}let tn=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:De.length},{name:"pads",type:"i32",length:Lt.length}];ro(i,tn);let Pn=vn(n[0].dataType,1);if(Pn!=="f16"&&Pn!=="f32")throw new Error(`elemType ${Pn} is not supported.`);return`
        ${Ll("uniforms.result_strides")}
        ${Jt.registerUniforms(tn).declareVariables(...Bn,wn)};
        ${Qt}
        ${zh(v,c,i,In.type.value,he)}
        ${G?Ms(ee,ie,Pn,void 0,!v,_e):pa(ee,ie,Pn,void 0,!v,_e,!1,void 0,g)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${i.cacheKey};${ee};${ie};${G}`,inputDependencies:pn},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:de[0],y:de[1],z:de[2]},programUniforms:jt}),getShaderSource:un}}}),sp,To,Rh=_(()=>{nn(),C(),Zt(),yn(),sp=(n,i,s,u,d,f=!1,c,g,v=!1)=>{let b=v?1:2,$=v?2:3,k=v?3:1,m=f?2:1,K=`
  fn setOutputAtIndex(flatIndex : u32, value : ${f?`vec4<${c}>`:c}) {
    result[flatIndex] = ${f?`vec4<${c}>`:c}(value);
  }`;u&&(K+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${f?`vec4<${c}>`:c} {
      return bias[coords.${v?"w":"y"}${f?"/ 4":""}];
    }`);let G=f?4:1,X=ot("W",i[1].dataType,i[1].dims.length,G),ne=ot("Dy",i[0].dataType,i[0].dims.length,G),ie=[ne,X];u&&ie.push(ot("bias",i[2].dataType,[s[k]].length,G));let ee=Yt("result",i[0].dataType,s.length,G),de=`{
        let batch: u32 = ${d?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${d?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${d?"global_id.y":"workgroup_id.y"} * ${m};
        let d1: u32 = ${d?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${c}>, ${m}>;
        for (var i = 0; i < ${m}; i++) {
          dotProd[i] = vec4<${c}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${c}(dyCorner.x) + ${c}(wR)) / ${c}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${c}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${c}(dyCorner.y) + ${c}(wC)) / ${c}(uniforms.strides.y);
            let dyC2 = (${c}(dyCorner.y) + 1.0 + ${c}(wC)) / ${c}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${c}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${c}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${ne.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${ne.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${c}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${k}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${ne.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${X.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${ne.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${c}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${m}; i = i + 1) {
          let value = dotProd[i] + ${u?"bias[c+i]":`vec4<${c}>(0.0)`};
          ${ee.set("batch","r","c + i","d1","value")};
        }
      }`,he=`
          let outputIndices = ${ee.offsetToIndices("global_idx")};
          let batch = ${ee.indicesGet("outputIndices",0)};
          let d1 = ${ee.indicesGet("outputIndices",k)};
          let r = ${ee.indicesGet("outputIndices",b)};
          let c = ${ee.indicesGet("outputIndices",$)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${c}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${c}(dyRCorner) + ${c}(wR)) / ${c}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${c}(uniforms.Dy_shape[${b}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${c}(dyCCorner) + ${c}(wC)) / ${c}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${c}(uniforms.Dy_shape[${$}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${v?ne.get("batch","idyR","idyC","inputChannel"):ne.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${X.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${u?"bias[d1]":`${c}(0.0)`};
          ${ee.setByOffset("global_idx","value")};
        `;return`
  ${n.registerUniforms(g).declareVariables(...ie,ee)}
  ${K}

    ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${f?de:he}}`},To=(n,i,s)=>{let u=n.length>2,d=i.outputShape,f=Ae.size(d),c=[Math.ceil(f/64),1,1];we("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${c}`);let g=i.format==="NHWC",v=["rank","rank"],b=[i.strides[0],i.strides[1]],$=[i.kernelShape[g?1:2],i.kernelShape[g?2:3]],k=[i.dilations[0],i.dilations[1]],m=[$[0]+(i.dilations[0]<=1?0:(i.kernelShape[g?1:2]-1)*(i.dilations[0]-1)),$[1]+(i.dilations[1]<=1?0:(i.kernelShape[g?2:3]-1)*(i.dilations[1]-1))],K=[m[0]-1-Math.floor((i.pads[0]+i.pads[2])/2),m[1]-1-Math.floor(i.pads[1]+i.pads[3])/2],G=!1,X=i.group,ne=n[1].dims,ie=ne[0]/X,ee=ne[1],de=[{type:12,data:f},{type:12,data:b},{type:12,data:$},{type:12,data:k},{type:12,data:m},{type:6,data:K},{type:12,data:ie},{type:12,data:ee},...Ft(n[0].dims,n[1].dims)];u&&(de.push(...Ft(n[2].dims)),v.push("rank")),de.push(...Ft(d));let he=c[1]===1&&c[2]===1,_e=Fe=>{let De=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:b.length},{name:"filter_dims",type:"u32",length:$.length},{name:"dilations",type:"u32",length:$.length},{name:"effective_filter_dims",type:"u32",length:m.length},{name:"pads",type:"i32",length:K.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],st=vn(n[0].dataType);return`${sp(Fe,n,d,u,he,G,st,De,g)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${i.cacheKey};`,inputDependencies:v},getRunData:()=>({dispatchGroup:{x:c[0],y:c[1],z:c[2]},outputs:[{dims:s?s(d):d,dataType:n[0].dataType}],programUniforms:de}),getShaderSource:_e}}}),ap,lp,up,Xl,_a,Bh,cp,dp,pp,fp,Nh=_(()=>{Lh(),Rh(),io(),Bi(),ap=(n,i,s,u,d,f)=>(n-1)*i+s+(u-1)*d+1-f,lp=(n,i,s,u,d)=>{let f=Math.floor(n/2);i==="SAME_UPPER"?(s[u]=f,s[d]=n-f):i==="SAME_LOWER"&&(s[u]=n-f,s[d]=f)},up=(n,i,s,u,d,f,c,g,v,b)=>{let $=n.length-2,k=b.length===0;v.length<$&&v.push(...Array($-v.length).fill(0));let m=n[0],K=i[g?3:1]*d;for(let G=0,X=n.length-$-(g?1:0);G<$;++G,++X){let ne=n[X],ie=k?ne*c[G]:b[G],ee=ap(ne,c[G],f[G],i[X],s[G],ie);lp(ee,u,f,G,G+$),k&&b.push(c[G]*(ne-1)+v[G]+(i[X]-1)*s[G]+1-f[G]-f[G+$])}b.splice(0,0,m),b.splice(g?3:1,0,K)},Xl=(n,i)=>{let s=n.kernelShape.slice();if(n.kernelShape.length===0||n.kernelShape.reduce((k,m)=>k*m,1)===0){s.length=0;for(let k=2;k<i[1].dims.length;++k)s.push(i[1].dims[k])}let u=n.format==="NHWC";s.splice(0,0,i[1].dims[0]),s.splice(u?3:1,0,i[1].dims[1]);let d=n.pads.slice(),f=n.outputShape.slice(),c=n.outputPadding.slice(),g=i[0].dims,v=n.dilations.slice();if(v.reduce((k,m)=>k+m,0)===0){let k=i[0].dims.length-2;v=new Array(k).fill(1)}let b=n.strides.slice();if(b.reduce((k,m)=>k+m,0)===0){let k=i[0].dims.length-2;b=new Array(k).fill(1)}up(g,s,v,n.autoPad,n.group,d,b,u,c,f);let $=Object.assign({},n);return Object.assign($,{kernelShape:s,pads:d,outputPadding:c,outputShape:f,dilations:v,strides:b}),$},_a=n=>{let i=ua(n),s=n.format,u=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof n.autoPad>"u"?0:n.autoPad],d=n.dilations,f=n.group,c=n.kernelShape,g=n.pads,v=n.strides,b=n.wIsConst(),$=n.outputPadding,k=n.outputShape;return{autoPad:u,format:s,dilations:d,group:f,kernelShape:c,outputPadding:$,outputShape:k,pads:g,strides:v,wIsConst:b,...i,cacheKey:`${n.format};${i.activation};`}},Bh=(n,i)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let s=n[0].dims[i.format==="NHWC"?n[0].dims.length-1:1],u=n[1].dims[0];if(s!==u)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let d=n[1].dims[1]*i.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==d))throw new Error("invalid bias");let f=n[0].dims.length-2;if(i.dilations.reduce((c,g)=>c+g,0)>0&&i.dilations.length!==f)throw new Error(`dilations should be ${f}D`);if(i.strides.reduce((c,g)=>c+g,0)>0&&i.strides.length!==f)throw new Error(`strides should be ${f}D`);if(i.pads.reduce((c,g)=>c+g,0)>0&&i.pads.length!==f*2)throw new Error(`pads should be ${f*2}D`);if(i.outputPadding.length!==f&&i.outputPadding.length!==0)throw new Error(`output_padding should be ${f}D`);if(i.kernelShape.reduce((c,g)=>c+g,0)>0&&i.kernelShape.length!==0&&i.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(i.outputShape.length!==0&&i.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape")},cp=[2,3,1,0],dp=(n,i,s)=>{let u=Xl(s,i),d=s.format==="NHWC",f=u.outputShape,c=f[d?3:1],g=i[0].dims[d?3:1];if(u.group!==1||c===1&&g===1){n.compute(To(i,u));return}let v=f[d?1:2],b=f[d?2:3],$=i[1].dims[2],k=i[1].dims[3],m=d?v*b:c,K=d?c:v*b,G=$*k*g,X=!0,ne=n.kernelCustomData.wT??n.compute(Zr(i[1],cp),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=ne);let ie=[i[0],ne],ee=i.length===3;ee&&(!d&&i[2].dims.length===1?ie.push(i[2].reshape([i[2].dims[0],1,1])):ie.push(i[2])),n.compute(op(ie,u,f,m,K,G,ee,X),{inputs:ie})},pp=(n,i)=>{let s=i.format==="NHWC",u=[n.inputs[0].reshape(s?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&u.push(n.inputs[2]);let d=i.kernelShape;(d.length===0||d[0]===0)&&(d=[n.inputs[1].dims[2]]);let f=i.dilations;(f.length===0||f[0]===0)&&(f=[1]);let c=i.strides;(c.length===0||c[0]===0)&&(c=[1]);let g=i.pads;g.length===0&&(g=[0,0]),g=[0,g[0],0,g[1]],c=[1].concat(c),f=[1].concat(f),d=[1].concat(d);let v=Xl({...i,pads:g,strides:c,dilations:f,kernelShape:d},u);n.compute(To(u,v,b=>s?[b[0],b[2],b[3]]:[b[0],b[1],b[3]]))},fp=(n,i)=>{Bh(n.inputs,i),n.inputs[0].dims.length===3?pp(n,i):dp(n,n.inputs,i)}}),Ql,hp,mp,gp=_(()=>{nn(),Zt(),Ln(),yn(),Ql=(n,i,s,u)=>{let d=Ae.size(i),f=i.length,c=ot("input",n,f),g=Yt("output",n,f),v=s.dataType===6?s.getInt32Array()[0]:Number(s.getBigInt64Array()[0]),b=Ae.normalizeAxis(v,f),$=k=>{let m=` i32(${c.indicesGet("inputIndices","uniforms.axis")}) `,K=Kt("uniforms.input_shape","uniforms.axis",f),G=u.reverse?m+(u.exclusive?" + 1":""):"0",X=u.reverse?K:m+(u.exclusive?"":" + 1");return`
                ${k.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(c,g)}
                ${k.mainStart()}
                  ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${g.offsetToIndices("global_idx")};
                  var sum = ${g.type.value}(0);
                  let first : i32 = ${G};
                  let last : i32 = ${X};
                  for (var i : i32 = first; i < last; i++) {
                    ${c.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${c.getByIndices("inputIndices")};
                  }
                  ${g.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:u.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:n}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:12,data:b},...Ft(i,i)]}),getShaderSource:$}},hp=(n,i)=>{let s=n.inputs[0].dims,u=n.inputs[0].dataType,d=n.inputs[1];n.compute(Ql(u,s,d,i),{inputs:[0]})},mp=n=>{let i=n.exclusive===1,s=n.reverse===1;return fn({exclusive:i,reverse:s})}}),_p,yp,Yl,wp,vp,Jl=_(()=>{nn(),Zt(),Ln(),yn(),_p=n=>{if(!n||n.length!==1)throw new Error("DepthToSpace requires 1 input.");if(n[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},yp=(n,i,s,u)=>{let d=[];d.push(`fn perm(i: ${u.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);for(let f=0;f<i;++f)d.push(s.indicesSet("a",n[f],`i[${f}]`));return d.push("return a;}"),d.join(`
`)},Yl=(n,i)=>{let s,u,d,f,c,g,v=i.format==="NHWC",b=i.blocksize,$=i.mode==="DCR";v?([s,u,d,f]=n.dims,c=$?[s,u,d,b,b,f/b**2]:[s,u,d,f/b**2,b,b],g=$?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([s,u,d,f]=[n.dims[0],n.dims[2],n.dims[3],n.dims[1]],c=$?[s,b,b,f/b**2,u,d]:[s,f/b**2,b,b,u,d],g=$?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let k=n.reshape(c),m=k.dims.length,K=n.dataType,G=ot("a",K,m),X=Yt("output",K,m),ne=ie=>`
  ${ie.registerUniform("output_size","u32").declareVariables(G,X)}

  ${yp(g,m,G,X)}

  ${ie.mainStart()}
    ${ie.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${X.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${X.setByOffset("global_idx",G.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${n.dims};${i.blocksize};${i.mode}`,inputDependencies:["rank"]},getRunData:ie=>{let ee=v?[s,u*b,d*b,f/b**2]:[s,f/b**2,u*b,d*b],de=Ae.size(ee),he=k.dims,_e=Ae.sortBasedOnPerm(he,g);return{outputs:[{dims:ee,dataType:ie[0].dataType}],dispatchGroup:{x:Math.ceil(de/64)},programUniforms:[{type:12,data:de},...Ft(he,_e)]}},getShaderSource:ne}},wp=(n,i)=>{_p(n.inputs),n.compute(Yl(n.inputs[0],i))},vp=n=>fn({blocksize:n.blocksize,mode:n.mode,format:n.format})}),ya,Ts,Zl,bp,eu,wa,Uh,tu,Mp,nu,xp,jh=_(()=>{nn(),Zt(),Ln(),yn(),ya="[a-zA-Z]|\\.\\.\\.",Ts="("+ya+")+",Zl="^"+Ts+"$",bp="("+Ts+",)*"+Ts,eu="^"+bp+"$",wa=class{constructor(n=-1){this.symbolToIndices=new Map,this.inputIndex=n}addSymbol(n,i){let s=this.symbolToIndices.get(n);s===void 0?s=[i]:s.push(i),this.symbolToIndices.set(n,s)}},Uh=class{constructor(n,i){var d;this.equation=i,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[s,u]=i.includes("->")?i.split("->",2):[i,""];if(!s.match(RegExp(eu)))throw new Error("Invalid LHS term");if(s.split(",").forEach((f,c)=>{let g=n[c].dims.slice();if(!f.match(RegExp(Zl)))throw new Error("Invalid LHS term");let v=this.processTerm(f,!0,g,c);this.lhs.push(v)}),u==="")u+=[...this.symbolToInfo.entries()].filter(([f,c])=>c.count===1||f==="...").map(([f])=>f).join("");else if(!u.match(RegExp(Ts)))throw new Error("Invalid RHS");(d=u.match(RegExp(ya,"g")))==null||d.forEach(f=>{if(f==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let c=this.symbolToInfo.get(f);if(c===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(c.dimValue)}}),this.rhs=this.processTerm(u,!1,this.outputDims)}addSymbol(n,i,s){let u=this.symbolToInfo.get(n);if(u!==void 0){if(u.dimValue!==i&&u.count!==1)throw new Error("Dimension mismatch");u.count++,u.inputIndices.push(s)}else u={count:1,dimValue:i,inputIndices:[s]};this.symbolToInfo.set(n,u)}processTerm(n,i,s,u=-1){let d=s.length,f=!1,c=[],g=0;if(!n.match(RegExp(Zl))&&!i&&n!=="")throw new Error("Invalid LHS term");let v=n.match(RegExp(ya,"g")),b=new wa(u);return v==null||v.forEach(($,k)=>{if($==="..."){if(f)throw new Error("Only one ellipsis is allowed per input term");f=!0;let m=d-v.length+1;if(m<0)throw new Error("Ellipsis out of bounds");if(c=s.slice(g,g+m),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(i)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let K=0;K<c.length;K++){let G=String.fromCharCode(48+K);b.addSymbol(G,k+K),this.addSymbol(G,s[g++],u)}}else b.addSymbol($,k+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol($,s[g++],u)}),b}},tu=n=>n+"_max",Mp=(n,i,s,u)=>{let d=n.map(b=>b.length).map((b,$)=>ot(`input${$}`,i,b)),f=Ae.size(u),c=Yt("output",i,u.length),g=[...s.symbolToInfo.keys()].filter(b=>!s.rhs.symbolToIndices.has(b)),v=b=>{let $=[],k="var prod = 1.0;",m="var sum = 0.0;",K="sum += prod;",G=[],X=[],ne=[],ie=[],ee=s.symbolToInfo.size===s.rhs.symbolToIndices.size;s.symbolToInfo.forEach((he,_e)=>{var Fe;if(s.rhs.symbolToIndices.has(_e)){let De=(Fe=s.rhs.symbolToIndices.get(_e))==null?void 0:Fe[0];De!==void 0&&s.lhs.forEach((st,Lt)=>{if(he.inputIndices.includes(Lt)){let jt=st.symbolToIndices.get(_e);if(jt===void 0)throw new Error("Invalid symbol error");jt.forEach(pn=>{$.push(`${d[Lt].indicesSet(`input${Lt}Indices`,pn,c.indicesGet("outputIndices",De))}`)})}})}else s.lhs.forEach((De,st)=>{if(he.inputIndices.includes(st)){let Lt=De.symbolToIndices.get(_e);if(Lt===void 0)throw new Error("Invalid symbol error");Lt.forEach(jt=>{G.push(`${d[st].indicesSet(`input${st}Indices`,jt,`${_e}`)}`)}),ie.push(`prod *= ${d[st].getByIndices(`input${st}Indices`)};`)}}),X.push(`for(var ${_e}: u32 = 0; ${_e} < uniforms.${tu(_e)}; ${_e}++) {`),ne.push("}")});let de=ee?[...$,`let sum = ${d.map((he,_e)=>he.getByIndices(`input${_e}Indices`)).join(" * ")};`]:[...$,m,...X,...G,k,...ie,K,...ne];return`
            ${b.registerUniforms(g.map(he=>({name:`${tu(he)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...d,c)}

            ${b.mainStart()}
            ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${c.offsetToIndices("global_idx")};
            ${d.map((he,_e)=>`var input${_e}Indices: ${d[_e].type.indices};`).join(`
`)}
            ${de.join(`
`)};
            ${c.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:s.equation,inputDependencies:n.map(()=>"rank")},getRunData:()=>{let b=g.filter(k=>s.symbolToInfo.has(k)).map(k=>{var m;return{type:12,data:((m=s.symbolToInfo.get(k))==null?void 0:m.dimValue)||0}});b.push({type:12,data:f});let $=n.map((k,m)=>[...Ft(k)]).reduce((k,m)=>k.concat(m),b);return $.push(...Ft(u)),{outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:$}},getShaderSource:v}},nu=(n,i)=>{let s=new Uh(n.inputs,i.equation),u=s.outputDims,d=n.inputs.map((f,c)=>f.dims);n.compute(Mp(d,n.inputs[0].dataType,s,u))},xp=n=>{let i=n.equation.replace(/\s+/g,"");return fn({equation:i})}}),ru,iu,Tp,ou,Vh,t_=_(()=>{nn(),Zt(),yn(),ru=n=>{if(!n||n.length!==2)throw new Error("Expand requires 2 input.");let i=n[0].dims,s=Array.from(n[1].getBigInt64Array(),Number),u=s.length<i.length?0:s.length-i.length,d=i.length<s.length?0:i.length-s.length;for(;u<s.length&&d<i.length;++u,++d)if(s[u]!==i[d]&&s[u]!==1&&i[d]!==1)throw new Error("Expand requires shape to be broadcastable to input")},iu=(n,i)=>{let s=n.length-i.length,u=[];for(let d=0;d<s;++d)u.push(n[d]);for(let d=0;d<i.length;++d)u.push(i[d]===1?n[d+s]:i[d]);return u},Tp=(n,i)=>n.length>i.length?iu(n,i):iu(i,n),ou=n=>{let i=n[0].dims,s=Array.from(n[1].getBigInt64Array(),Number),u=Tp(i,s),d=n[0].dataType,f=d===9?4:1,c=Math.ceil(Ae.size(u)/f),g=b=>{let $=ot("input",d,i.length,f),k=Yt("output",d,u.length,f),m;if(d===9){let K=(G,X,ne="")=>`
          let outputIndices${X} = ${k.offsetToIndices(`outputOffset + ${X}u`)};
          let offset${X} = ${$.broadcastedIndicesToOffset(`outputIndices${X}`,k)};
          let index${X} = offset${X} / 4u;
          let component${X} = offset${X} % 4u;
          ${G}[${X}] = ${ne}(${$.getByOffset(`index${X}`)}[component${X}]);
        `;m=`
        let outputOffset = global_idx * ${f};
        var data = vec4<u32>(0);
        ${K("data",0,"u32")}
        ${K("data",1,"u32")}
        ${K("data",2,"u32")}
        ${K("data",3,"u32")}
        ${k.setByOffset("global_idx","data")}
      }`}else m=`
        let outputIndices = ${k.offsetToIndices("global_idx")};
        let inputOffset = ${$.broadcastedIndicesToOffset("outputIndices",k)};
        ${k.setByOffset("global_idx",$.getByOffset("inputOffset"))}
      }`;return`
    ${b.registerUniform("vec_size","u32").declareVariables($,k)}
    ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${m}`},v=[{type:12,data:c},...Ft(i,u)];return{name:"Expand",shaderCache:{hint:`${u.length}`,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:[{dims:u,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:v})}},Vh=n=>{ru(n.inputs),n.compute(ou(n.inputs),{inputs:[0]})}}),su,au,Wh=_(()=>{nn(),Zt(),yn(),Fl(),su=n=>{let i=n[0].dataType,s=Ae.size(n[0].dims),u=Ae.size(n[1].dims),d=u%4===0,f=c=>{let g=ot("x",i,[1],4),v=ot("bias",i,[1],4),b=Yt("y",i,[1],4),$=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],k=K=>`
      let bias${K}_offset: u32 = (global_idx * 4 + ${K}) % uniforms.bias_size;
      let bias${K} = ${v.getByOffset(`bias${K}_offset / 4`)}[bias${K}_offset % 4];`,m=d?`
      let bias = ${v.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${k(0)}${k(1)}${k(2)}${k(3)}
      let bias = ${g.type.value}(bias0, bias1, bias2, bias3);`;return`${c.registerUniforms($).declareVariables(g,v,b)}

    ${Cl(Nn(i))}

    ${c.mainStart(Ir)}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${g.getByOffset("global_idx")};
      ${m}
      let x_in = x + bias;
      ${b.setByOffset("global_idx",Pl("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${d}`,inputDependencies:["type","type"]},getShaderSource:f,getRunData:c=>({outputs:[{dims:c[0].dims,dataType:c[0].dataType}],programUniforms:[{type:12,data:Math.ceil(s/4)},{type:12,data:u}],dispatchGroup:{x:Math.ceil(s/Ir/4)}})}},au=n=>{n.inputs.length<2||Ae.size(n.inputs[1].dims)===0?Md(n):n.compute(su(n.inputs))}}),Sp,lu,Ep,kp,Cp=_(()=>{nn(),Zt(),Ln(),yn(),Sp=n=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.")},lu=(n,i)=>{let s=n[0].dims,u=n[1].dims,d=s.length,f=Ae.normalizeAxis(i.axis,d),c=s.slice(0);c.splice(f,1,...u);let g=s[f],v=n[0].dataType===9?4:1,b=Math.ceil(Ae.size(c)/v),$=[{type:12,data:b},{type:6,data:g},{type:12,data:f},...Ft(n[0].dims,n[1].dims,c)],k=m=>{let K=ot("data",n[0].dataType,n[0].dims.length,v),G=ot("inputIndices",n[1].dataType,n[1].dims.length),X=Yt("output",n[0].dataType,c.length,v),ne=ee=>{let de=u.length,he=`var indicesIndices${ee}  = ${G.type.indices}(0);`;for(let _e=0;_e<de;_e++)he+=`${de>1?`indicesIndices${ee}[${_e}]`:`indicesIndices${ee}`} = ${c.length>1?`outputIndices${ee}[uniforms.axis + ${_e}]`:`outputIndices${ee}`};`;he+=`
          var idx${ee} = ${G.getByIndices(`indicesIndices${ee}`)};
          if (idx${ee} < 0) {
            idx${ee} = idx${ee} + uniforms.axisDimLimit;
          }
          var dataIndices${ee} : ${K.type.indices};
        `;for(let _e=0,Fe=0;_e<d;_e++)_e===f?(he+=`${d>1?`dataIndices${ee}[${_e}]`:`dataIndices${ee}`} = u32(idx${ee});`,Fe+=de):(he+=`${d>1?`dataIndices${ee}[${_e}]`:`dataIndices${ee}`} = ${c.length>1?`outputIndices${ee}[${Fe}]`:`outputIndices${ee}`};`,Fe++);return he},ie;if(n[0].dataType===9){let ee=(de,he,_e="")=>`
          let outputIndices${he} = ${X.offsetToIndices(`outputOffset + ${he}u`)};
          ${ne(he)};
          let offset${he} = ${K.indicesToOffset(`dataIndices${he}`)};
          let index${he} = offset${he} / 4u;
          let component${he} = offset${he} % 4u;
          ${de}[${he}] = ${_e}(${K.getByOffset(`index${he}`)}[component${he}]);
        `;ie=`
        let outputOffset = global_idx * ${v};
        var value = vec4<u32>(0);
        ${ee("value",0,"u32")}
        ${ee("value",1,"u32")}
        ${ee("value",2,"u32")}
        ${ee("value",3,"u32")}
        ${X.setByOffset("global_idx","value")}
      `}else ie=`
      let outputIndices = ${X.offsetToIndices("global_idx")};
      ${ne("")};
      let value = ${K.getByIndices("dataIndices")};
      ${X.setByOffset("global_idx","value")};
      `;return`
      ${m.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(K,G,X)}
      ${m.mainStart()}
        ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${ie}
      }`};return{name:"Gather",shaderCache:{hint:i.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:c,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:$}),getShaderSource:k}},Ep=n=>fn({axis:n.axis}),kp=(n,i)=>{let s=n.inputs;Sp(s),n.compute(lu(n.inputs,i))}}),Pp,$p,uu,Ap,Gh=_(()=>{nn(),Zt(),Ln(),yn(),Pp=(n,i)=>{if(n.length<3||n.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let s=Ae.normalizeAxis(i.quantizeAxis,n[0].dims.length),u=i.blockSize,d=n[0],f=n[2],c=n.length===4?n[3]:void 0;if(f.dims.length!==d.dims.length||!d.dims.map((g,v)=>v===s?Math.ceil(g/u)===f.dims[v]:g===f.dims[v]).reduce((g,v)=>g&&v,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(c){if(c.dataType!==d.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(c.dims.length!==f.dims.length||!c.dims.map((g,v)=>g===f.dims[v]).reduce((g,v)=>g&&v,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},$p=(n,i)=>{let s=n[0].dims,u=n[1].dims,d=s.length,f=Ae.normalizeAxis(i.gatherAxis,d),c=Ae.normalizeAxis(i.quantizeAxis,d),g=s.slice(0);g.splice(f,1,...u);let v=Ae.size(g),b=n[2].dataType,$=n[0].dataType===22,k=[{type:12,data:v},{type:12,data:c},{type:12,data:f},{type:12,data:i.blockSize},...Ft(...n.map((K,G)=>K.dims),g)],m=K=>{let G=ot("data",n[0].dataType,n[0].dims.length),X=ot("inputIndices",n[1].dataType,n[1].dims.length),ne=ot("scales",n[2].dataType,n[2].dims.length),ie=n.length>3?ot("zeroPoint",n[3].dataType,n[3].dims.length):void 0,ee=Yt("output",b,g.length),de=[G,X,ne];ie&&de.push(ie);let he=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${K.registerUniforms(he).declareVariables(...de,ee)}
        ${K.mainStart()}
        let output_indices = ${ee.offsetToIndices("global_idx")};
        var indices_indices = ${X.type.indices}(0);
        ${u.length>1?`
          for (var i: u32 = 0; i < ${u.length}; i++) {
            let index = ${ee.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${X.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${ee.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${G.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${ee.indicesGet("output_indices","i")};
          ${G.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${X.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${s[f]};
        }
        ${G.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${g.length}; i++) {
          let index = ${ee.indicesGet("output_indices",`i + ${u.length} - 1`)};
          ${G.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${G.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${G.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${$?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${ne.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${ne.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${ne.getByIndices("scale_indices")};
        ${ie?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${ie.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${ie.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${$?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Nn(b)}(quantized_data - zero_point) * scale;
        ${ee.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${i.cacheKey};${n.filter((K,G)=>G!==1).map(K=>K.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:n.length},(K,G)=>"rank")},getRunData:()=>({outputs:[{dims:g,dataType:b}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:k}),getShaderSource:m}},uu=(n,i)=>{let s=n.inputs;Pp(s,i),n.compute($p(n.inputs,i))},Ap=n=>fn({blockSize:n.blockSize,gatherAxis:n.gatherAxis,quantizeAxis:n.quantizeAxis})}),Fp,Ip,Un,qh,n_=_(()=>{nn(),Zt(),Ln(),yn(),Fp=n=>{if(!n||n.length!==2)throw new Error("GatherElements requires 2 inputs.");if(n[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(n[0].dims.length!==n[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Ip=(n,i)=>{let s=n[0].dims,u=n[0].dataType,d=s.length,f=n[1].dims,c=n[1].dataType,g=Ae.normalizeAxis(i.axis,d),v=s[g],b=f.slice(0),$=Ae.size(b),k=ot("input",u,d),m=ot("indicesInput",c,f.length),K=Yt("output",u,b.length),G=[{type:12,data:$},{type:6,data:v},{type:12,data:g}];return G.push(...Ft(s,f,b)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:b,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:G}),getShaderSource:X=>`
      ${X.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(k,m,K)}
      ${X.mainStart()}
      ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${K.offsetToIndices("global_idx")};

      var idx = ${m.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${k.type.indices}(outputIndices);
      ${k.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${k.getByIndices("inputIndices")};

      ${K.setByOffset("global_idx","value")};
  }`}},Un=n=>fn({axis:n.axis}),qh=(n,i)=>{let s=n.inputs;Fp(s),n.compute(Ip(n.inputs,i))}}),Hh,cu,Op,Dp,Kh=_(()=>{nn(),Zt(),yn(),Hh=n=>{if(!n)throw new Error("Input is missing");if(n.length<2||n.length>3)throw new Error("Invaid input number.");if(n.length===3&&n[2].dims.length>2)throw new Error("Invalid input shape of C");if(n[0].dataType!==n[1].dataType||n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("Input types are mismatched")},cu=(n,i)=>{let s=n[0].dims.slice(),u=n[1].dims.slice(),[d,f,c]=kr.getShapeOfGemmResult(s,i.transA,u,i.transB,n.length===3?n[2].dims:void 0),g=[d,f];if(!g)throw new Error("Can't use gemm on the given tensors");let v=Ae.size(g),b=[{type:12,data:v},{type:12,data:d},{type:12,data:f},{type:12,data:c},{type:1,data:i.alpha},{type:1,data:i.beta}],$=["type","type"];n.length===3&&(b.push(...Ft(n[2].dims)),$.push("rank")),b.push(...Ft(g));let k=m=>{let K="";i.transA&&i.transB?K="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":i.transA&&!i.transB?K="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!i.transA&&i.transB?K="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!i.transA&&!i.transB&&(K="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let G=i.alpha===1?"":"value *= uniforms.alpha;",X=ot("a",n[0].dataType,n[0].dims),ne=ot("b",n[1].dataType,n[1].dims),ie=X.type.value,ee=null,de=[X,ne];n.length===3&&(ee=ot("c",n[2].dataType,n[2].dims.length),de.push(ee));let he=Yt("output",n[0].dataType,g.length);de.push(he);let _e=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${m.registerUniforms(_e).declareVariables(...de)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${ie}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${K}
    }

    ${G}
    ${ee!=null?`let cOffset = ${ee.broadcastedIndicesToOffset("vec2(m, n)",he)}; value += ${ie}(uniforms.beta) * ${ee.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${i.cacheKey}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:g,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:b}),getShaderSource:k}},Op=n=>{let i=n.transA,s=n.transB,u=n.alpha,d=n.beta;return{transA:i,transB:s,alpha:u,beta:d,cacheKey:`${n.transA};${n.transB};${n.alpha===1}`}},Dp=(n,i)=>{Hh(n.inputs),n.compute(cu(n.inputs,i))}}),Ur,du,pu,fu,zp,qo,Xh,Qh=_(()=>{nn(),Zt(),Ln(),ve(),oa(),yn(),Bi(),Ur=(n,i)=>n.length>i&&n[i].dims.length>0?n[i]:void 0,du=(n,i)=>{let s=n[0],u=Ur(n,1),d=Ur(n,2),f=Ur(n,3),c=Ur(n,4),g=Ur(n,5),v=Ur(n,6),b=Ur(n,7);if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let $=s.dims[0],k=s.dims[1],m=s.dims.length===3?s.dims[2]:i.numHeads*s.dims[4],K=k,G=0,X=0,ne=Math.floor(m/i.numHeads);if(v&&b&&Ae.size(v.dims)&&Ae.size(b.dims)){if(v.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(v.dims[0]!==$||v.dims[1]!==i.numHeads||v.dims[3]!==ne)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(b.dims[0]!==$||b.dims[1]!==i.numHeads||b.dims[3]!==ne)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(v.dims[2]!==b.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(b.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');G=v.dims[2],X=v.dims[2]}else if(v&&Ae.size(v.dims)||b&&Ae.size(b.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let ie;if(u&&Ae.size(u.dims)>0){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(u.dims.length<3||u.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==u.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(u.dims.length===3){if(u.dims[2]!==s.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');ie=2,K=u.dims[1]}else if(u.dims.length===5){if(u.dims[2]!==i.numHeads||u.dims[3]!==2||u.dims[4]!==ne)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');ie=5,K=u.dims[1]}else{if(u.dims[1]!==i.numHeads||u.dims[3]!==ne)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');ie=0,K=u.dims[2]}}else{if(s.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(s.dims[2]!==i.numHeads||s.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');ie=3}if(f&&Ae.size(f.dims)>0){if(f.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(u&&u.dims.length===5&&u.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let ee=G+K,de=0;if(c&&Ae.size(c.dims)>0){de=8;let De=c.dims;throw De.length===1?De[0]===$?de=1:De[0]===3*$+2&&(de=3):De.length===2&&De[0]===$&&De[1]===ee&&(de=5),de===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let he=!1,_e=m;if(d&&Ae.size(d.dims)>0){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(K!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');_e=d.dims[2]}else{if(K!==d.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');_e=d.dims[1]*d.dims[3],he=!0}}let Fe=!1;if(c&&Ae.size(c.dims)>0)throw new Error("Key padding mask is not supported");if(g&&Ae.size(g.dims)>0){if(g.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(g.dims[0]!==$||g.dims[1]!==i.numHeads||g.dims[2]!==k||g.dims[3]!==ee)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:$,sequenceLength:k,pastSequenceLength:G,kvSequenceLength:K,totalSequenceLength:ee,maxSequenceLength:X,inputHiddenSize:0,hiddenSize:m,vHiddenSize:_e,headSize:ne,vHeadSize:Math.floor(_e/i.numHeads),numHeads:i.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:i.maskFilterValue,maskType:de,scale:i.scale,broadcastResPosBias:Fe,passPastInKv:he,qkvFormat:ie}},pu=n=>fn({...n}),fu=fn({perm:[0,2,1,3]}),zp=(n,i,s,u,d,f,c)=>{let g=[u,d,f],v=Ae.size(g),b=[{type:12,data:v},{type:12,data:c},{type:12,data:f}],$=k=>{let m=Yt("qkv_with_bias",i.dataType,g),K=ot("qkv",i.dataType,g),G=ot("bias",s.dataType,g),X=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${k.registerUniforms(X).declareVariables(K,G,m)}
  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return n.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:g,dataType:i.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:b}),getShaderSource:$},{inputs:[i,s],outputs:[-1]})[0]},qo=(n,i,s,u,d,f,c,g)=>{let v=f;if(c&&Ae.size(c.dims)>0){if(u===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return v=zp(n,f,c,i,u,s*d,g),v=v.reshape([i,u,s,d]),s===1||u===1?v:n.compute(Zr(v,fu.perm),{inputs:[v],outputs:[-1]})[0]}else return f.dims.length===3&&(v=f.reshape([i,u,s,d])),s===1||u===1?v:n.compute(Zr(v,fu.perm),{inputs:[v],outputs:[-1]})[0]},Xh=(n,i)=>{let s=du(n.inputs,i),u=n.inputs[0],d=Ur(n.inputs,1),f=Ur(n.inputs,2),c=Ur(n.inputs,3),g=Ur(n.inputs,4),v=Ur(n.inputs,5),b=Ur(n.inputs,6),$=Ur(n.inputs,7);if(u.dims.length===5)throw new Error("Packed QKV is not implemented");if((d==null?void 0:d.dims.length)===5)throw new Error("Packed KV is not implemented");let k=d&&f&&d.dims.length===4&&f.dims.length===4,m=qo(n,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,u,c,0);if(k)return Go(n,m,d,f,g,void 0,b,$,v,s);if(!d||!f)throw new Error("key and value must be provided");let K=qo(n,s.batchSize,s.numHeads,s.kvSequenceLength,s.headSize,d,c,s.hiddenSize),G=qo(n,s.batchSize,s.numHeads,s.kvSequenceLength,s.vHeadSize,f,c,2*s.hiddenSize);Go(n,m,K,G,g,void 0,b,$,v,s)}}),Lp,Rp,Bp,Np,hu,Up,jp,Vp=_(()=>{nn(),Zt(),Ln(),yn(),Lp=n=>{if(!n||n.length<1)throw new Error("too few inputs")},Rp=(n,i)=>{let s=[],u=i.numOutputs;return n[1].dims[0]>0&&(n[1].getBigInt64Array().forEach(d=>s.push(Number(d))),u=s.length),fn({numOutputs:u,axis:i.axis,splitSizes:s})},Bp=n=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
    if (index < ${Kt("uniforms.size_in_split_axis","i",n)}) {
        return i;
    }
    }
    return ${n}u;
}`,Np=n=>{let i=n.length,s=[];for(let u=0;u<i;++u){let d=n[u].setByIndices("indices","input[global_idx]");i===1?s.push(d):u===0?s.push(`if (output_number == ${u}u) { ${d} }`):u===i-1?s.push(`else { ${d} }`):s.push(`else if (output_number == ${u}) { ${d} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${n[0].type.indices}, global_idx: u32) {
        ${s.join(`
`)}
      }`},hu=(n,i)=>{let s=n[0].dims,u=Ae.size(s),d=n[0].dataType,f=Ae.normalizeAxis(i.axis,s.length),c=new Array(i.numOutputs),g=ot("input",d,s.length),v=new Array(i.numOutputs),b=[],$=[],k=0,m=[{type:12,data:u}];for(let G=0;G<i.numOutputs;G++){k+=i.splitSizes[G],v[G]=k;let X=s.slice();X[f]=i.splitSizes[G],$.push(X),c[G]=Yt(`output${G}`,d,X.length),b.push({dims:$[G],dataType:n[0].dataType})}m.push({type:12,data:v},...Ft(s,...$));let K=G=>`
  ${G.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",v.length).declareVariables(g,...c)}
  ${Bp(v.length)}
  ${Np(c)}

  ${G.mainStart()}
    ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${g.offsetToIndices("global_idx")};
    var index = ${g.indicesGet("indices",f)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Kt("uniforms.size_in_split_axis","output_number - 1u",v.length)};
      ${g.indicesSet("indices",f,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getShaderSource:K,getRunData:()=>({outputs:b,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:m})}},Up=(n,i)=>{Lp(n.inputs);let s=n.inputs.length===1?i:Rp(n.inputs,i);n.compute(hu(n.inputs,s),{inputs:[0]})},jp=n=>{let i=n.axis,s=n.splitSizes,u=n.numOutputs<0?s.length:n.numOutputs;if(u!==s.length)throw new Error("numOutputs and splitSizes lengh must be equal");return fn({axis:i,numOutputs:u,splitSizes:s})}}),Wp,Gp,mu,qp,Yh=_(()=>{Ln(),oa(),Qh(),Vp(),Bi(),Wp=(n,i)=>{if(i.doRotary&&n.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let s=n[0],u=n[1],d=n[2],f=n[3],c=n[4];if(i.localWindowSize!==-1)throw new Error("Local attention is not supported");if(i.softcap!==0)throw new Error("Softcap is not supported");if(i.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(i.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let g=!1,v=s.dims[0],b=s.dims[1],$=s.dims.length===3?g?s.dims[2]/3:s.dims[2]:i.numHeads*s.dims[4],k=b,m=0,K=!u||u.dims.length===0,G=Math.floor(K?$/(i.numHeads+2*i.kvNumHeads):$/i.numHeads);K&&($=G*i.numHeads);let X=f&&f.dims.length!==0,ne=c&&c.dims.length!==0;if(X&&f.dims.length===4&&f.dims[0]===v&&f.dims[1]!==i.kvNumHeads&&f.dims[2]===i.kvNumHeads&&f.dims[3]===G)throw new Error("BSNH pastKey/pastValue is not supported");if(X&&ne){if(f.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(c.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');m=f.dims[2]}else if(X||ne)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let ie=1;if(u&&u.dims.length>0){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(u.dims.length<3||u.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==u.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(u.dims.length===3){if(s.dims[2]%u.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');k=u.dims[1]}else if(u.dims.length===5){if(u.dims[2]!==i.numHeads||u.dims[3]!==2||u.dims[4]!==G)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');k=u.dims[1]}else{if(u.dims[1]!==i.numHeads||u.dims[3]!==G)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');k=u.dims[2]}}else{if(s.dims.length!==3&&s.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(s.dims.length===5&&(s.dims[2]!==i.numHeads||s.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');ie=3}let ee=0,de=!1,he=i.kvNumHeads?G*i.kvNumHeads:$;if(d&&d.dims.length>0){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(k!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');he=d.dims[2]}else{if(k!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');he=d.dims[1]*d.dims[3],de=!0}}let _e=n.length>4?n[5]:void 0;if(_e&&_e.dims.length!==1&&_e.dims[0]!==v)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:v,sequenceLength:b,pastSequenceLength:m,kvSequenceLength:k,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:$,vHiddenSize:he,headSize:G,vHeadSize:Math.floor(he/i.kvNumHeads),numHeads:i.numHeads,kvNumHeads:i.kvNumHeads,nReps:i.numHeads/i.kvNumHeads,pastPresentShareBuffer:!1,maskType:ee,scale:i.scale,broadcastResPosBias:!1,passPastInKv:de,qkvFormat:ie}},Gp=fn({perm:[0,2,1,3]}),mu=(n,i,s)=>{let u=i,d=s.kvNumHeads;return i.dims.length===3&&s.kvSequenceLength!==0&&(u=i.reshape([s.batchSize,s.kvSequenceLength,d,s.headSize]),u=n.compute(Zr(u,Gp.perm),{inputs:[u],outputs:[-1]})[0]),u},qp=(n,i)=>{var ne;let s=Wp(n.inputs,i);if(n.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((ne=n.inputs[1])==null?void 0:ne.dims.length)===5)throw new Error("Packed KV is not implemented");let u=n.inputs[0],d=n.inputs[1]&&n.inputs[1].dims.length>0?n.inputs[1]:void 0,f=n.inputs[2]&&n.inputs[2].dims.length>0?n.inputs[2]:void 0,c=n.inputs[3]&&n.inputs[3].dims.length!==0?n.inputs[3]:void 0,g=n.inputs[4]&&n.inputs[4].dims.length!==0?n.inputs[4]:void 0,v=n.inputs.length>4?n.inputs[5]:void 0,b=n.inputs.length>5?n.inputs[6]:void 0,$=s.kvNumHeads?s.kvNumHeads:s.numHeads,k=fn({axis:2,numOutputs:3,splitSizes:[s.numHeads*s.headSize,$*s.headSize,$*s.headSize]}),[m,K,G]=!d&&!f?n.compute(hu([u],k),{inputs:[u],outputs:[-1,-1,-1]}):[u,d,f],X=qo(n,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,m,void 0,0);Go(n,X,mu(n,K,s),mu(n,G,s),void 0,void 0,c,g,void 0,s,v,b)}}),gu,Hp,Kp,Xp,r_=_(()=>{nn(),Zt(),Bi(),yn(),gu=(n,i,s,u,d,f,c,g)=>{let v=Mn(f),b=v===1?"f32":`vec${v}f`,$=v===1?"vec2f":`mat2x${v}f`,k=d*c,m=[d,c,f/v],K=[d,c,2],G=["rank","type","type"],X=[];X.push(...Ft(m,K));let ne=ie=>{let ee=ot("x",i.dataType,3,v),de=ot("scale",s.dataType,s.dims),he=ot("bias",u.dataType,u.dims),_e=Yt("output",1,3,2),Fe=[ee,de,he,_e],De=64;return`
  var<workgroup> workgroup_shared : array<${$}, ${De}>;
  const workgroup_size = ${De}u;
  ${ie.declareVariables(...Fe)}
  ${ie.mainStart(De)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${b}(0);
    var squared_sum = ${b}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${b}(${ee.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${$}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Ri("workgroup_shared[0][0]",v)} / f32(hight * ${v});
      let squared_sum_final = ${Ri("workgroup_shared[0][1]",v)} / f32(hight * ${v});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${g}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return n.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${v};${g}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:K,dataType:1}],dispatchGroup:{x:k},programUniforms:X}),getShaderSource:ne},{inputs:[i,s,u],outputs:[-1]})[0]},Hp=(n,i,s)=>{let u=i[0].dims,d=u,f=2,c=u[0],g=u[1],v=Ae.sizeFromDimension(u,f),b=Mn(v),$=Ae.size(d)/b,k=gu(n,i[0],i[1],i[2],c,v,g,s.epsilon),m=[c,g,v/b],K=[c,g],G=["type","none"],X=ne=>{let ie=ot("x",i[0].dataType,m.length,b),ee=ot("scale_shift",1,K.length,2),de=Yt("output",i[0].dataType,m.length,b),he=[ie,ee,de];return`
  ${ne.registerUniform("output_size","u32").declareVariables(...he)}
  ${ne.mainStart()}
  ${ne.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${de.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${ee.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${ie.getByOffset("global_idx")} * ${de.type.value}(scale_shift.x) + ${de.type.value}(scale_shift.y);
      ${de.setByOffset("global_idx","value")};
  }`};n.compute({name:"InstanceNormalization",shaderCache:{hint:`${b}`,inputDependencies:G},getRunData:()=>({outputs:[{dims:d,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:[{type:12,data:$},...Ft(m,K,m)]}),getShaderSource:X},{inputs:[i[0],k]})},Kp=(n,i,s)=>{let u=i[0].dims,d=u,f=u[0],c=u[u.length-1],g=Ae.sizeFromDimension(u,1)/c,v=Mn(c),b=Ae.size(d)/v,$=[{type:12,data:g},{type:12,data:Math.floor(c/v)}],k=["type","type"],m=[0,u.length-1];for(let ne=0;ne<u.length-2;ne++)m.push(ne+1);let K=n.compute(Zr(n.inputs[0],m),{inputs:[n.inputs[0]],outputs:[-1]})[0],G=gu(n,K,i[1],i[2],f,g,c,s.epsilon),X=ne=>{let ie=vn(i[0].dataType),ee=v===1?"vec2f":`mat${v}x2f`,de=Fe=>{let De=Fe===0?"x":"y",st=v===1?"f32":`vec${v}f`;switch(v){case 1:return`${ie}(${st}(scale.${De}))`;case 2:return`vec2<${ie}>(${st}(scale[0].${De}, scale[1].${De}))`;case 4:return`vec4<${ie}>(${st}(scale[0].${De}, scale[1].${De}, scale[2].${De}, scale[3].${De}))`;default:throw new Error(`Not supported compoents ${v}`)}},he=ot("input",i[0].dataType,i[0].dims,v),_e=Yt("output",i[0].dataType,d,v);return`
  @group(0) @binding(0) var<storage, read> input : array<${he.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${ee}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${_e.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${ne.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${de(0)}, ${de(1)});
  }`};n.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${v}`,inputDependencies:k},getRunData:()=>({outputs:[{dims:d,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:$}),getShaderSource:X},{inputs:[i[0],G]})},Xp=(n,i)=>{i.format==="NHWC"?Kp(n,n.inputs,i):Hp(n,n.inputs,i)}}),_u,Qp,Yp,Jh=_(()=>{nn(),Zt(),yn(),_u=n=>{if(!n||n.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Qp=(n,i,s)=>{let u=i.simplified,d=n[0].dims,f=n[1],c=!u&&n[2],g=d,v=Ae.normalizeAxis(i.axis,d.length),b=Ae.sizeToDimension(d,v),$=Ae.sizeFromDimension(d,v),k=Ae.size(f.dims),m=c?Ae.size(c.dims):0;if(k!==$||c&&m!==$)throw new Error(`Size of X.shape()[axis:] == ${$}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${k} and bias size of ${m}`);let K=[];for(let _e=0;_e<d.length;++_e)_e<v?K.push(d[_e]):K.push(1);let G=Mn($),X=["type","type"],ne=[{type:12,data:b},{type:1,data:$},{type:12,data:Math.floor($/G)},{type:1,data:i.epsilon}];c&&X.push("type");let ie=s>1,ee=s>2,de=_e=>{let Fe=vn(n[0].dataType),De=[ot("x",n[0].dataType,n[0].dims,G),ot("scale",f.dataType,f.dims,G)];c&&De.push(ot("bias",c.dataType,c.dims,G)),De.push(Yt("output",n[0].dataType,g,G)),ie&&De.push(Yt("mean_data_output",1,K)),ee&&De.push(Yt("inv_std_output",1,K));let st=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${_e.registerUniforms(st).declareVariables(...De)}
  ${_e.mainStart()}
    ${_e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${bo("f32",G)};
    var mean_square_vector = ${bo("f32",G)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${eo(Fe,G,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Ri("mean_vector",G)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Ri("mean_square_vector",G)} / uniforms.norm_size ${u?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${eo(Fe,G,"x[j + offset]")};
      let f32scale = ${eo(Fe,G,"scale[j]")};
      output[j + offset] = ${De[0].type.value}((f32input ${u?"":"- mean"}) * inv_std_dev * f32scale
        ${c?`+ ${eo(Fe,G,"bias[j]")}`:""}
      );
    }

    ${ie?"mean_data_output[global_idx] = mean":""};
    ${ee?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},he=[{dims:g,dataType:n[0].dataType}];return ie&&he.push({dims:K,dataType:1}),ee&&he.push({dims:K,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${G};${s};${u}`,inputDependencies:X},getRunData:()=>({outputs:he,dispatchGroup:{x:Math.ceil(b/64)},programUniforms:ne}),getShaderSource:de}},Yp=(n,i)=>{_u(n.inputs),n.compute(Qp(n.inputs,i,n.outputCount))}}),Jp,Zp,ef,tf,nf,Zh=_(()=>{nn(),Zt(),Ln(),yn(),Jp=(n,i)=>{if(n.length<3||n.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let s=n[0],u=s.dims.length;if(s.dims[u-1]!==i.k)throw new Error("The last dim of input shape does not match the k value");let d=Math.floor((i.k+i.blockSize-1)/i.blockSize),f=i.blockSize/8*i.bits,c=n[1];if(!Ae.areEqual(c.dims,[i.n,d,f]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let g=n[2].dims;if(Ae.size(g)!==i.n*d)throw new Error("scales input size error.");if(n.length===4){let v=n[3].dims,b=i.bits>4?i.n*d:i.n*Math.floor((d+1)/2);if(Ae.size(v)!==b)throw new Error("zeroPoints input size error.")}},Zp=(n,i)=>{let s=n[0].dims,u=s.length,d=s[u-2],f=i.k,c=i.n,g=s.slice(0,u-2),v=Ae.size(g),b=n[1].dims[2]/4,$=n[0].dataType,k=Mn(i.k),m=Mn(b),K=Mn(c),G=g.concat([d,c]),X=d>1&&c/K%2===0?2:1,ne=Ae.size(G)/K/X,ie=64,ee=[],de=[v,d,f/k],he=Ae.convertShape(n[1].dims).slice();he.splice(-1,1,b/m),ee.push(...Ft(de)),ee.push(...Ft(he)),ee.push(...Ft(n[2].dims)),n.length===4&&ee.push(...Ft(Ae.convertShape(n[3].dims)));let _e=[v,d,c/K];ee.push(...Ft(_e));let Fe=De=>{let st=de.length,Lt=ot("a",n[0].dataType,st,k),jt=ot("b",12,he.length,m),pn=ot("scales",n[2].dataType,n[2].dims.length),un=[Lt,jt,pn],Jt=n.length===4?ot("zero_points",12,n[3].dims.length):void 0;Jt&&un.push(Jt);let In=_e.length,Yn=Yt("output",n[0].dataType,In,K),wn=vn(n[0].dataType),Bn=(()=>{switch(k){case 1:return`array<${wn}, 8>`;case 2:return`mat4x2<${wn}>`;case 4:return`mat2x4<${wn}>`;default:throw new Error(`${k}-component is not supported.`)}})(),Qt=()=>{let Ke=`
          // reuse a data
            var input_offset = ${Lt.indicesToOffset(`${Lt.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Bn};
            for (var j: u32 = 0; j < ${8/k}; j++) {
              a_data[j] = ${Lt.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let kt=0;kt<K*X;kt++)Ke+=`
            b_value = ${m===1?`b${kt}_data`:`b${kt}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Bn}(${Array.from({length:4},(ln,Gn)=>`${wn}(b_value_lower[${Gn}]), ${wn}(b_value_upper[${Gn}])`).join(", ")});
            b_dequantized_values = ${k===1?`${Bn}(${Array.from({length:8},(ln,Gn)=>`(b_quantized_values[${Gn}] - ${Jt?`zero_point${kt}`:"zero_point"}) * scale${kt}`).join(", ")});`:`(b_quantized_values - ${Bn}(${Array(8).fill(`${Jt?`zero_point${kt}`:"zero_point"}`).join(",")})) * scale${kt};`};
            workgroup_shared[local_id.x * ${X} + ${Math.floor(kt/K)}]${K>1?`[${kt%K}]`:""} += ${Array.from({length:8/k},(ln,Gn)=>`${k===1?`a_data[${Gn}] * b_dequantized_values[${Gn}]`:`dot(a_data[${Gn}], b_dequantized_values[${Gn}])`}`).join(" + ")};
          `;return Ke},tn=()=>{let Ke=`
            var col_index = col * ${K};
            ${Jt?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${wn}(8);`}
            `;for(let kt=0;kt<K*X;kt++)Ke+=`
            let scale${kt} = ${pn.getByOffset("col_index * nBlocksPerCol + block")};
            ${Jt?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${Jt.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${kt} = ${wn}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return Ke},Pn=()=>{let Ke=`col_index = col * ${K};`;for(let kt=0;kt<K*X;kt++)Ke+=`
            let b${kt}_data = ${jt.getByIndices(`${jt.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return Ke+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Bn};
            var b_dequantized_values: ${Bn};`,Ke};return`
        var<workgroup> workgroup_shared: array<${Yn.type.value}, ${X*ie}>;
        ${De.declareVariables(...un,Yn)}
        ${De.mainStart([ie,1,1])}
          let output_indices = ${Yn.offsetToIndices(`(global_idx / ${ie}) * ${X}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${ie}) {
            //process one block
            var word_offset: u32 = block * ${i.blockSize/k};
            ${tn()}
            for (var word: u32 = 0; word < ${b}; word += ${m}) {
              ${Pn()}
              for (var i: u32 = 0; i < ${m}; i++) {
                ${Qt()}
                word_offset += ${8/k};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${X}) {
            var output_value: ${Yn.type.value} = ${Yn.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${ie}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${X};
            }
            ${Yn.setByIndices(`${Yn.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${i.blockSize};${i.bits};${k};${m};${K};${X};${ie}`,inputDependencies:Array(n.length).fill("rank")},getRunData:()=>({outputs:[{dims:G,dataType:$}],dispatchGroup:{x:ne},programUniforms:ee}),getShaderSource:Fe}},ef=(n,i)=>{let s=n[0].dims,u=s.length,d=s[u-2],f=i.k,c=i.n,g=s.slice(0,u-2),v=Ae.size(g),b=n[1].dims[2]/4,$=n[0].dataType,k=Mn(i.k),m=Mn(b),K=g.concat([d,c]),G=128,X=c%8===0?8:c%4===0?4:1,ne=G/X,ie=ne*m*8,ee=ie/k,de=ie/i.blockSize,he=Ae.size(K)/X,_e=[],Fe=[v,d,f/k],De=Ae.convertShape(n[1].dims).slice();De.splice(-1,1,b/m),_e.push(...Ft(Fe)),_e.push(...Ft(De)),_e.push(...Ft(n[2].dims)),n.length===4&&_e.push(...Ft(Ae.convertShape(n[3].dims)));let st=[v,d,c];_e.push(...Ft(st));let Lt=jt=>{let pn=Fe.length,un=ot("a",n[0].dataType,pn,k),Jt=ot("b",12,De.length,m),In=ot("scales",n[2].dataType,n[2].dims.length),Yn=[un,Jt,In],wn=n.length===4?ot("zero_points",12,n[3].dims.length):void 0;wn&&Yn.push(wn);let Bn=st.length,Qt=Yt("output",n[0].dataType,Bn),tn=vn(n[0].dataType),Pn=()=>{switch(k){case 1:return`
          let a_data0 = vec4<${tn}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${tn}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${tn}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${tn}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${k}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${un.type.value}, ${ee}>;
        var<workgroup> inter_results: array<array<${Qt.type.value}, ${ne}>, ${X}>;
        ${jt.declareVariables(...Yn,Qt)}
        ${jt.mainStart([ne,X,1])}
          let output_indices = ${Qt.offsetToIndices(`workgroup_index * ${X}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${de} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${ee};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${ee}; a_offset += ${G})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${un.getByIndices(`${un.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${un.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${de} + local_id.x;
            ${wn?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${wn.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${tn}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${tn}(8);`}
            let scale = ${In.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${Jt.getByIndices(`${Jt.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${i.blockSize/k};
            for (var i: u32 = 0; i < ${m}; i++) {
              ${Pn()}
              let b_value = ${m===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${tn}>(${Array.from({length:4},(Ke,kt)=>`${tn}(b_value_lower[${kt}]), ${tn}(b_value_upper[${kt}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${tn}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Ke,kt)=>`${`dot(a_data${kt}, b_dequantized_values[${kt}])`}`).join(" + ")};
              word_offset += ${8/k};
            }
            workgroupBarrier();
          }

          if (local_idx < ${X}) {
            var output_value: ${Qt.type.value} = ${Qt.type.value}(0);
            for (var b = 0u; b < ${ne}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${Qt.setByIndices(`${Qt.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${i.blockSize};${k};${m};${ne};${X}`,inputDependencies:Array(n.length).fill("rank")},getRunData:()=>({outputs:[{dims:K,dataType:$}],dispatchGroup:{x:he},programUniforms:_e}),getShaderSource:Lt}},tf=(n,i)=>{Jp(n.inputs,i),i.blockSize===32&&n.adapterInfo.isVendor("intel")&&n.adapterInfo.isArchitecture("gen-12lp")?n.compute(ef(n.inputs,i)):n.compute(Zp(n.inputs,i))},nf=n=>fn(n)}),rf,of,sf,af,lf,uf,cf,df,pf,em=_(()=>{nn(),Zt(),yn(),rf=n=>{if(!n||n.length<1)throw new Error("Too few inputs");if(n[0].dataType!==1&&n[0].dataType!==10)throw new Error("Input type must be float or float16.");if(n.length>=2){let i=n[0].dims.length*2===n[1].dims[0];if(n.length===4&&(i=n[3].dims[0]*2===n[1].dims[0]),!i)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},of=(n,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
            k = i32(${n.indicesGet("indices",d)}) - ${Kt("uniforms.pads",d,s)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Kt("uniforms.x_shape",d,i)})) {
              break;
            }
            offset += k * i32(${Kt("uniforms.x_strides",d,i)});
        `;return`
          value = ${n.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${u}
            value = x[offset];
          }
      `},sf=(n,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
                k = i32(${n.indicesGet("indices",d)}) - ${Kt("uniforms.pads",d,s)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Kt("uniforms.x_shape",d,i)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Kt("uniforms.x_shape",d,i)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Kt("uniforms.x_strides",d,i)});
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},af=(n,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
                k = i32(${n.indicesGet("indices",d)}) - ${Kt("uniforms.pads",d,s)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Kt("uniforms.x_shape",d,i)})) {
                  k = i32(${Kt("uniforms.x_shape",d,i)}) - 1;
                }
                offset += k * i32(${Kt("uniforms.x_strides",d,i)});
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},lf=(n,i,s)=>{let u="";for(let d=i-1;d>=0;--d)u+=`
                k = i32(${n.indicesGet("indices",d)}) - ${Kt("uniforms.pads",d,s)};
                if (k < 0)  {
                  k += i32(${Kt("uniforms.x_shape",d,i)}]);
                }
                if (k >= i32(${Kt("uniforms.x_shape",d,i)})) {
                  k -= i32(${Kt("uniforms.x_shape",d,i)});
                }
                offset += k * i32(${Kt("uniforms.x_strides",d,i)});
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},uf=(n,i,s)=>{switch(s.mode){case 0:return of(n,i,s.pads.length);case 1:return sf(n,i,s.pads.length);case 2:return af(n,i,s.pads.length);case 3:return lf(n,i,s.pads.length);default:throw new Error("Invalid mode")}},cf=(n,i)=>{let s=Ae.padShape(n[0].dims.slice(),i.pads),u=n[0].dims,d=Ae.size(s),f=[{type:12,data:d},{type:6,data:i.pads}],c=n.length>=3&&n[2].data;i.mode===0&&f.push({type:c?n[2].dataType:1,data:i.value}),f.push(...Ft(n[0].dims,s));let g=["rank"],v=b=>{let $=Yt("output",n[0].dataType,s.length),k=ot("x",n[0].dataType,u.length),m=k.type.value,K=uf($,u.length,i),G=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:i.pads.length}];return i.mode===0&&G.push({name:"constant_value",type:c?m:"f32"}),`
            ${b.registerUniforms(G).declareVariables(k,$)}
            ${b.mainStart()}
            ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${$.offsetToIndices("global_idx")};

            var value = ${m}(0);
            ${K}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${i.mode}${c}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(Ae.size(s)/64)},programUniforms:f}),getShaderSource:v}},df=(n,i)=>{if(n.length>1){let s=n[1].getBigInt64Array(),u=n.length>=3&&n[2].data?n[2].dataType===10?n[2].getUint16Array()[0]:n[2].getFloat32Array()[0]:0,d=n[0].dims.length,f=new Int32Array(2*d).fill(0);if(n.length>=4){let g=n[3].getBigInt64Array();for(let v=0;v<g.length;v++)f[Number(g[v])]=Number(s[v]),f[Number(g[v])+d]=Number(s[v+g.length])}else s.forEach((g,v)=>f[Number(v)]=Number(g));let c=[];return f.forEach(g=>c.push(g)),{mode:i.mode,value:u,pads:c}}else return i},pf=(n,i)=>{rf(n.inputs);let s=df(n.inputs,i);n.compute(cf(n.inputs,s),{inputs:[0]})}}),Ss,yu,wu,vu,bu,ff,hf,Mu,mf,_n,gf,Mr,Cr,Dr,so,tm,_f,yf,S,R=_(()=>{Dt(),nn(),Zt(),yn(),Ss=n=>{if(L.webgpu.validateInputContent&&(!n||n.length!==1))throw new Error("Pool ops requires 1 input.")},yu=(n,i,s)=>{let u=i.format==="NHWC",d=n.dims.slice();u&&d.splice(1,0,d.pop());let f=Object.hasOwnProperty.call(i,"dilations"),c=i.kernelShape.slice(),g=i.strides.slice(),v=f?i.dilations.slice():[],b=i.pads.slice();_r.adjustPoolAttributes(s,d,c,g,v,b);let $=_r.computePoolOutputShape(s,d,g,v,c,b,i.autoPad),k=Object.assign({},i);f?Object.assign(k,{kernelShape:c,strides:g,pads:b,dilations:v,cacheKey:i.cacheKey}):Object.assign(k,{kernelShape:c,strides:g,pads:b,cacheKey:i.cacheKey});let m=$.slice();return m.push(m.splice(1,1)[0]),[k,u?m:$]},wu=(n,i)=>{let s=i.format==="NHWC",u=Ae.size(n),d=Ae.size(i.kernelShape),f=[{type:12,data:u},{type:12,data:d}],c=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(i.kernelShape.length<=2){let g=i.kernelShape[i.kernelShape.length-1],v=i.strides[i.strides.length-1],b=i.pads[i.pads.length/2-1],$=i.pads[i.pads.length-1],k=!!(b+$);f.push({type:12,data:g},{type:12,data:v},{type:12,data:b},{type:12,data:$}),c.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let m=!1;if(i.kernelShape.length===2){let K=i.kernelShape[i.kernelShape.length-2],G=i.strides[i.strides.length-2],X=i.pads[i.pads.length/2-2],ne=i.pads[i.pads.length-2];m=!!(X+ne),f.push({type:12,data:K},{type:12,data:G},{type:12,data:X},{type:12,data:ne}),c.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[f,c,!0,k,m]}else{if(s)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let g=Ae.computeStrides(i.kernelShape);f.push({type:12,data:g},{type:12,data:i.pads},{type:12,data:i.strides}),c.push({name:"kernelStrides",type:"u32",length:g.length},{name:"pads",type:"u32",length:i.pads.length},{name:"strides",type:"u32",length:i.strides.length});let v=i.pads.reduce((b,$)=>b+$);return[f,c,!!v,!1,!1]}},vu=(n,i,s,u,d,f,c,g,v,b,$,k)=>{let m=d.format==="NHWC",K=i.type.value,G=Yt("output",i.type.tensor,u);if(d.kernelShape.length<=2){let X="",ne="",ie="",ee=s-(m?2:1);if($?X=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${ee}] = indices[${ee}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${ee}] < 0 || xIndices[${ee}]
                      >= uniforms.x_shape[${ee}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${i.indicesToOffset("xIndices")}];
                  ${f}
                }`:X=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${ee}] = indices[${ee}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${i.indicesToOffset("xIndices")}];
                  ${f}
                }`,d.kernelShape.length===2){let de=s-(m?3:2);k?ne=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${de}] = indices[${de}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${de}] < 0 || xIndices[${de}] >= uniforms.x_shape[${de}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:ne=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${de}] = indices[${de}] * uniforms.sh - uniforms.phStart + j;
                `,ie=`
              }
            `}return`
            ${n.registerUniforms(v).declareVariables(i,G)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${G.offsetToIndices("global_idx")};
              var xIndices = ${G.offsetToIndices("global_idx")};

              var value = ${K}(${g});
              var pad = 0;
              ${ne}
              ${X}
              ${ie}
              ${c}

              output[global_idx] = value;
            }`}else{if(m)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let X=d.kernelShape.length,ne=d.pads.length,ie="";return b?ie=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${i.indicesToOffset("xIndices")}];
                ${f}
              }`:ie=`
              }
              let x_val = x[${i.indicesToOffset("xIndices")}];
              ${f}
            `,`
            ${n.registerUniforms(v).declareVariables(i,G)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${G.offsetToIndices("global_idx")};
              var xIndices = ${G.offsetToIndices("global_idx")};

              var offsets: array<u32, ${X}>;

              var value = ${K}(${g});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${X-1}u; j++) {
                  offsets[j] = offset / ${Kt("uniforms.kernelStrides","j",X)};
                  offset -= offsets[j] * ${Kt("uniforms.kernelStrides","j",X)};
                }
                offsets[${X-1}] = offset;

                isPad = false;
                for (var j = ${s-X}u; j < ${s}u; j++) {
                  xIndices[j] = indices[j] * ${Kt("uniforms.strides",`j - ${s-X}u`,X)}
                    + offsets[j - ${s-X}u] - ${Kt("uniforms.pads","j - 2u",ne)};
                  ${ie}
              }
              ${c}

              output[global_idx] = value;
            }`}},bu=n=>`${n.format};${n.ceilMode};${n.autoPad};${n.kernelShape.length}`,ff=n=>`${bu(n)};${n.countIncludePad}`,hf=n=>`${bu(n)};${n.storageOrder};${n.dilations}`,Mu=n=>({format:n.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],ceilMode:n.ceil_mode,kernelShape:n.kernel_shape,strides:n.strides,pads:n.pads}),mf=(n,i,s,u)=>{let[d,f]=yu(i,u,s),c=ot("x",i.dataType,i.dims.length),g=c.type.value,v="value += x_val;",b="";d.countIncludePad?b+=`value /= ${g}(uniforms.kernelSize);`:b+=`value /= ${g}(i32(uniforms.kernelSize) - pad);`;let[$,k,m,K,G]=wu(f,d);$.push(...Ft(i.dims,f));let X=["rank"];return{name:n,shaderCache:{hint:`${u.cacheKey};${m};${K};${G}`,inputDependencies:X},getRunData:()=>({outputs:[{dims:f,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(Ae.size(f)/64)},programUniforms:$}),getShaderSource:ne=>vu(ne,c,i.dims.length,f.length,d,v,b,0,k,m,K,G)}},_n=n=>{let i=n.count_include_pad!==0,s=Mu(n);if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let u={countIncludePad:i,...s,cacheKey:""};return{...u,cacheKey:ff(u)}},gf=(n,i)=>{Ss(n.inputs),n.compute(mf("AveragePool",n.inputs[0],!1,i))},Mr={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Cr=n=>{let i=n.format;return{format:i,...Mr,cacheKey:i}},Dr=(n,i)=>{Ss(n.inputs),n.compute(mf("GlobalAveragePool",n.inputs[0],!0,i))},so=(n,i,s,u)=>{let[d,f]=yu(i,u,s),c=`
      value = max(x_val, value);
    `,g="",v=ot("x",i.dataType,i.dims.length),b=["rank"],[$,k,m,K,G]=wu(f,d);return $.push(...Ft(i.dims,f)),{name:n,shaderCache:{hint:`${u.cacheKey};${m};${K};${G}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:f,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(Ae.size(f)/64)},programUniforms:$}),getShaderSource:X=>vu(X,v,i.dims.length,f.length,d,c,g,i.dataType===10?-65504:-1e5,k,m,K,G)}},tm=(n,i)=>{Ss(n.inputs),n.compute(so("MaxPool",n.inputs[0],!1,i))},_f=n=>{let i=n.storage_order,s=n.dilations,u=Mu(n);if(i!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(u.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let d={storageOrder:i,dilations:s,...u,cacheKey:""};return{...d,cacheKey:hf(d)}},yf=n=>{let i=n.format;return{format:i,...Mr,cacheKey:i}},S=(n,i)=>{Ss(n.inputs),n.compute(so("GlobalMaxPool",n.inputs[0],!0,i))}}),re,ke,qe,Ue,gt=_(()=>{nn(),Zt(),Ln(),yn(),re=(n,i)=>{if(n.length<2||n.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(n.length===3&&n[1].dims===n[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(n[0].dataType===6&&n.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(n[1].dims.length!==0&&n[1].dims.length!==1&&n[1].dims.length!==n[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(n.length>2){if(n[0].dataType!==n[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(n[1].dims.length!==n[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!n[1].dims.map((s,u)=>s===n[2].dims[u]).reduce((s,u)=>s&&u,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(i.blockSize>0){if(n[1].dims.length===0||n[1].dims.length===1&&n[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!n[1].dims.map((d,f)=>f===i.axis||d===n[0].dims[f]).reduce((d,f)=>d&&f,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(n[1].dims.length!==n[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let s=n[0].dims[i.axis],u=n[1].dims[i.axis];if(i.blockSize<Math.ceil(s/u)||i.blockSize>Math.ceil(s/(u-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},ke=(n,i)=>{let s=Ae.normalizeAxis(i.axis,n[0].dims.length),u=n[0].dataType,d=u===3,f=n[0].dims,c=n[1].dataType,g=Ae.size(f),v=u===3||u===2,b=v?[Math.ceil(Ae.size(n[0].dims)/4)]:n[0].dims,$=n[1].dims,k=n.length>2?n[2]:void 0,m=k?v?[Math.ceil(Ae.size(k.dims)/4)]:k.dims:void 0,K=$.length===0||$.length===1&&$[0]===1,G=K===!1&&$.length===1,X=Mn(g),ne=K&&(!v||X===4),ie=ne?X:1,ee=ne&&!v?X:1,de=ot("input",v?12:u,b.length,ee),he=ot("scale",c,$.length),_e=k?ot("zero_point",v?12:u,m.length):void 0,Fe=Yt("output",c,f.length,ie),De=[de,he];_e&&De.push(_e);let st=[b,$];k&&st.push(m);let Lt=[{type:12,data:g/ie},{type:12,data:s},{type:12,data:i.blockSize},...Ft(...st,f)],jt=pn=>{let un=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${pn.registerUniforms(un).declareVariables(...De,Fe)}
      ${pn.mainStart()}
          ${pn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${Fe.offsetToIndices("global_idx")};

          // Set input x
          ${v?`
            let input = ${de.getByOffset("global_idx / 4")};
            let x_vec = ${d?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${ie===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${de.getByOffset("global_idx")};`};

          // Set scale input
          ${K?`let scale_value= ${he.getByOffset("0")}`:G?`
            let scale_index = ${Fe.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${he.getByOffset("scale_index")};`:`
            var scale_indices: ${he.type.indices} = output_indices;
            let index = ${he.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${he.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${he.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${_e?K?v?`
                let zero_point_input = ${_e.getByOffset("0")};
                let zero_point_vec =  ${d?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${_e.getByOffset("0")}`:G?v?`
                let zero_point_index = ${Fe.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${_e.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${d?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${Fe.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${_e.getByOffset("zero_point_index")};`:v?`
                let zero_point_offset = ${he.indicesToOffset("scale_indices")};
                let zero_point_input = ${_e.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${d?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${_e.getByIndices("scale_indices")};`:`let zero_point_value = ${v?d?"i32":"u32":de.type.value}(0);`};
      // Compute and write output
      ${Fe.setByOffset("global_idx",`${Fe.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:i.cacheKey,inputDependencies:_e?["rank","rank","rank"]:["rank","rank"]},getShaderSource:jt,getRunData:()=>({outputs:[{dims:f,dataType:c}],dispatchGroup:{x:Math.ceil(g/ie/64),y:1,z:1},programUniforms:Lt})}},qe=(n,i)=>{re(n.inputs,i),n.compute(ke(n.inputs,i))},Ue=n=>fn({axis:n.axis,blockSize:n.blockSize})}),It,qt,an,jn=_(()=>{Dt(),nn(),yn(),It=(n,i,s)=>{let u=n===i,d=n<i&&s<0,f=n>i&&s>0;if(u||d||f)throw new Error("Range these inputs' contents are invalid.")},qt=(n,i,s,u)=>{let d=Math.abs(Math.ceil((i-n)/s)),f=[d],c=d,g=[{type:12,data:c},{type:u,data:n},{type:u,data:s},...Ft(f)],v=b=>{let $=Yt("output",u,f.length),k=$.type.value,m=[{name:"outputSize",type:"u32"},{name:"start",type:k},{name:"delta",type:k}];return`
        ${b.registerUniforms(m).declareVariables($)}
        ${b.mainStart()}
        ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${k}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${u}`},getShaderSource:v,getRunData:()=>({outputs:[{dims:f,dataType:u}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:g})}},an=n=>{let i=0,s=0,u=0;n.inputs[0].dataType===6?(i=n.inputs[0].getInt32Array()[0],s=n.inputs[1].getInt32Array()[0],u=n.inputs[2].getInt32Array()[0]):n.inputs[0].dataType===1&&(i=n.inputs[0].getFloat32Array()[0],s=n.inputs[1].getFloat32Array()[0],u=n.inputs[2].getFloat32Array()[0]),L.webgpu.validateInputContent&&It(i,s,u),n.compute(qt(i,s,u,n.inputs[0].dataType),{inputs:[]})}}),Vn,Tn,dn,Rn,Fn,Sn,Wn,ei,Pr,rr,ur,ir,jr,ao,va,xu,i_,ki,Ho,o_=_(()=>{nn(),Zt(),Ln(),yn(),Vn=(n,i)=>{if(n.every(s=>s>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),n.length>0){if(i.mode==="linear"){if(!(n.length===2||n.length===3||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1||n.length===5&&n[0]===1&&n[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(i.mode==="cubic"&&!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Tn=(n,i,s)=>{i.every(d=>d>=0&&d<s||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let u=new Array(s).fill(1);return i.forEach((d,f)=>u[d]=n[f]),u},dn=(n,i,s,u,d,f)=>{let[c,g,v]=s>10?[1,2,3]:[-1,n.length>1?1:-1,-1],b=n[0].dims.length;if(c>0&&n.length>c&&n[c].dims.length>0)n[c].getFloat32Array().forEach($=>f.push($));else if(i.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(g>0&&n.length>g&&n[g].dims.length===1&&n[g].dims[0]>0){if(n[g].getFloat32Array().forEach($=>u.push($)),u.length!==0&&u.length!==b&&s>=18&&u.length!==i.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Vn(u,i),i.axes.length>0&&Tn(u,i.axes,b).forEach(($,k)=>u[k]=$)}if(v>0&&n.length>v&&n[v].dims.length===1&&n[v].dims[0]>0&&(n[v].getBigInt64Array().forEach($=>d.push(Number($))),d.length!==0&&d.length!==b&&s>=18&&d.length!==i.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(i.axes.length>0){if(u.length!==0&&u.length!==i.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(d.length!==0&&d.length!==i.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof u<"u"&&typeof d<"u"&&u.length>0&&d.length>b)throw new Error("Resize requires only of scales or sizes to be specified")},Rn=(n,i)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${i} { `+(()=>{switch(n){case"asymmetric":return`return ${i}(xResized) / ${i}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${i}(xResized) + 0.5) / ${i}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${i}(xResized) + 0.5) / ${i}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${i}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${i}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${i}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${i}(roiStart) * ${i}(lengthOriginal - 1) +
                        (${i}(xResized) * ${i}(roiEnd - roiStart) * ${i}(lengthOriginal - 1)) /
                        ${i}(lengthResized - 1);
                  } else {
                    return 0.5 * ${i}(roiStart + roiEnd) * ${i}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${i}xScale * ${i}(lengthResized);
                  const adjustment = ${i}(lengthResized) / outputWidth;
                  const center = ${i}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${i}(xResized) + 0.5) / ${i}(xScale)) - 0.5;`;case"half_pixel":return`return ((${i}(xResized) + 0.5) / ${i}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${n} is not supported`)}})()+"}",Fn=(n,i,s)=>`fn getNearestPixelFromOriginal(xOriginal: ${s}, isDownSample: bool) -> ${s} {`+(()=>{switch(n){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(i<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${n} is not supported`)}})()+"}",Sn=(n,i,s)=>{let u=new Array(s).fill(0).concat(new Array(s).fill(1)),d=n.length===0?u:n.slice();return i.length>0?(i.forEach((f,c)=>{u[f]=d[c],u[c+s]=d[i.length+c]}),u):d},Wn=(n,i,s,u)=>{let d=[];if(s.length>0)if(u.length>0){if(n.forEach(f=>d.push(f)),Math.max(...u)>n.length)throw new Error("axes is out of bound");u.forEach((f,c)=>d[f]=s[c])}else s.forEach(f=>d.push(f));else{if(i.length===0)throw new Error("Resize requires either scales or sizes.");d=n.map((f,c)=>Math.round(f*i[c]))}return d},ei=(n,i,s)=>{let u=(()=>{switch(s.keepAspectRatioPolicy){case"not_larger":return s.axes.length>0?Math.min(...s.axes.map(f=>i[f]),Number.MAX_VALUE):Math.min(...i,Number.MAX_VALUE);case"not_smaller":return s.axes.length>0?Math.max(...s.axes.map(f=>i[f]),Number.MIN_VALUE):Math.max(...i,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${s.keepAspectRatioPolicy} is not supported`)}})();i.fill(1,0,i.length);let d=n.slice();return s.axes.length>0?(s.axes.forEach(f=>i[f]=u),s.axes.forEach(f=>d[f]=Math.round(n[f]*i[f]))):(i.fill(u,0,i.length),d.forEach((f,c)=>d[c]=Math.round(f*i[c]))),d},Pr=(n,i,s,u,d)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${n.type.indices}) -> array<${n.type.value}, ${s.length}> {
      var original_indices: array<${n.type.value}, ${s.length}>;
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${n.indicesGet("output_indices","i")};
        var scale = ${Kt("uniforms.scales","i",u)};
        var roi_low = ${Kt("uniforms.roi","i",d)};
        var roi_hi = ${Kt("uniforms.roi",`i + ${i.length}`,d)};
        if (scale == 1.0) {
          original_indices[i] = ${n.type.value}(output_index);
        } else {
          var input_shape_i = ${Kt("uniforms.input_shape","i",i.length)};
          var output_shape_i = ${Kt("uniforms.output_shape","i",s.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,rr=(n,i,s,u,d,f,c)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${i.type.indices}) -> ${n.type.indices} {
      var input_indices: ${n.type.indices};
      for (var i:u32 = 0; i < ${u.length}; i++) {
        var output_index = ${i.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Kt("uniforms.scales","i",d)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Kt("uniforms.roi","i",f)};
          var roi_hi = ${Kt("uniforms.roi",`i + ${s.length}`,f)};
          var input_shape_i = ${Kt("uniforms.input_shape","i",s.length)};
          var output_shape_i = ${Kt("uniforms.output_shape","i",u.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${c} || (original_idx >= 0 && original_idx < ${i.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${i.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${n.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,ur=(n,i)=>`
    fn checkInputIndices(input_indices: ${n.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var input_index = ${n.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Kt("uniforms.input_shape","i",i.length)}) {
          return false;
        }
      }
      return true;
    }`,ir=(n,i,s,u)=>n.rank>u?`
    ${n.indicesSet("input_indices",i,"channel")};
    ${n.indicesSet("input_indices",s,"batch")};
`:"",jr=(n,i,s,u,d)=>{let[f,c,g,v]=s.length===2?[-1,0,1,-1]:[0,2,3,1],b=n.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${b} {
      var input_indices: ${n.type.indices};
      ${n.indicesSet("input_indices",c,`max(0, min(row, ${s[c]} - 1))`)};
      ${n.indicesSet("input_indices",g,`max(0, min(col, ${s[g]} - 1))`)};
      ${ir(n,v,f,2)}
      return ${n.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${i.type.indices}) -> ${b} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${b} = originalIndices[${c}];
      var col:${b} = originalIndices[${g}];
      ${u?`if (row < 0 || row > (${s[c]} - 1) || col < 0 || col > (${s[g]} - 1)) {
        return ${d};
      }`:""};
      row = max(0, min(row, ${s[c]} - 1));
      col = max(0, min(col, ${s[g]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${s.length>2?`u32(originalIndices[${v}])`:"0"};
      var batch: u32 =  ${s.length>2?`u32(originalIndices[${f}])`:"0"};
      var x11: ${b} = getInputValue(batch, channel, row1, col1);
      var x12: ${b} = getInputValue(batch, channel, row1, col2);
      var x21: ${b} = getInputValue(batch, channel, row2, col1);
      var x22: ${b} = getInputValue(batch, channel, row2, col2);
      var dx1: ${b} = abs(row - ${b}(row1));
      var dx2: ${b} = abs(${b}(row2) - row);
      var dy1: ${b} = abs(col - ${b}(col1));
      var dy2: ${b} = abs(${b}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},ao=(n,i,s,u,d,f,c,g,v,b)=>{let $=s.length===2,[k,m]=$?[0,1]:[2,3],K=n.type.value,G=X=>{let ne=X===k?"row":"col";return`
      fn ${ne}CubicInterpolation(input_indices: ${n.type.indices}, output_indices: ${i.type.indices}) -> ${K} {
        var output_index = ${i.indicesGet("output_indices",X)};
        var originalIdx: ${K} = getOriginalCoordinateFromResizedCoordinate(output_index, ${d[X]},
        ${u[X]}, ${s[X]}, ${f[X]}, ${f[X]} + ${s.length});
        var fractOriginalIdx: ${K} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${g} && (originalIdx < 0 || originalIdx > (${s[X]} - 1))) {
          return ${v};
        }
        var data: array<${K}, 4> = array<${K}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${ne}: ${K} = originalIdx + ${K}(i);
          if (${ne} < 0 || ${ne} >= ${s[X]}) {
            ${b?`coefs[i + 1] = 0.0;
                        continue;`:g?`return ${v};`:`${ne} = max(0, min(${ne}, ${s[X]} - 1));`};
          }
        var input_indices_copy: ${n.type.indices} = input_indices;
          ${n.indicesSet("input_indices_copy",X,`u32(${ne})`)};
          data[i + 1] = ${X===k?n.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${G(k)};
    ${G(m)};
  fn getCubicInterpolationCoefs(s: ${K}) -> array<${K}, 4> {
    var absS = abs(s);
    var coeffs: array<${K}, 4> = array<${K}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${K} = 1.0 - absS;
    var twoMinusAbsS: ${K} = 2.0 - absS;
    var onePlusAbsS: ${K} = 1.0 + absS;
    coeffs[0] = ((${c} * onePlusAbsS - 5 * ${c}) * onePlusAbsS + 8 * ${c}) * onePlusAbsS - 4 * ${c};
    coeffs[1] = ((${c} + 2) * absS - (${c} + 3)) * absS * absS + 1;
    coeffs[2] = ((${c} + 2) * oneMinusAbsS - (${c} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${c} * twoMinusAbsS - 5 * ${c}) * twoMinusAbsS + 8 * ${c}) * twoMinusAbsS - 4 * ${c};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${K}, 4>, coefs: array<${K}, 4>) -> ${K} {
    var coefsSum: ${K} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${i.type.indices}) -> ${K} {
    var input_indices: ${n.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},va=(n,i,s,u,d)=>{let[f,c,g,v,b]=s.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],$=n.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${$} {
      var input_indices: ${n.type.indices};
      ${n.indicesSet("input_indices",c,`max(0, min(depth, ${s[c]} - 1))`)};
      ${n.indicesSet("input_indices",g,`max(0, min(height, ${s[g]} - 1))`)};
      ${n.indicesSet("input_indices",v,`max(0, min(width, ${s[v]} - 1))`)};
      ${ir(n,b,f,3)}
      return ${n.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${i.type.indices}) -> ${$} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${$} = originalIndices[${c}];
      var height:${$} = originalIndices[${g}];
      var width:${$} = originalIndices[${v}];
      ${u?`if (depth < 0 || depth > (${s[c]} - 1) || height < 0 || height > (${s[g]} - 1) || width < 0 || (width > ${s[v]} - 1)) {
      return ${d};
        }`:""};

    depth = max(0, min(depth, ${s[c]} - 1));
      height = max(0, min(height, ${s[g]} - 1));
      width = max(0, min(width, ${s[v]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${s.length>3?`u32(originalIndices[${b}])`:"0"};
      var batch: u32 =  ${s.length>3?`u32(originalIndices[${f}])`:"0"};

      var x111: ${$} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${$} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${$} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${$} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${$} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${$} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${$} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${$} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${$} = abs(depth - ${$}(depth1));
      var dx2: ${$} = abs(${$}(depth2) - depth);
      var dy1: ${$} = abs(height - ${$}(height1));
      var dy2: ${$} = abs(${$}(height2) - height);
      var dz1: ${$} = abs(width - ${$}(width1));
      var dz2: ${$} = abs(${$}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},xu=(n,i,s,u,d,f)=>{let c=n.dims,g=Sn(f,i.axes,c.length),v=Wn(c,u,d,i.axes),b=u.slice();u.length===0&&(b=c.map((ee,de)=>ee===0?1:v[de]/ee),i.keepAspectRatioPolicy!=="stretch"&&(v=ei(c,b,i)));let $=Yt("output",n.dataType,v.length),k=ot("input",n.dataType,c.length),m=Ae.size(v),K=c.length===v.length&&c.every((ee,de)=>ee===v[de]),G=i.coordinateTransformMode==="tf_crop_and_resize",X=i.extrapolationValue,ne=k.type.value,ie=ee=>`
      ${K?"":`
      ${Rn(i.coordinateTransformMode,ne)};
      ${(()=>{switch(i.mode){case"nearest":return`
              ${ur(k,c)};
              ${Fn(i.nearestMode,s,ne)};
              ${rr(k,$,c,v,b.length,g.length,G)};
              `;case"linear":return`
              ${Pr($,c,v,b.length,g.length)};
              ${(()=>{if(c.length===2||c.length===4)return`${jr(k,$,c,G,X)}`;if(c.length===3||c.length===5)return`${va(k,$,c,G,X)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(c.length===2||c.length===4)return`${ao(k,$,c,v,b,g,i.cubicCoeffA,G,i.extrapolationValue,i.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${ee.registerUniform("output_size","u32").registerUniform("scales","f32",b.length).registerUniform("roi","f32",g.length).declareVariables(k,$)}
      ${ee.mainStart()}
        ${ee.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${K?"output[global_idx] = input[global_idx];":`
        let output_indices = ${$.offsetToIndices("global_idx")};
        var input_indices: ${k.type.indices};
        ${(()=>{switch(i.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${k.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${i.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${c.length===2||c.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${i.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${i.cacheKey}|${s}|${b.length>0?b:""}|${d.length>0?d:""}|${g.length>0?g:""}|${K}|${c}`,inputDependencies:["rank"]},getShaderSource:ie,getRunData:()=>({outputs:[{dims:v,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},{type:1,data:b},{type:1,data:g},...Ft(c,v)]})}},i_=n=>{let i=n.customDataBuffer;return new Uint32Array(i,i.byteOffset,1)[0]},ki=(n,i)=>{let s=[],u=[],d=[],f=i_(n);if(i.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");dn(n.inputs,i,f,s,u,d),n.compute(xu(n.inputs[0],i,f,s,u,d),{inputs:[0]})},Ho=n=>{let i=n.antialias,s=n.axes,u=n.coordinateTransformMode,d=n.cubicCoeffA,f=n.excludeOutside!==0,c=n.extrapolationValue,g=n.keepAspectRatioPolicy,v=n.mode,b=n.nearestMode===""?"simple":n.nearestMode;return fn({antialias:i,axes:s,coordinateTransformMode:u,cubicCoeffA:d,excludeOutside:f,extrapolationValue:c,keepAspectRatioPolicy:g,mode:v,nearestMode:b})}}),nm,rm,wf,L2=_(()=>{nn(),Zt(),Ln(),yn(),nm=(n,i)=>{let[s,u,d,f]=n,{numHeads:c,rotaryEmbeddingDim:g}=i;if(s.dims.length!==3&&s.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${s.dims.length}`);if(!Ae.areEqual(u.dims,[])&&!Ae.areEqual(u.dims,[1])&&u.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${u.dims.length}`);if(d.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${d.dims.length}`);if(f.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${f.dims.length}`);if(!Ae.areEqual(d.dims,f.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(g>0&&c===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let v=s.dims[0],b=s.dims[s.dims.length-2],$=d.dims[0],k=Ae.sizeFromDimension(s.dims,1)/b,m=g===0?d.dims[1]*2:k/c;if(g>m)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(u.dims.length===2){if(v!==u.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${u.dims[0]}`);if(b!==u.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${u.dims[1]}`)}if(m/2!==d.dims[1]&&g/2!==d.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${d.dims[1]}`);if(b>$)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},rm=(n,i)=>{let{interleaved:s,numHeads:u,rotaryEmbeddingDim:d,scale:f}=i,c=n[0].dims[0],g=Ae.sizeFromDimension(n[0].dims,1),v=n[0].dims[n[0].dims.length-2],b=g/v,$=n[2].dims[1],k=d===0?$*2:b/u,m=new Array(c,v,b/k,k-$),K=Ae.computeStrides(m),G=[{type:1,data:f},{type:12,data:m},{type:12,data:K},...n[0].dims.length===3?new Array({type:12,data:[g,b,k,1]}):[],...n[0].dims.length===4?new Array({type:12,data:[g,k,v*k,1]}):[],...Ft(n[0].dims,n[1].dims,n[2].dims,n[3].dims,n[0].dims)],X=ne=>{let ie=ot("input",n[0].dataType,n[0].dims.length),ee=ot("position_ids",n[1].dataType,n[1].dims.length),de=ot("cos_cache",n[2].dataType,n[2].dims.length),he=ot("sin_cache",n[3].dataType,n[3].dims.length),_e=Yt("output",n[0].dataType,n[0].dims.length);return ne.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:m.length},{name:"global_strides",type:"u32",length:K.length},{name:"input_output_strides",type:"u32",length:K.length}]),`
        ${ne.declareVariables(ie,ee,de,he,_e)}

        ${ne.mainStart(Ir)}
          let half_rotary_emb_dim = uniforms.${de.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${ne.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${ee.broadcastedIndicesToOffset("bsnh.xy",Yt("",ee.type.tensor,2))};
            let position_id =
                u32(${ee.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${s});
            let j = i + select(half_rotary_emb_dim, 1, ${s});
            let re = ${ie.getByOffset("i")} * ${de.get("position_id","bsnh[3]")} -
                ${ie.getByOffset("j")} * ${he.get("position_id","bsnh[3]")};
            ${_e.setByOffset("i","re")}
            let im = ${ie.getByOffset("i")} * ${he.get("position_id","bsnh[3]")} +
                ${ie.getByOffset("j")} * ${de.get("position_id","bsnh[3]")};
            ${_e.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${_e.setByOffset("k",ie.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:fn({interleaved:s}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:X,getRunData:()=>({outputs:[{dims:n[0].dims,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(Ae.size(m)/Ir)},programUniforms:G})}},wf=(n,i)=>{nm(n.inputs,i),n.compute(rm(n.inputs,i))}}),Hw,Kw,Xw,R2=_(()=>{nn(),Zt(),yn(),Hw=n=>{if(!n||n.length<3)throw new Error("layerNorm requires at least 3 inputs.");let i=n[0],s=n[1],u=n[2];if(i.dataType!==s.dataType||i.dataType!==u.dataType)throw new Error("All inputs must have the same data type");if(i.dims.length!==3&&i.dims.length!==2)throw new Error("Input must be 2D or 3D");if(s.dims.length!==3&&s.dims.length!==2)throw new Error("Skip must be 2D or 3D");let d=i.dims[i.dims.length-1],f=i.dims[i.dims.length-2];if(s.dims[s.dims.length-1]!==d)throw new Error("Skip must have the same hidden size as input");if(s.dims[s.dims.length-2]!==f)throw new Error("Skip must have the same sequence length as input");if(u.dims.length!==1)throw new Error("Gamma must be 1D");if(u.dims[u.dims.length-1]!==d)throw new Error("Gamma must have the same hidden size as input");if(n.length>3){let c=n[3];if(c.dims.length!==1)throw new Error("Beta must be 1D");if(c.dims[c.dims.length-1]!==d)throw new Error("Beta must have the same hidden size as input")}if(n.length>4){let c=n[4];if(c.dims.length!==1)throw new Error("Bias must be 1D");if(c.dims[c.dims.length-1]!==d)throw new Error("Bias must have the same hidden size as input")}},Kw=(n,i,s,u)=>{let d=i.simplified,f=n[0].dims,c=Ae.size(f),g=f,v=c,b=f.slice(-1)[0],$=u?f.slice(0,-1).concat(1):[],k=!d&&n.length>3,m=n.length>4,K=u&&s>1,G=u&&s>2,X=s>3,ne=64,ie=Mn(b),ee=[{type:12,data:v},{type:12,data:ie},{type:12,data:b},{type:1,data:i.epsilon}],de=_e=>{let Fe=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],De=[ot("x",n[0].dataType,n[0].dims,ie),ot("skip",n[1].dataType,n[1].dims,ie),ot("gamma",n[2].dataType,n[2].dims,ie)];k&&De.push(ot("beta",n[3].dataType,n[3].dims,ie)),m&&De.push(ot("bias",n[4].dataType,n[4].dims,ie)),De.push(Yt("output",n[0].dataType,g,ie)),K&&De.push(Yt("mean_output",1,$)),G&&De.push(Yt("inv_std_output",1,$)),X&&De.push(Yt("input_skip_bias_sum",n[0].dataType,g,ie));let st=vn(n[0].dataType),Lt=vn(1,ie);return`

      ${_e.registerUniforms(Fe).declareVariables(...De)}
      var<workgroup> sum_shared : array<${Lt}, ${ne}>;
      var<workgroup> sum_squared_shared : array<${Lt}, ${ne}>;

      ${_e.mainStart([ne,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${ne};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${ne};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${ne-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${m?"bias[offset1d + i]":st+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${X?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${eo(st,ie,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${ne};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Ri("sum",ie)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Ri("square_sum",ie)} / f32(uniforms.hidden_size) ${d?"":"- mean * mean"} + uniforms.epsilon);
        ${K?"mean_output[global_idx] = mean;":""}
        ${G?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${d?"":`- ${st}(mean)`}) *
            ${st}(inv_std_dev) * gamma[offset1d + i]
            ${k?"+ beta[offset1d + i]":""};
        }
      }`},he=[{dims:g,dataType:n[0].dataType}];return s>1&&he.push({dims:$,dataType:1}),s>2&&he.push({dims:$,dataType:1}),s>3&&he.push({dims:f,dataType:n[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${ie};${K};${G};${X}`,inputDependencies:n.map((_e,Fe)=>"type")},getShaderSource:de,getRunData:()=>({outputs:he,dispatchGroup:{x:Math.ceil(v/b)},programUniforms:ee})}},Xw=(n,i)=>{Hw(n.inputs);let s=[0];n.outputCount>1&&s.push(-3),n.outputCount>2&&s.push(-3),n.outputCount>3&&s.push(3),n.compute(Kw(n.inputs,i,n.outputCount,!1),{outputs:s})}}),Qw,vf,Yw,s_,Jw,Zw,ev,tv,B2=_(()=>{nn(),Zt(),Ln(),yn(),Qw=(n,i)=>{if(!n||n.length<1)throw new Error("too few inputs");if(i.axes.length!==0){if(i.axes.length!==i.starts.length||i.axes.length!==i.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(i.starts.length!==i.ends.length)throw new Error("starts and ends must have the same length");n.slice(1).forEach((s,u)=>{if(n[u+1].dataType!==6&&n[u+1].dataType!==7)throw new Error(`Input ${u} must be an array of int32 or int64`)})},vf=(n,i)=>{let s=[];if(n.length>i)if(n[i].dataType===7)n[i].getBigInt64Array().forEach(u=>s.push(Number(u)));else if(n[i].dataType===6)n[i].getInt32Array().forEach(u=>s.push(Number(u)));else throw new Error(`Input ${i} must be an array of int32 or int64`);return s},Yw=(n,i)=>{if(n.length>1){let s=vf(n,1),u=vf(n,2),d=vf(n,3);return d.length===0&&(d=[...Array(n[0].dims.length).keys()]),fn({starts:s,ends:u,axes:d})}else return i},s_=(n,i,s,u,d)=>{let f=n;return n<0&&(f+=s[u[i]]),d[i]<0?Math.max(0,Math.min(f,s[u[i]]-1)):Math.max(0,Math.min(f,s[u[i]]))},Jw=(n,i,s)=>`fn calculateInputIndices(output_indices: ${i.type.indices}) -> ${n.type.indices} {
          var input_indices: ${n.type.indices};
          var carry = 0u;
          for (var i = ${s.length}; i >= 0; i--) {
            let input_shape_i = ${Kt("uniforms.input_shape","i",s.length)};
            let steps_i = ${Kt("uniforms.steps","i",s.length)};
            let signs_i = ${Kt("uniforms.signs","i",s.length)};
            let starts_i = ${Kt("uniforms.starts","i",s.length)};
            var output_index = ${i.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${n.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Zw=(n,i)=>{let s=n[0].dims,u=Ae.size(s),d=i.axes.length>0?Ae.normalizeAxes(i.axes,s.length):[...Array(s.length).keys()],f=vf(n,4);f.forEach(ie=>ie!==0||(()=>{throw new Error("step cannot be 0")})),f.length===0&&(f=Array(d.length).fill(1));let c=i.starts.map((ie,ee)=>s_(ie,ee,s,d,f)),g=i.ends.map((ie,ee)=>s_(ie,ee,s,d,f));if(d.length!==c.length||d.length!==g.length)throw new Error("start, ends and axes should have the same number of elements");if(d.length!==s.length)for(let ie=0;ie<s.length;++ie)d.includes(ie)||(c.splice(ie,0,0),g.splice(ie,0,s[ie]),f.splice(ie,0,1));let v=f.map(ie=>Math.sign(ie));f.forEach((ie,ee,de)=>{if(ie<0){let he=(g[ee]-c[ee])/ie,_e=c[ee],Fe=_e+he*f[ee];c[ee]=Fe,g[ee]=_e,de[ee]=-ie}});let b=s.slice(0);d.forEach((ie,ee)=>{b[ie]=Math.ceil((g[ie]-c[ie])/f[ie])});let $={dims:b,dataType:n[0].dataType},k=Yt("output",n[0].dataType,b.length),m=ot("input",n[0].dataType,n[0].dims.length),K=Ae.size(b),G=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:c.length},{name:"signs",type:"i32",length:v.length},{name:"steps",type:"u32",length:f.length}],X=[{type:12,data:K},{type:12,data:c},{type:6,data:v},{type:12,data:f},...Ft(n[0].dims,b)],ne=ie=>`
      ${ie.registerUniforms(G).declareVariables(m,k)}
        ${Jw(m,k,s)}
        ${ie.mainStart()}
          ${ie.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${k.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${k.setByOffset("global_idx",m.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${v.length}_${c.length}_${f.length}`,inputDependencies:["rank"]},getShaderSource:ne,getRunData:()=>({outputs:[$],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:X})}},ev=(n,i)=>{Qw(n.inputs,i);let s=Yw(n.inputs,i);n.compute(Zw(n.inputs,s),{inputs:[0]})},tv=n=>{let i=n.starts,s=n.ends,u=n.axes;return fn({starts:i,ends:s,axes:u})}}),nv,rv,iv,ov,N2=_(()=>{nn(),Zt(),Ln(),Bi(),yn(),nv=n=>{if(!n||n.length!==1)throw new Error("Softmax op requires 1 input.")},rv=(n,i)=>{let s=n.inputs[0],u=s.dims,d=Ae.size(u),f=64,c=u.length,g=Ae.normalizeAxis(i.axis,c),v=g<u.length-1,b,$=[];v?($=Array.from({length:c},(De,st)=>st),$[g]=c-1,$[c-1]=g,b=n.compute(Zr(s,$),{inputs:[s],outputs:[-1]})[0]):b=s;let k=b.dims,m=k[c-1],K=d/m,G=Mn(m),X=m/G,ne=(De,st)=>st===4?`max(max(${De}.x, ${De}.y), max(${De}.z, ${De}.w))`:st===2?`max(${De}.x, ${De}.y)`:st===3?`max(max(${De}.x, ${De}.y), ${De}.z)`:De,ie=ot("x",b.dataType,b.dims,G),ee=Yt("result",b.dataType,b.dims,G),de=ie.type.value,he=vn(b.dataType)==="f32"?`var threadMax = ${de}(-3.402823e+38f);`:`var threadMax = ${de}(-65504.0h);`,_e=De=>`
      var<workgroup> rowMaxShared : ${de};
      var<workgroup> rowSumShared : ${de};
      var<workgroup> threadShared : array<${de}, ${f}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${de} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${de}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${De.registerUniform("packedCols","i32").declareVariables(ie,ee)}
      ${De.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${f};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${he}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${de}(${ne("threadShared[0]",G)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${de}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${de}(${Ri("threadShared[0]",G)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,Fe=n.compute({name:"Softmax",shaderCache:{hint:`${G}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:k,dataType:b.dataType}],dispatchGroup:{x:K},programUniforms:[{type:6,data:X}]}),getShaderSource:_e},{inputs:[b],outputs:[v?-1:0]})[0];v&&n.compute(Zr(Fe,$),{inputs:[Fe]})},iv=(n,i)=>{nv(n.inputs),rv(n,i)},ov=n=>fn({axis:n.axis})}),a_,sv,av,lv,uv,U2=_(()=>{nn(),Zt(),yn(),a_=n=>Array.from(n.getBigInt64Array(),Number),sv=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 inputs.");if(n[0].dataType!==1&&n[0].dataType!==10&&n[0].dataType!==6&&n[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(n[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(n[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(a_(n[1]).length!==n[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},av=(n,i)=>{let s=[];for(let u=0;u<n.length;++u)s.push(n[u]*i[u]);return s},lv=(n,i)=>{let s=n[0].dims,u=i??a_(n[1]),d=av(s,u),f=Ae.size(d),c=n[0].dataType,g=ot("input",c,s.length),v=Yt("output",c,d.length),b=$=>`
      const inputShape = ${g.indices(...s)};
      ${$.registerUniform("output_size","u32").declareVariables(g,v)}
      ${$.mainStart()}
      ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${v.offsetToIndices("global_idx")};
      var input_indices: ${g.type.indices};
      for (var i = 0; i < ${s.length}; i++) {
        let input_dim_i = ${g.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${v.indicesGet("output_indices","i")}  % input_dim_i;

        ${g.indicesSet("input_indices","i","input_dim_value")}
      }
      ${v.setByOffset("global_idx",g.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${u}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:d,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...Ft(n[0].dims,d)]}),getShaderSource:b}},uv=n=>{sv(n.inputs),n.compute(lv(n.inputs),{inputs:[0]})}}),cv,dv,pv,j2=_(()=>{nn(),Zt(),yn(),cv=(n,i,s,u,d)=>{let f=Yt("output_data",d,s.length,4),c=ot("a_data",i[1].dataType,i[1].dims.length,4),g=ot("b_data",i[2].dataType,i[2].dims.length,4),v=ot("c_data",i[0].dataType,i[0].dims.length,4),b,$=(k,m,K)=>`select(${m}, ${k}, ${K})`;if(!u)b=f.setByOffset("global_idx",$(c.getByOffset("global_idx"),g.getByOffset("global_idx"),v.getByOffset("global_idx")));else{let k=(m,K,G="")=>{let X=`a_data[index_a${K}][component_a${K}]`,ne=`b_data[index_b${K}][component_b${K}]`,ie=`bool(c_data[index_c${K}] & (0xffu << (component_c${K} * 8)))`;return`
            let output_indices${K} = ${f.offsetToIndices(`global_idx * 4u + ${K}u`)};
            let offset_a${K} = ${c.broadcastedIndicesToOffset(`output_indices${K}`,f)};
            let offset_b${K} = ${g.broadcastedIndicesToOffset(`output_indices${K}`,f)};
            let offset_c${K} = ${v.broadcastedIndicesToOffset(`output_indices${K}`,f)};
            let index_a${K} = offset_a${K} / 4u;
            let index_b${K} = offset_b${K} / 4u;
            let index_c${K} = offset_c${K} / 4u;
            let component_a${K} = offset_a${K} % 4u;
            let component_b${K} = offset_b${K} % 4u;
            let component_c${K} = offset_c${K} % 4u;
            ${m}[${K}] = ${G}(${$(X,ne,ie)});
          `};d===9?b=`
            var data = vec4<u32>(0);
            ${k("data",0,"u32")}
            ${k("data",1,"u32")}
            ${k("data",2,"u32")}
            ${k("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:b=`
            ${k("output_data[global_idx]",0)}
            ${k("output_data[global_idx]",1)}
            ${k("output_data[global_idx]",2)}
            ${k("output_data[global_idx]",3)}
          `}return`
        ${n.registerUniform("vec_size","u32").declareVariables(v,c,g,f)}
        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${b}
      }`},dv=n=>{let i=n[1].dims,s=n[2].dims,u=n[0].dims,d=n[1].dataType,f=!(Ae.areEqual(i,s)&&Ae.areEqual(s,u)),c=i,g=Ae.size(i);if(f){let b=Kr.calcShape(Kr.calcShape(i,s,!1),u,!1);if(!b)throw new Error("Can't perform where op on the given tensors");c=b,g=Ae.size(c)}let v=Math.ceil(g/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:b=>cv(b,n,c,f,d),getRunData:()=>({outputs:[{dims:c,dataType:d}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:v},...Ft(u,i,s,c)]})}},pv=n=>{n.compute(dv(n.inputs))}}),fv,V2=_(()=>{Vc(),oa(),Ph(),$h(),Cd(),Ah(),Fh(),Dh(),Nh(),gp(),Jl(),jh(),t_(),Wh(),Cp(),Gh(),n_(),Kh(),Yh(),r_(),Jh(),tp(),Zh(),Qh(),em(),R(),gt(),jn(),cl(),o_(),L2(),R2(),B2(),N2(),Vp(),U2(),Bi(),Fl(),j2(),fv=new Map([["Abs",[td]],["Acos",[nd]],["Acosh",[rd]],["Add",[Ad]],["ArgMax",[jc,fl]],["ArgMin",[pl,fl]],["Asin",[id]],["Asinh",[_l]],["Atan",[od]],["Atanh",[sd]],["Attention",[Kc]],["AveragePool",[gf,_n]],["BatchNormalization",[Yc]],["BiasAdd",[Zc]],["BiasSplitGelu",[kd]],["Cast",[ld,ad]],["Ceil",[cd]],["Clip",[ud]],["Concat",[jd,zl]],["Conv",[Kl,ql]],["ConvTranspose",[fp,_a]],["Cos",[wl]],["Cosh",[dd]],["CumSum",[hp,mp]],["DepthToSpace",[wp,vp]],["DequantizeLinear",[qe,Ue]],["Div",[Fd]],["Einsum",[nu,xp]],["Elu",[vl,bs]],["Equal",[Ol]],["Erf",[pd]],["Exp",[bl]],["Expand",[Vh]],["FastGelu",[au]],["Floor",[fd]],["FusedConv",[Kl,ql]],["Gather",[kp,Ep]],["GatherElements",[qh,Un]],["GatherBlockQuantized",[uu,Ap]],["Gelu",[hd]],["Gemm",[Dp,Op]],["GlobalAveragePool",[Dr,Cr]],["GlobalMaxPool",[S,yf]],["Greater",[zd]],["GreaterOrEqual",[Ld]],["GroupQueryAttention",[qp]],["HardSigmoid",[Tl,xl]],["InstanceNormalization",[Xp]],["LayerNormalization",[Yp]],["LeakyRelu",[Ml,bs]],["Less",[la]],["LessOrEqual",[Rd]],["Log",[xd]],["MatMul",[ep]],["MatMulNBits",[tf,nf]],["MaxPool",[tm,_f]],["Mul",[Id]],["MultiHeadAttention",[Xh,pu]],["Neg",[gd]],["Not",[md]],["Pad",[pf]],["Pow",[Od]],["QuickGelu",[Sd,bs]],["Range",[an]],["Reciprocal",[aa]],["ReduceMin",[Bc]],["ReduceMean",[sl]],["ReduceMax",[Rc]],["ReduceSum",[Nc]],["ReduceProd",[ll]],["ReduceL1",[zc]],["ReduceL2",[Lc]],["ReduceLogSum",[ul]],["ReduceLogSumExp",[al]],["ReduceSumSquare",[Uc]],["Relu",[_d]],["Resize",[ki,Ho]],["RotaryEmbedding",[wf]],["Sigmoid",[yd]],["Sin",[wd]],["Sinh",[Sl]],["Slice",[ev,tv]],["SkipLayerNormalization",[Xw]],["Split",[Up,jp]],["Sqrt",[vd]],["Softmax",[iv,ov]],["Sub",[Dd]],["Tan",[bd]],["Tanh",[kl]],["ThresholdedRelu",[$l,bs]],["Tile",[uv]],["Transpose",[kh,hc]],["Where",[pv]]])}),hv,W2=_(()=>{Dt(),C(),yn(),hv=class{constructor(n){this.backend=n,this.repo=new Map,this.attributesBound=!1}getArtifact(n){return this.repo.get(n)}setArtifact(n,i){this.repo.set(n,i)}run(n,i,s,u,d){We(n.programInfo.name);let f=this.backend.device,c=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let g=[];for(let b of i)g.push({binding:g.length,resource:{buffer:b.buffer}});for(let b of s)g.push({binding:g.length,resource:{buffer:b.buffer}});d&&g.push({binding:g.length,resource:d});let v=f.createBindGroup({layout:n.computePipeline.getBindGroupLayout(0),entries:g,label:n.programInfo.name});if(this.backend.sessionStatus==="capturing"){let b={kernelId:this.backend.currentKernelId,computePipeline:n.computePipeline,bindGroup:v,dispatchGroup:u};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(b)}c.setPipeline(n.computePipeline),c.setBindGroup(0,v),c.dispatchWorkgroups(...u),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Ge(n.programInfo.name)}dispose(){}build(n,i){We(n.name);let s=this.backend.device,u=[];s.features.has("shader-f16")&&u.push("enable f16;");let d=dc(i,this.backend.device.limits),f=n.getShaderSource(d),c=`${u.join(`
`)}
${d.additionalImplementations}
${f}`,g=s.createShaderModule({code:c,label:n.name});we("verbose",()=>`[WebGPU] ${n.name} shader code: ${c}`);let v=s.createComputePipeline({compute:{module:g,entryPoint:"main"},layout:"auto",label:n.name});return Ge(n.name),{programInfo:n,computePipeline:v,uniformVariablesInfo:d.variablesInfo}}normalizeDispatchGroupSize(n){let i=typeof n=="number"?n:n.x,s=typeof n=="number"?1:n.y||1,u=typeof n=="number"?1:n.z||1,d=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(i<=d&&s<=d&&u<=d)return[i,s,u];let f=i*s*u,c=Math.ceil(Math.sqrt(f));if(c>d){if(c=Math.ceil(Math.cbrt(f)),c>d)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}}),mv,gv,_v,yv,G2=_(()=>{Dt(),nn(),C(),le(),er(),V2(),W2(),mv=(n,i)=>{if(i.length!==n.length)throw new Error(`inputDependencies length ${i.length} is not equal to inputTensors length ${n.length}.`);let s=[];for(let u=0;u<n.length;++u){let d=n[u].dataType;switch(i[u]){case"none":{s.push("");break}case"type":{s.push(`${d}`);break}case"rank":{let f=n[u].dims.length;s.push(`${d};${f}`);break}case"dims":{let f=n[u].dims.join(",");s.push(`${d};${f}`);break}default:throw new Error(`unsupported input dependency: ${i[u]}`)}}return s.join("|")},gv=(n,i,s)=>{var d,f;let u=n.name;return(d=n.shaderCache)!=null&&d.hint&&(u+="["+n.shaderCache.hint+"]"),u+=":"+s+`:${mv(i,((f=n.shaderCache)==null?void 0:f.inputDependencies)??new Array(i.length).fill("dims"))}`,u},_v=class{constructor(n){n&&(this.architecture=n.architecture,this.vendor=n.vendor)}isArchitecture(n){return this.architecture===n}isVendor(n){return this.vendor===n}},yv=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let n=this.kernelCustomData.get(this.currentKernelId);return n||(n={},this.kernelCustomData.set(this.currentKernelId,n)),n}async initialize(n,i){this.env=n;let s=[],u={requiredLimits:{maxComputeWorkgroupStorageSize:i.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.limits.maxStorageBufferBindingSize,maxBufferSize:i.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:i.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:i.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:i.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:i.limits.maxComputeWorkgroupSizeZ},requiredFeatures:s};i.features.has("chromium-experimental-timestamp-query-inside-passes")?s.push("chromium-experimental-timestamp-query-inside-passes"):i.features.has("timestamp-query")&&s.push("timestamp-query"),i.features.has("shader-f16")&&s.push("shader-f16"),this.device=await i.requestDevice(u),this.adapterInfo=new _v(i.info||await i.requestAdapterInfo()),this.gpuDataManager=hn(this),this.programManager=new hv(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,vo(n.logLevel,!!n.debug),this.device.onuncapturederror=d=>{d.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${d.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:i,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let n=this.getCommandEncoder(),i={};this.queryType==="at-passes"&&(i.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=n.beginComputePass(i)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;We(),this.endComputePass();let n;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),n=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(n,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,n,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&n.mapAsync(GPUMapMode.READ).then(()=>{var u;let i=new BigUint64Array(n.getMappedRange()),s=this.pendingQueries.get(n);for(let d=0;d<i.length/2;d++){let f=s[d],c=f.kernelId,g=this.kernels.get(c),v=g.kernelType,b=g.kernelName,$=f.programName,k=f.inputTensorViews,m=f.outputTensorViews,K=i[d*2],G=i[d*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=K);let X=Number(K-this.queryTimeBase),ne=Number(G-this.queryTimeBase);if(!Number.isSafeInteger(X)||!Number.isSafeInteger(ne))throw new RangeError("incorrect timestamp range");if((u=this.env.webgpu.profiling)!=null&&u.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:k.map(ie=>({dims:ie.dims,dataType:hi(ie.dataType)})),outputsMetadata:m.map(ie=>({dims:ie.dims,dataType:hi(ie.dataType)})),kernelId:c,kernelType:v,kernelName:b,programName:$,startTime:X,endTime:ne});else{let ie="";k.forEach((de,he)=>{ie+=`input[${he}]: [${de.dims}] | ${hi(de.dataType)}, `});let ee="";m.forEach((de,he)=>{ee+=`output[${he}]: [${de.dims}] | ${hi(de.dataType)}, `}),console.log(`[profiling] kernel "${c}|${v}|${b}|${$}" ${ie}${ee}execution time: ${ne-X} ns`)}Ye("GPU",`${$}::${K}::${G}`)}n.unmap(),this.pendingQueries.delete(n)}),Ge()}run(n,i,s,u,d,f){We(n.name);let c=[];for(let ee=0;ee<i.length;++ee){let de=i[ee].data;if(de===0)continue;let he=this.gpuDataManager.get(de);if(!he)throw new Error(`no GPU data for input: ${de}`);c.push(he)}let{outputs:g,dispatchGroup:v,programUniforms:b}=n.getRunData(i),$=s.length===0?g.map((ee,de)=>de):s;if($.length!==g.length)throw new Error(`Output size ${$.length} must be equal to ${g.length}.`);let k=[],m=[];for(let ee=0;ee<g.length;++ee){if(!Number.isInteger($[ee])||$[ee]<-3||$[ee]>=f)throw new Error(`Invalid output index: ${$[ee]}`);if($[ee]===-3)continue;let de=$[ee]===-1,he=$[ee]===-2,_e=de||he?d(g[ee].dataType,g[ee].dims):u($[ee],g[ee].dataType,g[ee].dims);if(k.push(_e),_e.data===0)continue;let Fe=this.gpuDataManager.get(_e.data);if(!Fe)throw new Error(`no GPU data for output: ${_e.data}`);if(de&&this.temporaryData.push(Fe),he){let De=this.kernelPersistentData.get(this.currentKernelId);De||(De=[],this.kernelPersistentData.set(this.currentKernelId,De)),De.push(Fe)}m.push(Fe)}if(c.length!==i.length||m.length!==k.length){if(m.length===0)return Ge(n.name),k;throw new Error(`Program ${n.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let K;if(b){let ee=0,de=[];b.forEach(De=>{let st=typeof De.data=="number"?[De.data]:De.data;if(st.length===0)return;let Lt=De.type===10?2:4,jt,pn;De.type===10?(pn=st.length>4?16:st.length>2?8:st.length*Lt,jt=st.length>4?16:Lt*st.length):(pn=st.length<=2?st.length*Lt:16,jt=16),ee=Math.ceil(ee/pn)*pn,de.push(ee);let un=De.type===10?8:4;ee+=st.length>4?Math.ceil(st.length/un)*jt:st.length*Lt});let he=16;ee=Math.ceil(ee/he)*he;let _e=new ArrayBuffer(ee);b.forEach((De,st)=>{let Lt=de[st],jt=typeof De.data=="number"?[De.data]:De.data;if(De.type===6)new Int32Array(_e,Lt,jt.length).set(jt);else if(De.type===12)new Uint32Array(_e,Lt,jt.length).set(jt);else if(De.type===10)new Uint16Array(_e,Lt,jt.length).set(jt);else if(De.type===1)new Float32Array(_e,Lt,jt.length).set(jt);else throw new Error(`Unsupported uniform type: ${hi(De.type)}`)});let Fe=this.gpuDataManager.create(ee,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(Fe.buffer,0,_e,0,ee),this.gpuDataManager.release(Fe.id),K={offset:0,size:ee,buffer:Fe.buffer}}let G=this.programManager.normalizeDispatchGroupSize(v),X=G[1]===1&&G[2]===1,ne=gv(n,i,X),ie=this.programManager.getArtifact(ne);if(ie||(ie=this.programManager.build(n,G),this.programManager.setArtifact(ne,ie),we("info",()=>`[artifact] key: ${ne}, programName: ${n.name}`)),b&&ie.uniformVariablesInfo){if(b.length!==ie.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${ie.uniformVariablesInfo.length}, got ${b.length} in program "${ie.programInfo.name}".`);for(let ee=0;ee<b.length;ee++){let de=b[ee],he=de.type,_e=typeof de.data=="number"?1:de.data.length,[Fe,De]=ie.uniformVariablesInfo[ee];if(he!==Fe||_e!==De)throw new Error(`Uniform variable ${ee} mismatch: expect type ${Fe} with size ${De}, got type ${he} with size ${_e} in program "${ie.programInfo.name}".`)}}if(we("info",()=>`[ProgramManager] run "${n.name}" (key=${ne}) with ${G[0]}x${G[1]}x${G[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let ee={kernelId:this.currentKernelId,programName:ie.programInfo.name,inputTensorViews:i,outputTensorViews:k};this.pendingKernels.push(ee),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(ee)}return this.programManager.run(ie,c,m,G,K),Ge(n.name),k}upload(n,i){this.gpuDataManager.upload(n,i)}memcpy(n,i){this.gpuDataManager.memcpy(n,i)}async download(n,i){await this.gpuDataManager.download(n,i)}alloc(n){return this.gpuDataManager.create(n).id}free(n){return this.gpuDataManager.release(n)}createKernel(n,i,s,u){let d=fv.get(n);if(!d)throw new Error(`kernel not implemented: ${n}`);let f={kernelType:n,kernelName:u,kernelEntry:d[0],attributes:[d[1],s]};this.kernels.set(i,f)}releaseKernel(n){let i=this.kernelPersistentData.get(n);if(i){for(let s of i)this.gpuDataManager.release(s.id);this.kernelPersistentData.delete(n)}this.kernelCustomData.delete(n),this.kernels.delete(n)}computeKernel(n,i,s){let u=this.kernels.get(n);if(!u)throw new Error(`kernel not created: ${n}`);let d=u.kernelType,f=u.kernelName,c=u.kernelEntry,g=u.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${d}] ${f}" is not allowed to be called recursively`);this.currentKernelId=n,g[0]&&(g[1]=g[0](g[1]),g[0]=void 0),we("info",()=>`[WebGPU] Start to run kernel "[${d}] ${f}"...`);let v=this.env.debug;this.temporaryData=[];try{return v&&this.device.pushErrorScope("validation"),c(i,g[1]),0}catch(b){return s.push(Promise.resolve(`[WebGPU] Kernel "[${d}] ${f}" failed. ${b}`)),1}finally{v&&s.push(this.device.popErrorScope().then(b=>b?`GPU validation error for kernel "[${d}] ${f}": ${b.message}`:null));for(let b of this.temporaryData)this.gpuDataManager.release(b.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(n,i,s,u){let d=this.sessionExternalDataMapping.get(n);d||(d=new Map,this.sessionExternalDataMapping.set(n,d));let f=d.get(i),c=this.gpuDataManager.registerExternalBuffer(s,u,f);return d.set(i,[c,s]),c}unregisterBuffers(n){let i=this.sessionExternalDataMapping.get(n);i&&(i.forEach(s=>this.gpuDataManager.unregisterExternalBuffer(s[0])),this.sessionExternalDataMapping.delete(n))}getBuffer(n){let i=this.gpuDataManager.get(n);if(!i)throw new Error(`no GPU data for buffer: ${n}`);return i.buffer}createDownloader(n,i,s){return async()=>{let u=await sn(this,n,i);return te(u.buffer,s)}}writeTimestamp(n){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,n)}setQueryType(){var n;this.queryType="none",(((n=this.env.webgpu.profiling)==null?void 0:n.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){we("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){we("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){we("info","replay"),this.sessionStatus="replaying";let n=this.capturedCommandList.get(this.currentSessionId),i=this.capturedPendingKernels.get(this.currentSessionId),s=n.length;this.pendingKernels=[];for(let u=0;u<s;u++){let d=this.getComputePassEncoder(),f=n[u];this.writeTimestamp(this.pendingDispatchNumber*2),d.setPipeline(f.computePipeline),d.setBindGroup(0,f.bindGroup),d.dispatchWorkgroups(...f.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(i[u]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(n){this.unregisterBuffers(n),this.capturedCommandList.has(n)&&this.capturedCommandList.delete(n),this.capturedPendingKernels.has(n)&&this.capturedPendingKernels.delete(n),this.gpuDataManager.onReleaseSession(n)}onRunStart(n){this.currentSessionId=n,this.setQueryType()}}}),wv,l_,u_,c_,vv,bv,q2=_(()=>{C(),wv=1,l_=()=>wv++,u_=class{constructor(n){this.sessionId=n.sessionId,this.mlContext=n.context,this.mlTensor=n.tensor,this.dataType=n.dataType,this.tensorShape=n.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}destroy(){we("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(n){this.mlContext.writeTensor(this.mlTensor,n)}async read(n){return n?this.mlContext.readTensor(this.mlTensor,n):this.mlContext.readTensor(this.mlTensor)}sameTypeAndShape(n,i){return this.dataType===n&&this.tensorShape.every((s,u)=>s===i[u])}},c_=class{constructor(n,i){this.tensorManager=n,this.wrapper=i}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&this.tensorManager.releaseTensor(this.tensorWrapper)}async ensureTensor(n,i,s){if(this.wrapper){if(this.wrapper.sameTypeAndShape(n,i))return this.wrapper.tensor;s&&(this.activeUpload=new Uint8Array(await this.wrapper.read())),this.tensorManager.releaseTensor(this.wrapper)}let u=MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(n,i,u,!0,!0),s&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(n){if(this.wrapper){this.wrapper.write(n);return}this.activeUpload?this.activeUpload.set(n):this.activeUpload=new Uint8Array(n)}async download(n){if(this.activeUpload)if(n){n instanceof ArrayBuffer?new Uint8Array(n).set(this.activeUpload):new Uint8Array(n.buffer,n.byteOffset,n.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return n?this.wrapper.read(n):this.wrapper.read()}},vv=class{constructor(n){this.backend=n,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}reserveTensorId(){let n=l_();return this.tensorTrackersById.set(n,new c_(this)),n}releaseTensorId(n){let i=this.tensorTrackersById.get(n);i&&(this.tensorTrackersById.delete(n),i.tensorWrapper&&this.releaseTensor(i.tensorWrapper))}async ensureTensor(n,i,s,u){we("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${n}, dataType: ${i}, shape: ${s}, copyOld: ${u}}`);let d=this.tensorTrackersById.get(n);if(!d)throw new Error("Tensor not found.");return d.ensureTensor(i,s,u)}upload(n,i){let s=this.tensorTrackersById.get(n);if(!s)throw new Error("Tensor not found.");s.upload(i)}async download(n,i){we("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${n}, dstBuffer: ${i==null?void 0:i.byteLength}}`);let s=this.tensorTrackersById.get(n);if(!s)throw new Error("Tensor not found.");return s.download(i)}releaseTensorsForSession(n){for(let i of this.freeTensors)i.sessionId===n&&i.destroy();this.freeTensors=this.freeTensors.filter(i=>i.sessionId!==n)}registerTensor(n,i,s,u){let d=l_(),f=new u_({sessionId:this.backend.currentSessionId,context:n,tensor:i,dataType:s,shape:u});return this.tensorTrackersById.set(d,new c_(this,f)),this.externalTensors.add(f),d}async getCachedTensor(n,i,s,u,d){let f=this.backend.currentSessionId;for(let[v,b]of this.freeTensors.entries())if(b.sameTypeAndShape(n,i)){let $=this.freeTensors.splice(v,1)[0];return $.sessionId=f,$}let c=this.backend.currentContext;we("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${n}, shape: ${i}}`);let g=await c.createTensor({dataType:n,shape:i,dimensions:i,usage:s,writable:u,readable:d});return new u_({sessionId:f,context:c,tensor:g,dataType:n,shape:i})}releaseTensor(n){this.externalTensors.has(n)&&this.externalTensors.delete(n),this.freeTensors.push(n)}},bv=(...n)=>new vv(...n)}),d_,Mv,H2=_(()=>{nn(),Dn(),le(),q2(),C(),d_=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),Mv=class{constructor(n){this.tensorManager=bv(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,vo(n.logLevel,!!n.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(n){this.activeSessionId=n}get currentContext(){let n=this.getMLContext(this.currentSessionId);if(!n)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return n}registerMLContext(n,i){this.mlContextBySessionId.set(n,i);let s=this.sessionIdsByMLContext.get(i);s||(s=new Set,this.sessionIdsByMLContext.set(i,s)),s.add(n)}onReleaseSession(n){let i=this.mlContextBySessionId.get(n);if(!i)return;this.tensorManager.releaseTensorsForSession(n),this.mlContextBySessionId.delete(n);let s=this.sessionIdsByMLContext.get(i);s.delete(n),s.size===0&&this.sessionIdsByMLContext.delete(i)}getMLContext(n){return this.mlContextBySessionId.get(n)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(n){we("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n)}async ensureTensor(n,i,s,u){let d=d_.get(i);if(!d)throw new Error(`Unsupported ONNX data type: ${i}`);return this.tensorManager.ensureTensor(n,d,s,u)}uploadTensor(n,i){if(!bn().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");we("verbose",()=>`[WebNN] uploadTensor {tensorId: ${n}, data: ${i.byteLength}}`),this.tensorManager.upload(n,i)}async downloadTensor(n,i){return this.tensorManager.download(n,i)}createMLTensorDownloader(n,i){return async()=>{let s=await this.tensorManager.download(n);return te(s,i)}}registerMLTensor(n,i,s){let u=d_.get(i);if(!u)throw new Error(`Unsupported ONNX data type: ${i}`);let d=this.tensorManager.registerTensor(this.currentContext,n,u,s);return we("verbose",()=>`[WebNN] registerMLTensor {tensor: ${n}, dataType: ${u}, dimensions: ${s}} -> {tensorId: ${d}}`),d}registerMLConstant(n,i,s,u,d,f){if(!f)throw new Error("External mounted files are not available.");let c=n;n.startsWith("./")&&(c=n.substring(2));let g=f.get(c);if(!g)throw new Error(`File with name ${c} not found in preloaded files.`);if(i+s>g.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let v=g.slice(i,i+s).buffer,b;switch(d.dataType){case"float32":b=new Float32Array(v);break;case"float16":b=new Uint16Array(v);break;case"int32":b=new Int32Array(v);break;case"uint32":b=new Uint32Array(v);break;case"int64":b=new BigInt64Array(v);break;case"uint64":b=new BigUint64Array(v);break;case"int8":b=new Int8Array(v);break;case"uint8":b=new Uint8Array(v);break;default:throw new Error(`Unsupported data type: ${d.dataType} in creating WebNN Constant from external data.`)}return we("verbose",()=>`[WebNN] registerMLConstant {dataType: ${d.dataType}, shape: ${d.shape}}}`),u.constant(d,b)}flush(){}}}),xv={};y(xv,{init:()=>Sv});var im,Tv,Sv,K2=_(()=>{nn(),G2(),C(),Zt(),H2(),im=class z2{constructor(i,s,u,d){this.module=i,this.dataType=s,this.data=u,this.dims=d}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let i=Ae.size(this.dims);return i===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,i)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let i=Ae.size(this.dims);return i===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,i)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let i=Ae.size(this.dims);return i===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,i)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let i=Ae.size(this.dims);return i===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,i)}reshape(i){if(Ae.size(i)!==Ae.size(this.dims))throw new Error("Invalid new shape");return new z2(this.module,this.dataType,this.data,i)}},Tv=class{constructor(n,i,s){this.module=n,this.backend=i,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=i.adapterInfo;let u=n.HEAPU32,d=s>>>2;this.opKernelContext=u[d++];let f=u[d++];this.outputCount=u[d++],this.customDataOffset=u[d++],this.customDataSize=u[d++];let c=[];for(let g=0;g<f;g++){let v=u[d++],b=u[d++],$=u[d++],k=[];for(let m=0;m<$;m++)k.push(u[d++]);c.push(new im(n,v,b,k))}this.inputs=c}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(n,i){var c;let s=((c=i==null?void 0:i.inputs)==null?void 0:c.map(g=>typeof g=="number"?this.inputs[g]:g))??this.inputs,u=(i==null?void 0:i.outputs)??[],d=(g,v,b)=>new im(this.module,v,this.output(g,b),b),f=(g,v)=>{let b=zi(g,v);if(!b)throw new Error(`Unsupported data type: ${g}`);let $=b>0?this.backend.gpuDataManager.create(b).id:0;return new im(this.module,g,$,v)};return this.backend.run(n,s,u,d,f,this.outputCount)}output(n,i){let s=this.module.stackSave();try{let u=this.module.stackAlloc((1+i.length)*4),d=u>>2;this.module.HEAPU32[d++]=i.length;for(let f=0;f<i.length;f++)this.module.HEAPU32[d++]=i[f];return this.module._JsepOutput(this.opKernelContext,n,u)}catch(u){throw new Error(`Failed to generate kernel's output[${n}] with dims [${i}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${u}`)}finally{this.module.stackRestore(s)}}},Sv=async(n,i,s,u)=>{let d=i.jsepInit;if(!d)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(n==="webgpu"){let f=new yv;await f.initialize(s,u),d("webgpu",[f,c=>f.alloc(c),c=>f.free(c),(c,g,v,b=!1)=>{if(b)we("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${c}, dst=${g}, size=${v}`),f.memcpy(c,g);else{we("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${c}, gpuDataId=${g}, size=${v}`);let $=i.HEAPU8.subarray(c>>>0,(c>>>0)+v);f.upload(g,$)}},async(c,g,v)=>{we("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${c}, dataOffset=${g}, size=${v}`),await f.download(c,()=>i.HEAPU8.subarray(g>>>0,(g>>>0)+v))},(c,g,v)=>f.createKernel(c,g,v,i.UTF8ToString(i._JsepGetNodeName(g))),c=>f.releaseKernel(c),(c,g,v,b)=>{we("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${v}, kernel=${c}, contextDataOffset=${g}`);let $=new Tv(i,f,g);return f.computeKernel(c,$,b)},()=>f.captureBegin(),()=>f.captureEnd(),()=>f.replay()])}else{let f=new Mv(s);d("webnn",[f,()=>f.reserveTensorId(),c=>f.releaseTensorId(c),async(c,g,v,b)=>f.ensureTensor(c,g,v,b),(c,g)=>{f.uploadTensor(c,g)},async(c,g)=>f.downloadTensor(c,g)])}}}),Ev,p_,f_,Es,kv,om,h_,m_,g_,__,y_,w_,Cv=_(()=>{Ji(),yo(),nn(),Dn(),Ro(),gs(),Ev=(n,i)=>{bn()._OrtInit(n,i)!==0&&Zn("Can't initialize onnxruntime.")},p_=async n=>{Ev(n.wasm.numThreads,Ei(n.logLevel))},f_=async(n,i)=>{{let s=(K2(),E(xv)).init;if(i==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let u=n.webgpu.adapter;if(u){if(typeof u.limits!="object"||typeof u.features!="object"||typeof u.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let d=n.webgpu.powerPreference;if(d!==void 0&&d!=="low-power"&&d!=="high-performance")throw new Error(`Invalid powerPreference setting: "${d}"`);let f=n.webgpu.forceFallbackAdapter;if(f!==void 0&&typeof f!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${f}"`);if(u=await navigator.gpu.requestAdapter({powerPreference:d,forceFallbackAdapter:f}),!u)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await s("webgpu",bn(),n,u)}if(i==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await s("webnn",bn(),n)}}},Es=new Map,kv=n=>{let i=bn(),s=i.stackSave();try{let u=i.stackAlloc(8);return i._OrtGetInputOutputCount(n,u,u+4)!==0&&Zn("Can't get session input/output count."),[i.HEAP32[u/4],i.HEAP32[u/4+1]]}finally{i.stackRestore(s)}},om=n=>{let i=bn(),s=i._malloc(n.byteLength);if(s===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${n.byteLength}.`);return i.HEAPU8.set(n,s),[s,n.byteLength]},h_=async(n,i)=>{var k,m,K;let s,u,d=bn();Array.isArray(n)?[s,u]=n:n.buffer===d.HEAPU8.buffer?[s,u]=[n.byteOffset,n.byteLength]:[s,u]=om(n);let f=0,c=0,g=0,v=[],b=[],$=[];try{if([c,v]=ms(i),(i==null?void 0:i.externalData)&&d.mountExternalData){let _e=[];for(let Fe of i.externalData){let De=typeof Fe=="string"?Fe:Fe.path;_e.push(wo(typeof Fe=="string"?Fe:Fe.data).then(st=>{d.mountExternalData(De,st)}))}await Promise.all(_e)}for(let _e of(i==null?void 0:i.executionProviders)??[])if((typeof _e=="string"?_e:_e.name)==="webnn"){if(d.shouldTransferToMLTensor=!1,d.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof _e!="string"){let Fe=_e,De=Fe==null?void 0:Fe.context,st=Fe==null?void 0:Fe.gpuDevice,Lt=Fe==null?void 0:Fe.deviceType,jt=Fe==null?void 0:Fe.powerPreference;De?d.currentContext=De:st?d.currentContext=await navigator.ml.createContext(st):d.currentContext=await navigator.ml.createContext({deviceType:Lt,powerPreference:jt})}else d.currentContext=await navigator.ml.createContext();break}f=await d._OrtCreateSession(s,u,c),f===0&&Zn("Can't create a session."),(k=d.jsepOnCreateSession)==null||k.call(d),d.currentContext&&(d.jsepRegisterMLContext(f,d.currentContext),d.currentContext=void 0,d.shouldTransferToMLTensor=!0);let[G,X]=kv(f),ne=!!(i!=null&&i.enableGraphCapture),ie=[],ee=[],de=[];for(let _e=0;_e<G;_e++){let Fe=d._OrtGetInputName(f,_e);Fe===0&&Zn("Can't get an input name."),b.push(Fe),ie.push(d.UTF8ToString(Fe))}for(let _e=0;_e<X;_e++){let Fe=d._OrtGetOutputName(f,_e);Fe===0&&Zn("Can't get an output name."),$.push(Fe);let De=d.UTF8ToString(Fe);ee.push(De);{if(ne&&(i==null?void 0:i.preferredOutputLocation)===void 0){de.push("gpu-buffer");continue}let st=typeof(i==null?void 0:i.preferredOutputLocation)=="string"?i.preferredOutputLocation:((m=i==null?void 0:i.preferredOutputLocation)==null?void 0:m[De])??"cpu";if(st!=="cpu"&&st!=="cpu-pinned"&&st!=="gpu-buffer"&&st!=="ml-tensor")throw new Error(`Not supported preferred output location: ${st}.`);if(ne&&st!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${st}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);de.push(st)}}let he=null;return de.some(_e=>_e==="gpu-buffer"||_e==="ml-tensor")&&(g=d._OrtCreateBinding(f),g===0&&Zn("Can't create IO binding."),he={handle:g,outputPreferredLocations:de,outputPreferredLocationsEncoded:de.map(_e=>jo(_e))}),Es.set(f,[f,b,$,he,ne,!1]),[f,ie,ee]}catch(G){throw b.forEach(X=>d._OrtFree(X)),$.forEach(X=>d._OrtFree(X)),g!==0&&d._OrtReleaseBinding(g),f!==0&&d._OrtReleaseSession(f),G}finally{d._free(s),c!==0&&d._OrtReleaseSessionOptions(c),v.forEach(G=>d._free(G)),(K=d.unmountExternalData)==null||K.call(d)}},m_=n=>{var v;let i=bn(),s=Es.get(n);if(!s)throw new Error(`cannot release session. invalid session id: ${n}`);let[u,d,f,c,g]=s;c&&(g&&i._OrtClearBoundOutputs(c.handle),i._OrtReleaseBinding(c.handle)),(v=i.jsepOnReleaseSession)==null||v.call(i,n),d.forEach(b=>i._OrtFree(b)),f.forEach(b=>i._OrtFree(b)),i._OrtReleaseSession(u),Es.delete(n)},g_=(n,i,s,u,d,f=!1)=>{if(!n){i.push(0);return}let c=bn(),g=n[0],v=n[1],b=n[3],$,k;if(g==="string"&&(b==="gpu-buffer"||b==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(f&&b!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`);if(b==="gpu-buffer"){let G=n[2].gpuBuffer;k=zi(Zi(g),v);let X=c.jsepRegisterBuffer;if(!X)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');$=X(u,d,G,k)}else if(b==="ml-tensor"){let G=n[2].mlTensor;k=zi(Zi(g),v);let X=c.jsepRegisterMLTensor;if(!X)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');$=X(G,Zi(g),v)}else{let G=n[2];if(Array.isArray(G)){k=4*G.length,$=c._malloc(k),s.push($);let X=$/4;for(let ne=0;ne<G.length;ne++){if(typeof G[ne]!="string")throw new TypeError(`tensor data at index ${ne} is not a string`);c.HEAPU32[X++]=xn(G[ne],s)}}else k=G.byteLength,$=c._malloc(k),s.push($),c.HEAPU8.set(new Uint8Array(G.buffer,G.byteOffset,k),$)}let m=c.stackSave(),K=c.stackAlloc(4*v.length);try{let G=K/4;v.forEach(ne=>c.HEAP32[G++]=ne);let X=c._OrtCreateTensor(Zi(g),$,k,K,v.length,jo(b));X===0&&Zn(`Can't create tensor for input/output. session=${u}, index=${d}.`),i.push(X)}finally{c.stackRestore(m)}},__=async(n,i,s,u,d,f)=>{var jt,pn;let c=bn(),g=Es.get(n);if(!g)throw new Error(`cannot run inference. invalid session id: ${n}`);let v=g[0],b=g[1],$=g[2],k=g[3],m=g[4],K=g[5],G=i.length,X=u.length,ne=0,ie=[],ee=[],de=[],he=[],_e=c.stackSave(),Fe=c.stackAlloc(G*4),De=c.stackAlloc(G*4),st=c.stackAlloc(X*4),Lt=c.stackAlloc(X*4);try{(jt=c.jsepOnRunStart)==null||jt.call(c,v),[ne,ie]=cs(f);for(let Qt=0;Qt<G;Qt++)g_(s[Qt],ee,he,n,i[Qt],m);for(let Qt=0;Qt<X;Qt++)g_(d[Qt],de,he,n,G+u[Qt],m);let un=Fe/4,Jt=De/4,In=st/4,Yn=Lt/4;for(let Qt=0;Qt<G;Qt++)c.HEAPU32[un++]=ee[Qt],c.HEAPU32[Jt++]=b[i[Qt]];for(let Qt=0;Qt<X;Qt++)c.HEAPU32[In++]=de[Qt],c.HEAPU32[Yn++]=$[u[Qt]];if(k&&!K){let{handle:Qt,outputPreferredLocations:tn,outputPreferredLocationsEncoded:Pn}=k;if(b.length!==G)throw new Error(`input count from feeds (${G}) is expected to be always equal to model's input count (${b.length}).`);for(let Ke=0;Ke<G;Ke++){let kt=i[Ke];await c._OrtBindInput(Qt,b[kt],ee[Ke])!==0&&Zn(`Can't bind input[${Ke}] for session=${n}.`)}for(let Ke=0;Ke<X;Ke++){let kt=u[Ke];(pn=d[Ke])!=null&&pn[3]?c._OrtBindOutput(Qt,$[kt],de[Ke],0)!==0&&Zn(`Can't bind pre-allocated output[${Ke}] for session=${n}.`):c._OrtBindOutput(Qt,$[kt],0,Pn[kt])!==0&&Zn(`Can't bind output[${Ke}] to ${tn[Ke]} for session=${n}.`)}Es.set(n,[v,b,$,k,m,!0])}let wn;k?wn=await c._OrtRunWithBinding(v,k.handle,X,st,ne):wn=await c._OrtRun(v,De,Fe,G,Lt,X,st,ne),wn!==0&&Zn("failed to call OrtRun().");let Bn=[];for(let Qt=0;Qt<X;Qt++){let tn=c.HEAPU32[st/4+Qt];if(tn===de[Qt]){Bn.push(d[Qt]);continue}let Pn=c.stackSave(),Ke=c.stackAlloc(4*4),kt=!1,ln,Gn=0;try{c._OrtGetTensorData(tn,Ke,Ke+4,Ke+8,Ke+12)!==0&&Zn(`Can't access output tensor data on index ${Qt}.`);let xr=Ke/4,Sr=c.HEAPU32[xr++];Gn=c.HEAPU32[xr++];let Cs=c.HEAPU32[xr++],lm=c.HEAPU32[xr++],ui=[];for(let $r=0;$r<lm;$r++)ui.push(c.HEAPU32[Cs/4+$r]);c._OrtFree(Cs);let zr=ui.reduce(($r,Xr)=>$r*Xr,1);ln=hi(Sr);let xa=k==null?void 0:k.outputPreferredLocations[u[Qt]];if(ln==="string"){if(xa==="gpu-buffer"||xa==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let $r=[],Xr=Gn/4;for(let Ni=0;Ni<zr;Ni++){let Ps=c.HEAPU32[Xr++],um=Ni===zr-1?void 0:c.HEAPU32[Xr]-Ps;$r.push(c.UTF8ToString(Ps,um))}Bn.push([ln,ui,$r,"cpu"])}else if(xa==="gpu-buffer"&&zr>0){let $r=c.jsepGetBuffer;if(!$r)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Xr=$r(Gn),Ni=zi(Sr,zr);if(Ni===void 0||!No(ln))throw new Error(`Unsupported data type: ${ln}`);kt=!0,Bn.push([ln,ui,{gpuBuffer:Xr,download:c.jsepCreateDownloader(Xr,Ni,ln),dispose:()=>{c._OrtReleaseTensor(tn)}},"gpu-buffer"])}else if(xa==="ml-tensor"&&zr>0){let $r=c.jsepEnsureTensor;if(!$r)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(zi(Sr,zr)===void 0||!Uo(ln))throw new Error(`Unsupported data type: ${ln}`);let Xr=await $r(Gn,Sr,ui,!1);kt=!0,Bn.push([ln,ui,{mlTensor:Xr,download:c.jsepCreateMLTensorDownloader(Gn,ln),dispose:()=>{c.jsepReleaseTensorId(Gn),c._OrtReleaseTensor(tn)}},"ml-tensor"])}else{let $r=Bo(ln),Xr=new $r(zr);new Uint8Array(Xr.buffer,Xr.byteOffset,Xr.byteLength).set(c.HEAPU8.subarray(Gn,Gn+Xr.byteLength)),Bn.push([ln,ui,Xr,"cpu"])}}finally{c.stackRestore(Pn),ln==="string"&&Gn&&c._free(Gn),kt||c._OrtReleaseTensor(tn)}}return k&&!m&&(c._OrtClearBoundOutputs(k.handle),Es.set(n,[v,b,$,k,m,!1])),Bn}finally{c.stackRestore(_e),ee.forEach(un=>c._OrtReleaseTensor(un)),de.forEach(un=>c._OrtReleaseTensor(un)),he.forEach(un=>c._free(un)),ne!==0&&c._OrtReleaseRunOptions(ne),ie.forEach(un=>c._free(un))}},y_=n=>{let i=bn(),s=Es.get(n);if(!s)throw new Error("invalid session id");let u=s[0],d=i._OrtEndProfiling(u);d===0&&Zn("Can't get an profile file name."),i._OrtFree(d)},w_=n=>{let i=[];for(let s of n){let u=s[2];!Array.isArray(u)&&"buffer"in u&&i.push(u.buffer)}return i}}),ks,wi,Tu,bf,Mf,sm,v_,am,ba,Ma,Pv,$v,Av,Fv,Iv,Ov,Dv,zv,Lv=_(()=>{Dt(),Cv(),Dn(),Rt(),ks=()=>!!L.wasm.proxy&&typeof document<"u",Tu=!1,bf=!1,Mf=!1,am=new Map,ba=(n,i)=>{let s=am.get(n);s?s.push(i):am.set(n,[i])},Ma=()=>{if(Tu||!bf||Mf||!wi)throw new Error("worker not ready")},Pv=n=>{switch(n.data.type){case"init-wasm":Tu=!1,n.data.err?(Mf=!0,v_[1](n.data.err)):(bf=!0,v_[0]()),sm&&(URL.revokeObjectURL(sm),sm=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let i=am.get(n.data.type);n.data.err?i.shift()[1](n.data.err):i.shift()[0](n.data.out);break}}},$v=async()=>{if(!bf){if(Tu)throw new Error("multiple calls to 'initWasm()' detected.");if(Mf)throw new Error("previous call to 'initWasm()' failed.");if(Tu=!0,ks())return new Promise((n,i)=>{wi==null||wi.terminate(),_t().then(([s,u])=>{try{wi=u,wi.onerror=f=>i(f),wi.onmessage=Pv,v_=[n,i];let d={type:"init-wasm",in:L};wi.postMessage(d),sm=s}catch(d){i(d)}},i)});try{await Qn(L.wasm),await p_(L),bf=!0}catch(n){throw Mf=!0,n}finally{Tu=!1}}},Av=async n=>{if(ks())return Ma(),new Promise((i,s)=>{ba("init-ep",[i,s]);let u={type:"init-ep",in:{epName:n,env:L}};wi.postMessage(u)});await f_(L,n)},Fv=async n=>ks()?(Ma(),new Promise((i,s)=>{ba("copy-from",[i,s]);let u={type:"copy-from",in:{buffer:n}};wi.postMessage(u,[n.buffer])})):om(n),Iv=async(n,i)=>{if(ks()){if(i!=null&&i.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Ma(),new Promise((s,u)=>{ba("create",[s,u]);let d={type:"create",in:{model:n,options:{...i}}},f=[];n instanceof Uint8Array&&f.push(n.buffer),wi.postMessage(d,f)})}else return h_(n,i)},Ov=async n=>{if(ks())return Ma(),new Promise((i,s)=>{ba("release",[i,s]);let u={type:"release",in:n};wi.postMessage(u)});m_(n)},Dv=async(n,i,s,u,d,f)=>{if(ks()){if(s.some(c=>c[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(d.some(c=>c))throw new Error("pre-allocated output tensor is not supported for proxy.");return Ma(),new Promise((c,g)=>{ba("run",[c,g]);let v=s,b={type:"run",in:{sessionId:n,inputIndices:i,inputs:v,outputIndices:u,options:f}};wi.postMessage(b,w_(v))})}else return __(n,i,s,u,d,f)},zv=async n=>{if(ks())return Ma(),new Promise((i,s)=>{ba("end-profiling",[i,s]);let u={type:"end-profiling",in:n};wi.postMessage(u)});y_(n)}}),b_,Rv,Bv,X2=_(()=>{Dt(),Lv(),nn(),gn(),gs(),b_=(n,i)=>{switch(n.location){case"cpu":return[n.type,n.dims,n.data,"cpu"];case"gpu-buffer":return[n.type,n.dims,{gpuBuffer:n.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[n.type,n.dims,{mlTensor:n.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${n.location} for ${i()}`)}},Rv=n=>{switch(n[3]){case"cpu":return new ce(n[0],n[2],n[1]);case"gpu-buffer":{let i=n[0];if(!No(i))throw new Error(`not supported data type: ${i} for deserializing GPU tensor`);let{gpuBuffer:s,download:u,dispose:d}=n[2];return ce.fromGpuBuffer(s,{dataType:i,dims:n[1],download:u,dispose:d})}case"ml-tensor":{let i=n[0];if(!Uo(i))throw new Error(`not supported data type: ${i} for deserializing MLTensor tensor`);let{mlTensor:s,download:u,dispose:d}=n[2];return ce.fromMLTensor(s,{dataType:i,dims:n[1],download:u,dispose:d})}default:throw new Error(`invalid data location: ${n[3]}`)}},Bv=class{async fetchModelAndCopyToWasmMemory(n){return Fv(await wo(n))}async loadModel(n,i){We();let s;typeof n=="string"?s=await this.fetchModelAndCopyToWasmMemory(n):s=n,[this.sessionId,this.inputNames,this.outputNames]=await Iv(s,i),Ge()}async dispose(){return Ov(this.sessionId)}async run(n,i,s){We();let u=[],d=[];Object.entries(n).forEach(k=>{let m=k[0],K=k[1],G=this.inputNames.indexOf(m);if(G===-1)throw new Error(`invalid input '${m}'`);u.push(K),d.push(G)});let f=[],c=[];Object.entries(i).forEach(k=>{let m=k[0],K=k[1],G=this.outputNames.indexOf(m);if(G===-1)throw new Error(`invalid output '${m}'`);f.push(K),c.push(G)});let g=u.map((k,m)=>b_(k,()=>`input "${this.inputNames[d[m]]}"`)),v=f.map((k,m)=>k?b_(k,()=>`output "${this.outputNames[c[m]]}"`):null),b=await Dv(this.sessionId,d,g,c,v,s),$={};for(let k=0;k<b.length;k++)$[this.outputNames[c[k]]]=f[k]??Rv(b[k]);return Ge(),$}startProfiling(){}endProfiling(){zv(this.sessionId)}}}),Nv={};y(Nv,{OnnxruntimeWebAssemblyBackend:()=>x_,initializeFlags:()=>M_,wasmBackend:()=>Uv});var M_,x_,Uv,Q2=_(()=>{Dt(),Lv(),X2(),Rt(),M_=()=>{if((typeof L.wasm.initTimeout!="number"||L.wasm.initTimeout<0)&&(L.wasm.initTimeout=0),L.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof L.wasm.proxy!="boolean"&&(L.wasm.proxy=!1),typeof L.wasm.trace!="boolean"&&(L.wasm.trace=!1),typeof L.wasm.numThreads!="number"||!Number.isInteger(L.wasm.numThreads)||L.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)L.wasm.numThreads=1;else{let n=typeof navigator>"u"?w("node:os").cpus().length:navigator.hardwareConcurrency;L.wasm.numThreads=Math.min(4,Math.ceil((n||1)/2))}},x_=class{async init(n){M_(),await $v(),await Av(n)}async createInferenceSessionHandler(n,i){let s=new Bv;return await s.loadModel(n,i),Promise.resolve(s)}},Uv=new x_});Dt(),Dt(),Dt();var Y2="1.21.0-dev.20241024-d9ca84ef96",J2=Nt;{let n=(Q2(),E(Nv)).wasmBackend;W("webgpu",n,5),W("webnn",n,5),W("cpu",n,10),W("wasm",n,10)}Object.defineProperty(L.versions,"web",{value:Y2,enumerable:!0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},"./src/backends/onnx.js":(e,t,r)=>{var o;r.r(t),r.d(t,{Tensor:()=>w.Tensor,createInferenceSession:()=>B,deviceToExecutionProviders:()=>W,isONNXProxy:()=>P,isONNXTensor:()=>F});var a=r("./src/env.js"),l=r("?2ce3"),p=r("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),w=r("./node_modules/onnxruntime-common/dist/esm/index.js");const _=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),y=[];let T,E;const A=Symbol.for("onnxruntime");if(A in globalThis)E=globalThis[A];else if(a.apis.IS_NODE_ENV){switch(E=l??(o||(o=r.t(l,2))),process.platform){case"win32":y.push("dml");break;case"linux":process.arch==="x64"&&y.push("cuda");break}y.push("cpu"),T=["cpu"]}else E=p,a.apis.IS_WEBNN_AVAILABLE&&y.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),a.apis.IS_WEBGPU_AVAILABLE&&y.push("webgpu"),y.push("wasm"),T=["wasm"];const H=E.InferenceSession;function W(j=null){if(!j)return T;switch(j){case"auto":return y;case"gpu":return y.filter(V=>["webgpu","cuda","dml","webnn-gpu"].includes(V))}if(y.includes(j))return[_[j]??j];throw new Error(`Unsupported device: "${j}". Should be one of: ${y.join(", ")}.`)}let Y=null;async function B(j,V,z){Y&&await Y;const q=H.create(j,V);Y??(Y=q);const L=await q;return L.config=z,L}function F(j){return j instanceof E.Tensor}const O=E==null?void 0:E.env;O!=null&&O.wasm&&(O.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${a.env.version}/dist/`,O.wasm.proxy=!1,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(O.wasm.numThreads=1)),O!=null&&O.webgpu&&(O.webgpu.powerPreference="high-performance");function P(){var j;return(j=O==null?void 0:O.wasm)==null?void 0:j.proxy}a.env.backends.onnx=O},"./src/configs.js":(e,t,r)=>{r.r(t),r.d(t,{AutoConfig:()=>y,PretrainedConfig:()=>_,getKeyValueShapes:()=>w});var o=r("./src/utils/core.js"),a=r("./src/utils/hub.js");async function l(T,E){return await(0,a.getModelJSON)(T,"config.json",!0,E)}function p(T){const E={};let A={};switch(T.model_type){case"llava":case"paligemma":case"florence2":A=p(T.text_config);break;case"moondream1":A=p(T.phi_config);break;case"musicgen":A=p(T.decoder);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":E.num_heads="n_head",E.num_layers="n_layer",E.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"phi":case"phi3":case"falcon":E.num_heads="num_attention_heads",E.num_layers="num_hidden_layers",E.hidden_size="hidden_size";break;case"llama":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":E.num_heads="num_key_value_heads",E.num_layers="num_hidden_layers",E.hidden_size="hidden_size",E.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":E.num_heads="num_key_value_heads",E.num_layers="num_hidden_layers",E.dim_kv="head_dim";break;case"openelm":E.num_heads="num_kv_heads",E.num_layers="num_transformer_layers",E.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":E.num_heads="num_heads",E.num_layers="num_layers",E.hidden_size="hidden_size";break;case"bloom":E.num_heads="n_head",E.num_layers="n_layer",E.hidden_size="hidden_size";break;case"mpt":E.num_heads="n_heads",E.num_layers="n_layers",E.hidden_size="d_model";break;case"t5":case"mt5":case"longt5":E.num_decoder_layers="num_decoder_layers",E.num_decoder_heads="num_heads",E.decoder_dim_kv="d_kv",E.num_encoder_layers="num_layers",E.num_encoder_heads="num_heads",E.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":E.num_decoder_layers="decoder_layers",E.num_decoder_heads="decoder_attention_heads",E.decoder_hidden_size="d_model",E.num_encoder_layers="encoder_layers",E.num_encoder_heads="encoder_attention_heads",E.encoder_hidden_size="d_model";break;case"speecht5":E.num_decoder_layers="decoder_layers",E.num_decoder_heads="decoder_attention_heads",E.decoder_hidden_size="hidden_size",E.num_encoder_layers="encoder_layers",E.num_encoder_heads="encoder_attention_heads",E.encoder_hidden_size="hidden_size";break;case"trocr":E.num_encoder_layers=E.num_decoder_layers="decoder_layers",E.num_encoder_heads=E.num_decoder_heads="decoder_attention_heads",E.encoder_hidden_size=E.decoder_hidden_size="d_model";break;case"musicgen_decoder":E.num_encoder_layers=E.num_decoder_layers="num_hidden_layers",E.num_encoder_heads=E.num_decoder_heads="num_attention_heads",E.encoder_hidden_size=E.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const W=p(T.decoder),Y="num_decoder_layers"in W,B=(0,o.pick)(T,["model_type","is_encoder_decoder"]);return Y?(B.num_decoder_layers=W.num_decoder_layers,B.num_decoder_heads=W.num_decoder_heads,B.decoder_hidden_size=W.decoder_hidden_size,B.num_encoder_layers=W.num_encoder_layers,B.num_encoder_heads=W.num_encoder_heads,B.encoder_hidden_size=W.encoder_hidden_size):(B.num_layers=W.num_layers,B.num_heads=W.num_heads,B.hidden_size=W.hidden_size),B}const H={...A,...(0,o.pick)(T,["model_type","multi_query","is_encoder_decoder"])};for(const W in E)H[W]=T[E[W]];return H}function w(T,{prefix:E="past_key_values"}={}){const A={},H=T.normalized_config,W=1;if(H.is_encoder_decoder&&"num_encoder_heads"in H&&"num_decoder_heads"in H){const Y=H.encoder_dim_kv??H.encoder_hidden_size/H.num_encoder_heads,B=H.decoder_dim_kv??H.decoder_hidden_size/H.num_decoder_heads,F=[W,H.num_encoder_heads,0,Y],O=[W,H.num_decoder_heads,0,B];for(let P=0;P<H.num_decoder_layers;++P)A[`${E}.${P}.encoder.key`]=F,A[`${E}.${P}.encoder.value`]=F,A[`${E}.${P}.decoder.key`]=O,A[`${E}.${P}.decoder.value`]=O}else{const Y=H.num_heads,B=H.num_layers,F=H.dim_kv??H.hidden_size/(H.num_attention_heads??Y);if(H.model_type==="falcon"){const O=[W*Y,0,F];for(let P=0;P<B;++P)A[`${E}.${P}.key`]=O,A[`${E}.${P}.value`]=O}else if(H.multi_query){const O=[W*Y,0,2*F];for(let P=0;P<B;++P)A[`${E}.${P}.key_value`]=O}else if(H.model_type==="bloom"){const O=[W*Y,F,0],P=[W*Y,0,F];for(let j=0;j<B;++j)A[`${E}.${j}.key`]=O,A[`${E}.${j}.value`]=P}else if(H.model_type==="openelm")for(let O=0;O<B;++O){const P=[W,Y[O],0,F];A[`${E}.${O}.key`]=P,A[`${E}.${O}.value`]=P}else{const O=[W,Y,0,F];for(let P=0;P<B;++P)A[`${E}.${P}.key`]=O,A[`${E}.${P}.value`]=O}}return A}class _{constructor(E){Ee(this,"model_type",null);Ee(this,"is_encoder_decoder",!1);Ee(this,"max_position_embeddings");Ee(this,"transformers.js_config");Object.assign(this,E),this.normalized_config=p(this)}static async from_pretrained(E,{progress_callback:A=null,config:H=null,cache_dir:W=null,local_files_only:Y=!1,revision:B="main"}={}){H&&!(H instanceof _)&&(H=new _(H));const F=H??await l(E,{progress_callback:A,config:H,cache_dir:W,local_files_only:Y,revision:B});return new this(F)}}class y{static async from_pretrained(...E){return _.from_pretrained(...E)}}},"./src/env.js":(e,t,r)=>{var L;r.r(t),r.d(t,{apis:()=>B,env:()=>z});var o=r("?569f"),a=r("?3f59"),l=r("?154a");const p="3.0.1",w=typeof self<"u",_=w&&self.constructor.name==="DedicatedWorkerGlobalScope",y=w&&"caches"in self,T=typeof navigator<"u"&&"gpu"in navigator,E=typeof navigator<"u"&&"ml"in navigator,A=typeof process<"u",H=A&&((L=process==null?void 0:process.release)==null?void 0:L.name)==="node",W=!q(o),Y=!q(a),B=Object.freeze({IS_BROWSER_ENV:w,IS_WEBWORKER_ENV:_,IS_WEB_CACHE_AVAILABLE:y,IS_WEBGPU_AVAILABLE:T,IS_WEBNN_AVAILABLE:E,IS_PROCESS_AVAILABLE:A,IS_NODE_ENV:H,IS_FS_AVAILABLE:W,IS_PATH_AVAILABLE:Y}),F=W&&Y,O=F?a.dirname(a.dirname(l.fileURLToPath(import.meta.url))):"./",P=F?a.join(O,"/.cache/"):null,j="/models/",V=F?a.join(O,j):j,z={version:p,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!w,localModelPath:V,useFS:W,useBrowserCache:y,useFSCache:W,cacheDir:P,useCustomCache:!1,customCache:null};function q(pe){return Object.keys(pe).length===0}},"./src/generation/configuration_utils.js":(e,t,r)=>{r.r(t),r.d(t,{GenerationConfig:()=>a});var o=r("./src/utils/core.js");class a{constructor(p){Ee(this,"max_length",20);Ee(this,"max_new_tokens",null);Ee(this,"min_length",0);Ee(this,"min_new_tokens",null);Ee(this,"early_stopping",!1);Ee(this,"max_time",null);Ee(this,"do_sample",!1);Ee(this,"num_beams",1);Ee(this,"num_beam_groups",1);Ee(this,"penalty_alpha",null);Ee(this,"use_cache",!0);Ee(this,"temperature",1);Ee(this,"top_k",50);Ee(this,"top_p",1);Ee(this,"typical_p",1);Ee(this,"epsilon_cutoff",0);Ee(this,"eta_cutoff",0);Ee(this,"diversity_penalty",0);Ee(this,"repetition_penalty",1);Ee(this,"encoder_repetition_penalty",1);Ee(this,"length_penalty",1);Ee(this,"no_repeat_ngram_size",0);Ee(this,"bad_words_ids",null);Ee(this,"force_words_ids",null);Ee(this,"renormalize_logits",!1);Ee(this,"constraints",null);Ee(this,"forced_bos_token_id",null);Ee(this,"forced_eos_token_id",null);Ee(this,"remove_invalid_values",!1);Ee(this,"exponential_decay_length_penalty",null);Ee(this,"suppress_tokens",null);Ee(this,"begin_suppress_tokens",null);Ee(this,"forced_decoder_ids",null);Ee(this,"guidance_scale",null);Ee(this,"num_return_sequences",1);Ee(this,"output_attentions",!1);Ee(this,"output_hidden_states",!1);Ee(this,"output_scores",!1);Ee(this,"return_dict_in_generate",!1);Ee(this,"pad_token_id",null);Ee(this,"bos_token_id",null);Ee(this,"eos_token_id",null);Ee(this,"encoder_no_repeat_ngram_size",0);Ee(this,"decoder_start_token_id",null);Ee(this,"generation_kwargs",{});Object.assign(this,(0,o.pick)(p,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,t,r)=>{r.r(t),r.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>F,ForcedBOSTokenLogitsProcessor:()=>_,ForcedEOSTokenLogitsProcessor:()=>y,LogitsProcessor:()=>l,LogitsProcessorList:()=>w,LogitsWarper:()=>p,MinLengthLogitsProcessor:()=>W,MinNewTokensLengthLogitsProcessor:()=>Y,NoBadWordsLogitsProcessor:()=>B,NoRepeatNGramLogitsProcessor:()=>A,RepetitionPenaltyLogitsProcessor:()=>H,SuppressTokensAtBeginLogitsProcessor:()=>T,TemperatureLogitsWarper:()=>O,TopKLogitsWarper:()=>j,TopPLogitsWarper:()=>P,WhisperTimeStampLogitsProcessor:()=>E});var o=r("./src/utils/generic.js");r("./src/utils/tensor.js");var a=r("./src/utils/maths.js");class l extends o.Callable{_call(z,q){throw Error("`_call` should be implemented in a subclass")}}class p extends o.Callable{_call(z,q){throw Error("`_call` should be implemented in a subclass")}}class w extends o.Callable{constructor(){super(),this.processors=[]}push(z){this.processors.push(z)}extend(z){this.processors.push(...z)}_call(z,q){let L=q;for(const pe of this.processors)L=pe(z,L);return L}[Symbol.iterator](){return this.processors.values()}}class _ extends l{constructor(z){super(),this.bos_token_id=z}_call(z,q){for(let L=0;L<z.length;++L)if(z[L].length===1){const pe=q[L].data;pe.fill(-1/0),pe[this.bos_token_id]=0}return q}}class y extends l{constructor(z,q){super(),this.max_length=z,this.eos_token_id=Array.isArray(q)?q:[q]}_call(z,q){for(let L=0;L<z.length;++L)if(z[L].length===this.max_length-1){const pe=q[L].data;pe.fill(-1/0);for(const fe of this.eos_token_id)pe[fe]=0}return q}}class T extends l{constructor(z,q){super(),this.begin_suppress_tokens=z,this.begin_index=q}_call(z,q){for(let L=0;L<z.length;++L)if(z[L].length===this.begin_index){const pe=q[L].data;for(const fe of this.begin_suppress_tokens)pe[fe]=-1/0}return q}}class E extends l{constructor(z,q){super(),this.eos_token_id=Array.isArray(z.eos_token_id)?z.eos_token_id[0]:z.eos_token_id,this.no_timestamps_token_id=z.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=q.length,q.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=z.max_initial_timestamp_index}_call(z,q){for(let L=0;L<z.length;++L){const pe=q[L].data;if(pe[this.no_timestamps_token_id]=-1/0,z[L].length===this.begin_index-1){pe.fill(-1/0),pe[this.timestamp_begin]=0;continue}const fe=z[L].slice(this.begin_index),xe=fe.length>=1&&fe[fe.length-1]>=this.timestamp_begin,$e=fe.length<2||fe[fe.length-2]>=this.timestamp_begin;if(xe&&($e?pe.subarray(this.timestamp_begin).fill(-1/0):pe.subarray(0,this.eos_token_id).fill(-1/0)),z[L].length===this.begin_index&&this.max_initial_timestamp_index!==null){const it=this.timestamp_begin+this.max_initial_timestamp_index;pe.subarray(it+1).fill(-1/0)}const Ce=(0,a.log_softmax)(pe),tt=Math.log(Ce.subarray(this.timestamp_begin).map(Math.exp).reduce((it,be)=>it+be)),Je=(0,a.max)(Ce.subarray(0,this.timestamp_begin))[0];tt>Je&&pe.subarray(0,this.timestamp_begin).fill(-1/0)}return q}}class A extends l{constructor(z){super(),this.no_repeat_ngram_size=z}getNgrams(z){const q=z.length,L=[];for(let fe=0;fe<q+1-this.no_repeat_ngram_size;++fe){const xe=[];for(let $e=0;$e<this.no_repeat_ngram_size;++$e)xe.push(z[fe+$e]);L.push(xe.map(Number))}const pe=new Map;for(const fe of L){const xe=fe.slice(0,fe.length-1),$e=JSON.stringify(xe),Ce=pe.get($e)??[];Ce.push(fe[fe.length-1]),pe.set($e,Ce)}return pe}getGeneratedNgrams(z,q){const L=q.slice(q.length+1-this.no_repeat_ngram_size,q.length);return z.get(JSON.stringify(L.map(Number)))??[]}calcBannedNgramTokens(z){const q=[];if(z.length+1<this.no_repeat_ngram_size)return q;{const L=this.getNgrams(z);return this.getGeneratedNgrams(L,z)}}_call(z,q){for(let L=0;L<z.length;++L){const pe=q[L].data,fe=this.calcBannedNgramTokens(z[L]);for(const xe of fe)pe[xe]=-1/0}return q}}class H extends l{constructor(z){super(),this.penalty=z}_call(z,q){for(let L=0;L<z.length;++L){const pe=q[L].data;for(const fe of z[L]){const xe=Number(fe);pe[xe]<0?pe[xe]*=this.penalty:pe[xe]/=this.penalty}}return q}}class W extends l{constructor(z,q){super(),this.min_length=z,this.eos_token_id=Array.isArray(q)?q:[q]}_call(z,q){for(let L=0;L<z.length;++L)if(z[L].length<this.min_length){const pe=q[L].data;for(const fe of this.eos_token_id)pe[fe]=-1/0}return q}}class Y extends l{constructor(z,q,L){super(),this.prompt_length_to_skip=z,this.min_new_tokens=q,this.eos_token_id=Array.isArray(L)?L:[L]}_call(z,q){for(let L=0;L<z.length;++L)if(z[L].length-this.prompt_length_to_skip<this.min_new_tokens){const fe=q[L].data;for(const xe of this.eos_token_id)fe[xe]=-1/0}return q}}class B extends l{constructor(z,q){super(),this.bad_words_ids=z,this.eos_token_id=Array.isArray(q)?q:[q]}_call(z,q){for(let L=0;L<z.length;++L){const pe=q[L].data,fe=z[L];for(const xe of this.bad_words_ids){let $e=!0;for(let Ce=1;Ce<=xe.length-1&&xe.length<fe.length;++Ce)if(xe.at(-Ce-1)!=fe.at(-Ce)){$e=!1;break}$e&&(pe[xe.at(-1)]=-1/0)}}return q}}class F extends l{constructor(z){if(super(),z<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${z}.`);this.guidance_scale=z}_call(z,q){if(q.dims[0]!==2*z.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${q.dims[0]} for the logits and ${z.length} for the input ids.`);const L=z.length,pe=q.slice([0,L],null),fe=q.slice([L,q.dims[0]],null);for(let xe=0;xe<fe.data.length;++xe)fe.data[xe]+=(pe.data[xe]-fe.data[xe])*this.guidance_scale;return fe}}class O extends p{constructor(z){super(),this.temperature=z}_call(z,q){const L=q.data;for(let pe=0;pe<L.length;++pe)L[pe]/=this.temperature;return q}}class P extends p{constructor(z,{filter_value:q=-1/0,min_tokens_to_keep:L=1}={}){if(super(),z<0||z>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${z}`);if(!Number.isInteger(L)||L<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${L}`);this.top_p=z,this.filter_value=q,this.min_tokens_to_keep=L}}class j extends p{constructor(z,{filter_value:q=-1/0,min_tokens_to_keep:L=1}={}){if(super(),!Number.isInteger(z)||z<0)throw new Error(`\`top_k\` must be a positive integer, but is ${z}`);this.top_k=Math.max(z,L),this.filter_value=q}}},"./src/generation/logits_sampler.js":(e,t,r)=>{r.r(t),r.d(t,{LogitsSampler:()=>p});var o=r("./src/utils/generic.js"),a=r("./src/utils/tensor.js"),l=r("./src/utils/maths.js");r("./src/generation/configuration_utils.js");class p extends o.Callable{constructor(E){super(),this.generation_config=E}async _call(E){return this.sample(E)}async sample(E){throw Error("sample should be implemented in subclasses.")}getLogits(E,A){let H=E.dims.at(-1),W=E.data;if(A===-1)W=W.slice(-H);else{let Y=A*H;W=W.slice(Y,Y+H)}return W}randomSelect(E){let A=0;for(let W=0;W<E.length;++W)A+=E[W];let H=Math.random()*A;for(let W=0;W<E.length;++W)if(H-=E[W],H<=0)return W;return 0}static getSampler(E){if(E.do_sample)return new _(E);if(E.num_beams>1)return new y(E);if(E.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${E.num_return_sequences}.`);return new w(E)}}class w extends p{async sample(E){const A=(0,l.max)(E.data)[1];return[[BigInt(A),0]]}}class _ extends p{async sample(E){let A=E.dims.at(-1);this.generation_config.top_k>0&&(A=Math.min(this.generation_config.top_k,A));const[H,W]=await(0,a.topk)(E,A),Y=(0,l.softmax)(H.data);return Array.from({length:this.generation_config.num_beams},()=>{const B=this.randomSelect(Y);return[W.data[B],Math.log(Y[B])]})}}class y extends p{async sample(E){let A=E.dims.at(-1);this.generation_config.top_k>0&&(A=Math.min(this.generation_config.top_k,A));const[H,W]=await(0,a.topk)(E,A),Y=(0,l.softmax)(H.data);return Array.from({length:this.generation_config.num_beams},(B,F)=>[W.data[F],Math.log(Y[F])])}}},"./src/generation/stopping_criteria.js":(e,t,r)=>{r.r(t),r.d(t,{EosTokenCriteria:()=>w,InterruptableStoppingCriteria:()=>_,MaxLengthCriteria:()=>p,StoppingCriteria:()=>a,StoppingCriteriaList:()=>l});var o=r("./src/utils/generic.js");class a extends o.Callable{_call(T,E){throw Error("StoppingCriteria needs to be subclassed")}}class l extends o.Callable{constructor(){super(),this.criteria=[]}push(T){this.criteria.push(T)}extend(T){T instanceof l?T=T.criteria:T instanceof a&&(T=[T]),this.criteria.push(...T)}_call(T,E){const A=new Array(T.length).fill(!1);for(const H of this.criteria){const W=H(T,E);for(let Y=0;Y<A.length;++Y)A[Y]||(A[Y]=W[Y])}return A}[Symbol.iterator](){return this.criteria.values()}}class p extends a{constructor(T,E=null){super(),this.max_length=T,this.max_position_embeddings=E}_call(T){return T.map(E=>E.length>=this.max_length)}}class w extends a{constructor(T){super(),Array.isArray(T)||(T=[T]),this.eos_token_id=T}_call(T,E){return T.map(A=>{const H=A.at(-1);return this.eos_token_id.some(W=>H==W)})}}class _ extends a{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(T,E){return new Array(T.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,t,r)=>{r.r(t),r.d(t,{BaseStreamer:()=>p,TextStreamer:()=>_,WhisperTextStreamer:()=>y});var o=r("./src/utils/core.js"),a=r("./src/tokenizers.js"),l=r("./src/env.js");class p{put(E){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const w=l.apis.IS_PROCESS_AVAILABLE?T=>process.stdout.write(T):T=>console.log(T);class _ extends p{constructor(E,{skip_prompt:A=!1,callback_function:H=null,token_callback_function:W=null,decode_kwargs:Y={},...B}={}){super(),this.tokenizer=E,this.skip_prompt=A,this.callback_function=H??w,this.token_callback_function=W,this.decode_kwargs={...Y,...B},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(E){var Y;if(E.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt){this.next_tokens_are_prompt=!1;return}const A=E[0];(Y=this.token_callback_function)==null||Y.call(this,A),this.token_cache=(0,o.mergeArrays)(this.token_cache,A);const H=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let W;H.endsWith(`
`)?(W=H.slice(this.print_len),this.token_cache=[],this.print_len=0):H.length>0&&(0,a.is_chinese_char)(H.charCodeAt(H.length-1))?(W=H.slice(this.print_len),this.print_len+=W.length):(W=H.slice(this.print_len,H.lastIndexOf(" ")+1),this.print_len+=W.length),this.on_finalized_text(W,!1)}end(){let E;this.token_cache.length>0?(E=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):E="",this.next_tokens_are_prompt=!0,this.on_finalized_text(E,!0)}on_finalized_text(E,A){var H,W;E.length>0&&((H=this.callback_function)==null||H.call(this,E)),A&&this.callback_function===w&&l.apis.IS_PROCESS_AVAILABLE&&((W=this.callback_function)==null||W.call(this,`
`))}}class y extends _{constructor(E,{skip_prompt:A=!1,callback_function:H=null,token_callback_function:W=null,on_chunk_start:Y=null,on_chunk_end:B=null,on_finalize:F=null,time_precision:O=.02,skip_special_tokens:P=!0,decode_kwargs:j={}}={}){super(E,{skip_prompt:A,callback_function:H,token_callback_function:W,decode_kwargs:{skip_special_tokens:P,...j}}),this.timestamp_begin=E.timestamp_begin,this.on_chunk_start=Y,this.on_chunk_end=B,this.on_finalize=F,this.time_precision=O,this.waiting_for_timestamp=!1}put(E){var H,W;if(E.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const A=E[0];if(A.length===1){const Y=Number(A[0])-this.timestamp_begin;if(Y>=0){const B=Y*this.time_precision;this.waiting_for_timestamp?(H=this.on_chunk_end)==null||H.call(this,B):(W=this.on_chunk_start)==null||W.call(this,B),this.waiting_for_timestamp=!this.waiting_for_timestamp,E=[[]]}}return super.put(E)}end(){var E;super.end(),(E=this.on_finalize)==null||E.call(this)}}},"./src/models.js":(e,t,r)=>{r.r(t),r.d(t,{ASTForAudioClassification:()=>na,ASTModel:()=>Kt,ASTPreTrainedModel:()=>Ri,AlbertForMaskedLM:()=>nn,AlbertForQuestionAnswering:()=>jo,AlbertForSequenceClassification:()=>Uo,AlbertModel:()=>No,AlbertPreTrainedModel:()=>Ei,AutoModel:()=>_u,AutoModelForAudioClassification:()=>em,AutoModelForAudioFrameClassification:()=>yu,AutoModelForCTC:()=>pf,AutoModelForCausalLM:()=>tf,AutoModelForDepthEstimation:()=>ff,AutoModelForDocumentQuestionAnswering:()=>wu,AutoModelForImageClassification:()=>of,AutoModelForImageFeatureExtraction:()=>Mu,AutoModelForImageMatting:()=>vu,AutoModelForImageSegmentation:()=>sf,AutoModelForImageToImage:()=>bu,AutoModelForMaskGeneration:()=>df,AutoModelForMaskedLM:()=>nf,AutoModelForNormalEstimation:()=>hf,AutoModelForObjectDetection:()=>uf,AutoModelForQuestionAnswering:()=>Zh,AutoModelForSemanticSegmentation:()=>af,AutoModelForSeq2SeqLM:()=>Jh,AutoModelForSequenceClassification:()=>Qp,AutoModelForSpeechSeq2Seq:()=>Jp,AutoModelForTextToSpectrogram:()=>Zp,AutoModelForTextToWaveform:()=>ef,AutoModelForTokenClassification:()=>Yp,AutoModelForUniversalSegmentation:()=>lf,AutoModelForVision2Seq:()=>rf,AutoModelForXVector:()=>Ss,AutoModelForZeroShotObjectDetection:()=>cf,BartForConditionalGeneration:()=>le,BartForSequenceClassification:()=>ve,BartModel:()=>te,BartPretrainedModel:()=>C,BaseModelOutput:()=>et,BeitForImageClassification:()=>gd,BeitModel:()=>md,BeitPreTrainedModel:()=>Ml,BertForMaskedLM:()=>vt,BertForQuestionAnswering:()=>ze,BertForSequenceClassification:()=>nt,BertForTokenClassification:()=>ce,BertModel:()=>rt,BertPreTrainedModel:()=>Ie,BlenderbotForConditionalGeneration:()=>zn,BlenderbotModel:()=>sn,BlenderbotPreTrainedModel:()=>Bt,BlenderbotSmallForConditionalGeneration:()=>gr,BlenderbotSmallModel:()=>er,BlenderbotSmallPreTrainedModel:()=>hn,BloomForCausalLM:()=>qc,BloomModel:()=>Gc,BloomPreTrainedModel:()=>hl,CLIPModel:()=>fc,CLIPPreTrainedModel:()=>Mo,CLIPSegForImageSegmentation:()=>bc,CLIPSegModel:()=>vc,CLIPSegPreTrainedModel:()=>Xa,CLIPTextModel:()=>Eh,CLIPTextModelWithProjection:()=>Zr,CLIPVisionModel:()=>kh,CLIPVisionModelWithProjection:()=>hc,CamembertForMaskedLM:()=>pr,CamembertForQuestionAnswering:()=>Hr,CamembertForSequenceClassification:()=>Xn,CamembertForTokenClassification:()=>mr,CamembertModel:()=>An,CamembertPreTrainedModel:()=>gn,CausalLMOutput:()=>so,CausalLMOutputWithPast:()=>tm,ChineseCLIPModel:()=>wc,ChineseCLIPPreTrainedModel:()=>yc,ClapAudioModelWithProjection:()=>Zl,ClapModel:()=>ya,ClapPreTrainedModel:()=>Jl,ClapTextModelWithProjection:()=>Ts,CodeGenForCausalLM:()=>$c,CodeGenModel:()=>Pc,CodeGenPreTrainedModel:()=>ai,CohereForCausalLM:()=>yi,CohereModel:()=>Dc,CoherePreTrainedModel:()=>ol,ConvBertForMaskedLM:()=>J,ConvBertForQuestionAnswering:()=>dt,ConvBertForSequenceClassification:()=>ue,ConvBertForTokenClassification:()=>Me,ConvBertModel:()=>se,ConvBertPreTrainedModel:()=>U,ConvNextForImageClassification:()=>Or,ConvNextModel:()=>io,ConvNextPreTrainedModel:()=>ua,ConvNextV2ForImageClassification:()=>Ll,ConvNextV2Model:()=>da,ConvNextV2PreTrainedModel:()=>ca,DPTForDepthEstimation:()=>Od,DPTModel:()=>Id,DPTPreTrainedModel:()=>Ol,DebertaForMaskedLM:()=>Se,DebertaForQuestionAnswering:()=>Ve,DebertaForSequenceClassification:()=>Re,DebertaForTokenClassification:()=>Oe,DebertaModel:()=>oe,DebertaPreTrainedModel:()=>ft,DebertaV2ForMaskedLM:()=>yt,DebertaV2ForQuestionAnswering:()=>Ut,DebertaV2ForSequenceClassification:()=>$t,DebertaV2ForTokenClassification:()=>_t,DebertaV2Model:()=>xt,DebertaV2PreTrainedModel:()=>ut,DecisionTransformerModel:()=>Ip,DecisionTransformerPreTrainedModel:()=>Fp,DeiTForImageClassification:()=>Td,DeiTModel:()=>xd,DeiTPreTrainedModel:()=>$l,DepthAnythingForDepthEstimation:()=>zd,DepthAnythingPreTrainedModel:()=>Dd,DepthProForDepthEstimation:()=>Nd,DepthProPreTrainedModel:()=>Bd,DetrForObjectDetection:()=>yd,DetrForSegmentation:()=>xl,DetrModel:()=>_d,DetrObjectDetectionOutput:()=>Tl,DetrPreTrainedModel:()=>aa,DetrSegmentationOutput:()=>wd,Dinov2ForImageClassification:()=>Wd,Dinov2Model:()=>Vd,Dinov2PreTrainedModel:()=>Rl,DistilBertForMaskedLM:()=>Ht,DistilBertForQuestionAnswering:()=>mt,DistilBertForSequenceClassification:()=>Be,DistilBertForTokenClassification:()=>Ne,DistilBertModel:()=>Rt,DistilBertPreTrainedModel:()=>Gt,DonutSwinModel:()=>ro,DonutSwinPreTrainedModel:()=>no,EfficientNetForImageClassification:()=>Tp,EfficientNetModel:()=>iu,EfficientNetPreTrainedModel:()=>ru,ElectraForMaskedLM:()=>Tt,ElectraForQuestionAnswering:()=>Dt,ElectraForSequenceClassification:()=>St,ElectraForTokenClassification:()=>Nt,ElectraModel:()=>Wt,ElectraPreTrainedModel:()=>at,EsmForMaskedLM:()=>Qn,EsmForSequenceClassification:()=>bn,EsmForTokenClassification:()=>Dn,EsmModel:()=>En,EsmPreTrainedModel:()=>cn,FalconForCausalLM:()=>vp,FalconModel:()=>wp,FalconPreTrainedModel:()=>Yl,FastViTForImageClassification:()=>sd,FastViTModel:()=>od,FastViTPreTrainedModel:()=>_l,Florence2ForConditionalGeneration:()=>Ka,Florence2PreTrainedModel:()=>pc,GLPNForDepthEstimation:()=>to,GLPNModel:()=>Fh,GLPNPreTrainedModel:()=>zl,GPT2LMHeadModel:()=>gi,GPT2Model:()=>Mc,GPT2PreTrainedModel:()=>Qa,GPTBigCodeForCausalLM:()=>nl,GPTBigCodeModel:()=>ra,GPTBigCodePreTrainedModel:()=>tl,GPTJForCausalLM:()=>_i,GPTJModel:()=>Ch,GPTJPreTrainedModel:()=>el,GPTNeoForCausalLM:()=>Ec,GPTNeoModel:()=>Sc,GPTNeoPreTrainedModel:()=>Ja,GPTNeoXForCausalLM:()=>Cc,GPTNeoXModel:()=>kc,GPTNeoXPreTrainedModel:()=>Za,Gemma2ForCausalLM:()=>Bc,Gemma2Model:()=>Rc,Gemma2PreTrainedModel:()=>al,GemmaForCausalLM:()=>Lc,GemmaModel:()=>zc,GemmaPreTrainedModel:()=>sl,GraniteForCausalLM:()=>Oc,GraniteModel:()=>Ic,GranitePreTrainedModel:()=>il,GroupViTModel:()=>id,GroupViTPreTrainedModel:()=>rd,HieraForImageClassification:()=>Fl,HieraModel:()=>Sd,HieraPreTrainedModel:()=>Al,HubertForCTC:()=>Lh,HubertForSequenceClassification:()=>sp,HubertModel:()=>op,HubertPreTrainedModel:()=>zh,ImageMattingOutput:()=>_f,JAISLMHeadModel:()=>Tc,JAISModel:()=>xc,JAISPreTrainedModel:()=>Ya,LlamaForCausalLM:()=>Fc,LlamaModel:()=>Ac,LlamaPreTrainedModel:()=>rl,LlavaForConditionalGeneration:()=>Wo,LlavaPreTrainedModel:()=>dc,LongT5ForConditionalGeneration:()=>ws,LongT5Model:()=>ys,LongT5PreTrainedModel:()=>Vo,M2M100ForConditionalGeneration:()=>xs,M2M100Model:()=>Vl,M2M100PreTrainedModel:()=>jl,MBartForCausalLM:()=>Pt,MBartForConditionalGeneration:()=>Mt,MBartForSequenceClassification:()=>At,MBartModel:()=>He,MBartPreTrainedModel:()=>Te,MPNetForMaskedLM:()=>ps,MPNetForQuestionAnswering:()=>ms,MPNetForSequenceClassification:()=>fs,MPNetForTokenClassification:()=>hs,MPNetModel:()=>ds,MPNetPreTrainedModel:()=>Ji,MT5ForConditionalGeneration:()=>we,MT5Model:()=>vs,MT5PreTrainedModel:()=>vo,MarianMTModel:()=>Ih,MarianModel:()=>Hd,MarianPreTrainedModel:()=>Ul,MaskFormerForInstanceSegmentation:()=>jd,MaskFormerModel:()=>Ud,MaskFormerPreTrainedModel:()=>Dl,MaskedLMOutput:()=>Cr,MistralForCausalLM:()=>mp,MistralModel:()=>hp,MistralPreTrainedModel:()=>Ql,MobileBertForMaskedLM:()=>Zn,MobileBertForQuestionAnswering:()=>cs,MobileBertForSequenceClassification:()=>Ro,MobileBertModel:()=>si,MobileBertPreTrainedModel:()=>xn,MobileNetV1ForImageClassification:()=>Sp,MobileNetV1Model:()=>Wh,MobileNetV1PreTrainedModel:()=>au,MobileNetV2ForImageClassification:()=>kp,MobileNetV2Model:()=>Ep,MobileNetV2PreTrainedModel:()=>lu,MobileNetV3ForImageClassification:()=>$p,MobileNetV3Model:()=>Pp,MobileNetV3PreTrainedModel:()=>Cp,MobileNetV4ForImageClassification:()=>Gh,MobileNetV4Model:()=>Ap,MobileNetV4PreTrainedModel:()=>uu,MobileViTForImageClassification:()=>cd,MobileViTModel:()=>ud,MobileViTPreTrainedModel:()=>yl,MobileViTV2ForImageClassification:()=>bs,MobileViTV2Model:()=>dd,MobileViTV2PreTrainedModel:()=>wl,ModelOutput:()=>Qe,Moondream1ForConditionalGeneration:()=>yn,MptForCausalLM:()=>Kc,MptModel:()=>Hc,MptPreTrainedModel:()=>Go,MusicgenForCausalLM:()=>t_,MusicgenForConditionalGeneration:()=>su,MusicgenModel:()=>Vh,MusicgenPreTrainedModel:()=>ou,NomicBertModel:()=>lt,NomicBertPreTrainedModel:()=>Ye,OPTForCausalLM:()=>Qc,OPTModel:()=>Xc,OPTPreTrainedModel:()=>oa,OpenELMForCausalLM:()=>Uc,OpenELMModel:()=>Nc,OpenELMPreTrainedModel:()=>ll,OwlViTForObjectDetection:()=>pd,OwlViTModel:()=>sa,OwlViTPreTrainedModel:()=>vl,Owlv2ForObjectDetection:()=>hd,Owlv2Model:()=>fd,Owlv2PreTrainedModel:()=>bl,Phi3ForCausalLM:()=>ia,Phi3Model:()=>Wc,Phi3PreTrainedModel:()=>Vc,PhiForCausalLM:()=>fl,PhiModel:()=>jc,PhiPreTrainedModel:()=>pl,PreTrainedModel:()=>me,PretrainedMixin:()=>Un,PvtForImageClassification:()=>Zc,PvtModel:()=>Jc,PvtPreTrainedModel:()=>gl,PyAnnoteForAudioFrameClassification:()=>Zd,PyAnnoteModel:()=>Jd,PyAnnotePreTrainedModel:()=>Yd,QuestionAnsweringModelOutput:()=>Dr,Qwen2ForCausalLM:()=>dl,Qwen2Model:()=>cl,Qwen2PreTrainedModel:()=>ul,RTDetrForObjectDetection:()=>bd,RTDetrModel:()=>vd,RTDetrObjectDetectionOutput:()=>El,RTDetrPreTrainedModel:()=>Sl,ResNetForImageClassification:()=>kd,ResNetModel:()=>Ed,ResNetPreTrainedModel:()=>Il,RoFormerForMaskedLM:()=>ht,RoFormerForQuestionAnswering:()=>Ct,RoFormerForSequenceClassification:()=>bt,RoFormerForTokenClassification:()=>Ot,RoFormerModel:()=>Ge,RoFormerPreTrainedModel:()=>We,RobertaForMaskedLM:()=>Nr,RobertaForQuestionAnswering:()=>_r,RobertaForSequenceClassification:()=>Kr,RobertaForTokenClassification:()=>Ae,RobertaModel:()=>Ln,RobertaPreTrainedModel:()=>fn,SamImageSegmentationOutput:()=>fa,SamModel:()=>Nl,SamPreTrainedModel:()=>qd,SapiensForDepthEstimation:()=>Rd,SapiensForNormalEstimation:()=>Ah,SapiensForSemanticSegmentation:()=>Ld,SapiensPreTrainedModel:()=>la,SegformerForImageClassification:()=>tu,SegformerForSemanticSegmentation:()=>Mp,SegformerModel:()=>Uh,SegformerPreTrainedModel:()=>wa,Seq2SeqLMOutput:()=>mf,SequenceClassifierOutput:()=>_n,SiglipModel:()=>mc,SiglipPreTrainedModel:()=>Bi,SiglipTextModel:()=>gc,SiglipVisionModel:()=>_c,SpeechT5ForSpeechToText:()=>cp,SpeechT5ForTextToSpeech:()=>dp,SpeechT5HifiGan:()=>pp,SpeechT5Model:()=>Bh,SpeechT5PreTrainedModel:()=>_a,SqueezeBertForMaskedLM:()=>hi,SqueezeBertForQuestionAnswering:()=>Bo,SqueezeBertForSequenceClassification:()=>zi,SqueezeBertModel:()=>Zi,SqueezeBertPreTrainedModel:()=>yo,StableLmForCausalLM:()=>jh,StableLmModel:()=>xp,StableLmPreTrainedModel:()=>nu,Starcoder2ForCausalLM:()=>yp,Starcoder2Model:()=>_p,Starcoder2PreTrainedModel:()=>gp,Swin2SRForImageSuperResolution:()=>Fd,Swin2SRModel:()=>Ad,Swin2SRPreTrainedModel:()=>li,SwinForImageClassification:()=>$d,SwinModel:()=>Pd,SwinPreTrainedModel:()=>Cd,T5ForConditionalGeneration:()=>_s,T5Model:()=>gs,T5PreTrainedModel:()=>wo,TableTransformerForObjectDetection:()=>Pl,TableTransformerModel:()=>Cl,TableTransformerObjectDetectionOutput:()=>Md,TableTransformerPreTrainedModel:()=>kl,TokenClassifierOutput:()=>Mr,TrOCRForCausalLM:()=>Nh,TrOCRPreTrainedModel:()=>fp,UniSpeechForCTC:()=>tp,UniSpeechForSequenceClassification:()=>np,UniSpeechModel:()=>ep,UniSpeechPreTrainedModel:()=>ha,UniSpeechSatForAudioFrameClassification:()=>Hl,UniSpeechSatForCTC:()=>ma,UniSpeechSatForSequenceClassification:()=>ql,UniSpeechSatModel:()=>rp,UniSpeechSatPreTrainedModel:()=>xo,ViTForImageClassification:()=>Ph,ViTMAEModel:()=>ed,ViTMAEPreTrainedModel:()=>$h,ViTMSNForImageClassification:()=>nd,ViTMSNModel:()=>td,ViTMSNPreTrainedModel:()=>kn,ViTModel:()=>Yc,ViTPreTrainedModel:()=>ml,VisionEncoderDecoderModel:()=>Ha,VitMatteForImageMatting:()=>ld,VitMattePreTrainedModel:()=>ad,VitsModel:()=>eu,VitsModelOutput:()=>yf,VitsPreTrainedModel:()=>bp,Wav2Vec2BertForCTC:()=>Kl,Wav2Vec2BertForSequenceClassification:()=>Dh,Wav2Vec2BertModel:()=>ip,Wav2Vec2BertPreTrainedModel:()=>ga,Wav2Vec2ForAudioFrameClassification:()=>Qd,Wav2Vec2ForCTC:()=>Kd,Wav2Vec2ForSequenceClassification:()=>Xd,Wav2Vec2Model:()=>Wl,Wav2Vec2PreTrainedModel:()=>oo,WavLMForAudioFrameClassification:()=>Xl,WavLMForCTC:()=>ap,WavLMForSequenceClassification:()=>lp,WavLMForXVector:()=>up,WavLMModel:()=>Rh,WavLMPreTrainedModel:()=>To,WeSpeakerResNetModel:()=>Gl,WeSpeakerResNetPreTrainedModel:()=>Oh,WhisperForConditionalGeneration:()=>qa,WhisperModel:()=>Yt,WhisperPreTrainedModel:()=>ot,XLMForQuestionAnswering:()=>lr,XLMForSequenceClassification:()=>Zt,XLMForTokenClassification:()=>Ir,XLMModel:()=>mi,XLMPreTrainedModel:()=>kr,XLMRobertaForMaskedLM:()=>Ft,XLMRobertaForQuestionAnswering:()=>eo,XLMRobertaForSequenceClassification:()=>Mn,XLMRobertaForTokenClassification:()=>bo,XLMRobertaModel:()=>Nn,XLMRobertaPreTrainedModel:()=>vn,XLMWithLMHeadModel:()=>Li,XVectorOutput:()=>gf,YolosForObjectDetection:()=>Gd,YolosModel:()=>Bl,YolosObjectDetectionOutput:()=>pa,YolosPreTrainedModel:()=>Ms});var o=r("./src/configs.js"),a=r("./src/backends/onnx.js"),l=r("./src/utils/dtypes.js"),p=r("./src/utils/generic.js"),w=r("./src/utils/core.js"),_=r("./src/utils/hub.js"),y=r("./src/utils/constants.js"),T=r("./src/generation/logits_process.js"),E=r("./src/generation/configuration_utils.js"),A=r("./src/utils/tensor.js"),H=r("./src/utils/maths.js"),W=r("./src/generation/stopping_criteria.js"),Y=r("./src/generation/logits_sampler.js"),B=r("./src/env.js"),F=r("./src/models/whisper/generation_whisper.js"),O=r("./src/models/whisper/common_whisper.js");const P={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7},j=new Map,V=new Map,z=new Map;async function q(S,R,re){var Pr;const ke=((Pr=re.config)==null?void 0:Pr["transformers.js_config"])??{};let qe=re.device??ke.device;qe&&typeof qe!="string"&&(qe.hasOwnProperty(R)?qe=qe[R]:(console.warn(`device not specified for "${R}". Using the default device.`),qe=null));const Ue=qe??(B.apis.IS_NODE_ENV?"cpu":"wasm"),gt=(0,a.deviceToExecutionProviders)(Ue);let It=re.dtype??ke.dtype;typeof It!="string"&&(It&&It.hasOwnProperty(R)?It=It[R]:(It=l.DEFAULT_DEVICE_DTYPE_MAPPING[Ue]??l.DATA_TYPES.fp32,console.warn(`dtype not specified for "${R}". Using the default dtype (${It}) for this device (${Ue}).`)));const qt=It;if(l.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(qt)){if(qt===l.DATA_TYPES.fp16&&Ue==="webgpu"&&!await(0,l.isWebGpuFp16Supported)())throw new Error(`The device (${Ue}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${qt}. Should be one of: ${Object.keys(l.DATA_TYPES).join(", ")}`);const an=ke.kv_cache_dtype?typeof ke.kv_cache_dtype=="string"?ke.kv_cache_dtype:ke.kv_cache_dtype[qt]??"float32":void 0;if(an&&!["float32","float16"].includes(an))throw new Error(`Invalid kv_cache_dtype: ${an}. Should be one of: float32, float16`);const jn={dtype:qt,kv_cache_dtype:an},Vn=l.DEFAULT_DTYPE_SUFFIX_MAPPING[qt],Tn=`${re.subfolder??""}/${R}${Vn}.onnx`,dn={...re.session_options};dn.executionProviders??(dn.executionProviders=gt);const Rn=ke.free_dimension_overrides;Rn?dn.freeDimensionOverrides??(dn.freeDimensionOverrides=Rn):Ue.startsWith("webnn")&&!dn.freeDimensionOverrides&&console.warn('WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.');const Fn=(0,_.getModelFile)(S,Tn,!0,re),Sn=re.use_external_data_format??ke.use_external_data_format;let Wn=[];if(Sn&&(Sn===!0||typeof Sn=="object"&&Sn.hasOwnProperty(R)&&Sn[R]===!0)){if(B.apis.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const rr=`${R}${Vn}.onnx_data`,ur=`${re.subfolder??""}/${rr}`;Wn.push(new Promise(async(ir,jr)=>{const ao=await(0,_.getModelFile)(S,ur,!0,re);ir({path:rr,data:ao})}))}else dn.externalData!==void 0&&(Wn=dn.externalData.map(async rr=>{if(typeof rr.data=="string"){const ur=await(0,_.getModelFile)(S,rr.data,!0,re);return{...rr,data:ur}}return rr}));if(Wn.length>0&&(dn.externalData=await Promise.all(Wn)),Ue==="webgpu"){const rr=(0,o.getKeyValueShapes)(re.config,{prefix:"present"});if(Object.keys(rr).length>0&&!(0,a.isONNXProxy)()){const ur={};for(const ir in rr)ur[ir]="gpu-buffer";dn.preferredOutputLocation=ur}}return{buffer:await Fn,session_options:dn,session_config:jn}}async function L(S,R,re){return Object.fromEntries(await Promise.all(Object.keys(R).map(async ke=>{const{buffer:qe,session_options:Ue,session_config:gt}=await q(S,R[ke],re),It=await(0,a.createInferenceSession)(qe,Ue,gt);return[ke,It]})))}async function pe(S,R,re){return Object.fromEntries(await Promise.all(Object.keys(R).map(async ke=>{const qe=await(0,_.getModelJSON)(S,R[ke],!1,re);return[ke,qe]})))}function fe(S,R){const re=Object.create(null),ke=[];for(const gt of S.inputNames){const It=R[gt];if(!(It instanceof A.Tensor)){ke.push(gt);continue}re[gt]=(0,a.isONNXProxy)()?It.clone():It}if(ke.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ke.join(", ")}.`);const qe=Object.keys(R).length,Ue=S.inputNames.length;if(qe>Ue){let gt=Object.keys(R).filter(It=>!S.inputNames.includes(It));console.warn(`WARNING: Too many inputs were provided (${qe} > ${Ue}). The following inputs will be ignored: "${gt.join(", ")}".`)}return re}async function xe(S,R){const re=fe(S,R);try{const ke=Object.fromEntries(Object.entries(re).map(([Ue,gt])=>[Ue,gt.ort_tensor]));let qe=await S.run(ke);return qe=$e(qe),qe}catch(ke){throw console.error(`An error occurred during model execution: "${ke}".`),console.error("Inputs given to model:",re),ke}}function $e(S){for(let R in S)(0,a.isONNXTensor)(S[R])?S[R]=new A.Tensor(S[R]):typeof S[R]=="object"&&$e(S[R]);return S}function Ce(S){if(S instanceof A.Tensor)return S;if(S.length===0)throw Error("items must be non-empty");if(Array.isArray(S[0])){if(S.some(R=>R.length!==S[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new A.Tensor("int64",BigInt64Array.from(S.flat().map(R=>BigInt(R))),[S.length,S[0].length])}else return new A.Tensor("int64",BigInt64Array.from(S.map(R=>BigInt(R))),[1,S.length])}function tt(S){return new A.Tensor("bool",[S],[1])}async function Je(S,R){let{encoder_outputs:re,input_ids:ke,decoder_input_ids:qe,...Ue}=R;if(!re){const It=(0,w.pick)(R,S.sessions.model.inputNames);re=(await it(S,It)).last_hidden_state}return Ue.input_ids=qe,Ue.encoder_hidden_states=re,S.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Ue.encoder_attention_mask=R.attention_mask),await be(S,Ue,!0)}async function it(S,R){const re=S.sessions.model,ke=(0,w.pick)(R,re.inputNames);if(re.inputNames.includes("inputs_embeds")&&!ke.inputs_embeds){if(!R.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ke.inputs_embeds=await S.encode_text({input_ids:R.input_ids})}return re.inputNames.includes("token_type_ids")&&!ke.token_type_ids&&(ke.token_type_ids=new A.Tensor("int64",new BigInt64Array(ke.input_ids.data.length),ke.input_ids.dims)),await xe(re,ke)}async function be(S,R,re=!1){const ke=S.sessions[re?"decoder_model_merged":"model"],{past_key_values:qe,...Ue}=R;ke.inputNames.includes("use_cache_branch")&&(Ue.use_cache_branch=tt(!!qe)),ke.inputNames.includes("position_ids")&&Ue.attention_mask&&!Ue.position_ids&&(Ue.position_ids=ae(Ue,qe)),S.addPastKeyValues(Ue,qe);const gt=(0,w.pick)(Ue,ke.inputNames);return await xe(ke,gt)}async function Q(S,{input_ids:R=null,attention_mask:re=null,pixel_values:ke=null,position_ids:qe=null,inputs_embeds:Ue=null,past_key_values:gt=null,generation_config:It=null,logits_processor:qt=null,...an}){if(!Ue){if(Ue=await S.encode_text({input_ids:R}),ke&&R.dims[1]!==1){const Vn=await S.encode_image({pixel_values:ke});({inputs_embeds:Ue,attention_mask:re}=S._merge_input_ids_with_image_features({image_features:Vn,inputs_embeds:Ue,input_ids:R,attention_mask:re}))}else if(gt&&ke&&R.dims[1]===1){const Vn=R.dims[1],Tn=Object.values(gt)[0].dims.at(-2);re=(0,A.cat)([(0,A.ones)([R.dims[0],Tn]),re.slice(null,[re.dims[1]-Vn,re.dims[1]])],1)}}return await be(S,{inputs_embeds:Ue,past_key_values:gt,attention_mask:re,position_ids:qe,generation_config:It,logits_processor:qt},!0)}function ae(S,R=null){const{input_ids:re,inputs_embeds:ke,attention_mask:qe}=S,[Ue,gt]=qe.dims,It=new BigInt64Array(qe.data.length);for(let an=0;an<Ue;++an){const jn=an*gt;let Vn=BigInt(0);for(let Tn=0;Tn<gt;++Tn){const dn=jn+Tn;qe.data[dn]===0n?It[dn]=BigInt(1):(It[dn]=Vn,Vn+=qe.data[dn])}}let qt=new A.Tensor("int64",It,qe.dims);if(R){const an=-(re??ke).dims.at(1);qt=qt.slice(null,[an,null])}return qt}function ye(S,R,re,ke){if(re.past_key_values){const qe=Object.values(re.past_key_values)[0].dims.at(-2),{input_ids:Ue,attention_mask:gt}=re;if(!(gt&&gt.dims[1]>Ue.dims[1])){if(qe<Ue.dims[1])re.input_ids=Ue.slice(null,[qe,null]);else if(S.config.image_token_index!=null&&Ue.data.some(It=>It==S.config.image_token_index)){const It=S.config.num_image_tokens;if(!It)throw new Error("`num_image_tokens` is missing in the model configuration.");const qt=Ue.dims[1]-(qe-It);re.input_ids=Ue.slice(null,[-qt,null]),re.attention_mask=(0,A.ones)([1,qe+qt])}}}return re}function Pe(S,R,re,ke){return re.past_key_values&&(R=R.map(qe=>[qe.at(-1)])),{...re,decoder_input_ids:Ce(R)}}function Ze(S,...R){return S.config.is_encoder_decoder?Pe(S,...R):ye(S,...R)}class me extends p.Callable{constructor(re,ke,qe){super();Ee(this,"main_input_name","input_ids");Ee(this,"forward_params",["input_ids","attention_mask"]);this.config=re,this.sessions=ke,this.configs=qe;const Ue=z.get(this.constructor),gt=j.get(Ue);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,gt){case P.DecoderOnly:this.can_generate=!0,this._forward=be,this._prepare_inputs_for_generation=ye;break;case P.Seq2Seq:case P.Vision2Seq:case P.Musicgen:this.can_generate=!0,this._forward=Je,this._prepare_inputs_for_generation=Pe;break;case P.EncoderDecoder:this._forward=Je;break;case P.ImageTextToText:this.can_generate=!0,this._forward=Q,this._prepare_inputs_for_generation=Ze;break;default:this._forward=it;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var ke;const re=[];for(const qe of Object.values(this.sessions))(ke=qe==null?void 0:qe.handler)!=null&&ke.dispose&&re.push(qe.handler.dispose());return await Promise.all(re)}static async from_pretrained(re,{progress_callback:ke=null,config:qe=null,cache_dir:Ue=null,local_files_only:gt=!1,revision:It="main",model_file_name:qt=null,subfolder:an="onnx",device:jn=null,dtype:Vn=null,use_external_data_format:Tn=null,session_options:dn={}}={}){let Rn={progress_callback:ke,config:qe,cache_dir:Ue,local_files_only:gt,revision:It,model_file_name:qt,subfolder:an,device:jn,dtype:Vn,use_external_data_format:Tn,session_options:dn};const Fn=z.get(this),Sn=j.get(Fn);qe=Rn.config=await o.AutoConfig.from_pretrained(re,Rn);let Wn;if(Sn===P.DecoderOnly)Wn=await Promise.all([L(re,{model:Rn.model_file_name??"model"},Rn),pe(re,{generation_config:"generation_config.json"},Rn)]);else if(Sn===P.Seq2Seq||Sn===P.Vision2Seq)Wn=await Promise.all([L(re,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},Rn),pe(re,{generation_config:"generation_config.json"},Rn)]);else if(Sn===P.MaskGeneration)Wn=await Promise.all([L(re,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},Rn)]);else if(Sn===P.EncoderDecoder)Wn=await Promise.all([L(re,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},Rn)]);else if(Sn===P.ImageTextToText){const ei={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};qe.is_encoder_decoder&&(ei.model="encoder_model"),Wn=await Promise.all([L(re,ei,Rn),pe(re,{generation_config:"generation_config.json"},Rn)])}else Sn===P.Musicgen?Wn=await Promise.all([L(re,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},Rn),pe(re,{generation_config:"generation_config.json"},Rn)]):(Sn!==P.EncoderOnly&&console.warn(`Model type for '${Fn??(qe==null?void 0:qe.model_type)}' not found, assuming encoder-only architecture. Please report this at ${y.GITHUB_ISSUE_URL}.`),Wn=await Promise.all([L(re,{model:Rn.model_file_name??"model"},Rn)]));return new this(qe,...Wn)}async _call(re){return await this.forward(re)}async forward(re){return await this._forward(this,re)}get generation_config(){var re;return((re=this.configs)==null?void 0:re.generation_config)??null}_get_logits_warper(re){const ke=new T.LogitsProcessorList;return re.temperature!==null&&re.temperature!==1&&ke.push(new T.TemperatureLogitsWarper(re.temperature)),re.top_k!==null&&re.top_k!==0&&ke.push(new T.TopKLogitsWarper(re.top_k)),re.top_p!==null&&re.top_p<1&&ke.push(new T.TopPLogitsWarper(re.top_p)),ke}_get_logits_processor(re,ke,qe=null){const Ue=new T.LogitsProcessorList;if(re.repetition_penalty!==null&&re.repetition_penalty!==1&&Ue.push(new T.RepetitionPenaltyLogitsProcessor(re.repetition_penalty)),re.no_repeat_ngram_size!==null&&re.no_repeat_ngram_size>0&&Ue.push(new T.NoRepeatNGramLogitsProcessor(re.no_repeat_ngram_size)),re.bad_words_ids!==null&&Ue.push(new T.NoBadWordsLogitsProcessor(re.bad_words_ids,re.eos_token_id)),re.min_length!==null&&re.eos_token_id!==null&&re.min_length>0&&Ue.push(new T.MinLengthLogitsProcessor(re.min_length,re.eos_token_id)),re.min_new_tokens!==null&&re.eos_token_id!==null&&re.min_new_tokens>0&&Ue.push(new T.MinNewTokensLengthLogitsProcessor(ke,re.min_new_tokens,re.eos_token_id)),re.forced_bos_token_id!==null&&Ue.push(new T.ForcedBOSTokenLogitsProcessor(re.forced_bos_token_id)),re.forced_eos_token_id!==null&&Ue.push(new T.ForcedEOSTokenLogitsProcessor(re.max_length,re.forced_eos_token_id)),re.begin_suppress_tokens!==null){const gt=ke>1||re.forced_bos_token_id===null?ke:ke+1;Ue.push(new T.SuppressTokensAtBeginLogitsProcessor(re.begin_suppress_tokens,gt))}return re.guidance_scale!==null&&re.guidance_scale>1&&Ue.push(new T.ClassifierFreeGuidanceLogitsProcessor(re.guidance_scale)),qe!==null&&Ue.extend(qe),Ue}_prepare_generation_config(re,ke,qe=E.GenerationConfig){const Ue={...this.config};for(const It of["decoder","generator","text_config"])It in Ue&&Object.assign(Ue,Ue[It]);const gt=new qe(Ue);return Object.assign(gt,this.generation_config??{}),re&&Object.assign(gt,re),ke&&Object.assign(gt,(0,w.pick)(ke,Object.getOwnPropertyNames(gt))),gt}_get_stopping_criteria(re,ke=null){const qe=new W.StoppingCriteriaList;return re.max_length!==null&&qe.push(new W.MaxLengthCriteria(re.max_length,this.config.max_position_embeddings??null)),re.eos_token_id!==null&&qe.push(new W.EosTokenCriteria(re.eos_token_id)),ke&&qe.extend(ke),qe}_validate_model_class(){if(!this.can_generate){const re=[pu,qo,du,cu],ke=z.get(this.constructor),qe=new Set,Ue=this.config.model_type;for(const It of re){const qt=It.get(Ue);qt&&qe.add(qt[0])}let gt=`The current model class (${ke}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw qe.size>0&&(gt+=` Please use the following class instead: ${[...qe].join(", ")}`),Error(gt)}}prepare_inputs_for_generation(...re){return this._prepare_inputs_for_generation(this,...re)}_update_model_kwargs_for_generation({generated_input_ids:re,outputs:ke,model_inputs:qe,is_encoder_decoder:Ue}){return qe.past_key_values=this.getPastKeyValues(ke,qe.past_key_values),qe.input_ids=new A.Tensor("int64",re.flat(),[re.length,1]),Ue||(qe.attention_mask=(0,A.cat)([qe.attention_mask,(0,A.ones)([qe.attention_mask.dims[0],1])],1)),qe.position_ids=null,qe}_prepare_model_inputs({inputs:re,bos_token_id:ke,model_kwargs:qe}){const Ue=(0,w.pick)(qe,this.forward_params),gt=this.main_input_name;if(gt in Ue){if(re)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Ue[gt]=re;return{inputs_tensor:Ue[gt],model_inputs:Ue,model_input_name:gt}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:re,model_inputs:ke,model_input_name:qe,generation_config:Ue}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ke.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:It,pixel_values:qt,attention_mask:an,...jn}=ke,Vn=await this._prepare_inputs_embeds(ke);ke={...jn,...(0,w.pick)(Vn,["inputs_embeds","attention_mask"])}}let{last_hidden_state:gt}=await it(this,ke);if(Ue.guidance_scale!==null&&Ue.guidance_scale>1)gt=(0,A.cat)([gt,(0,A.full_like)(gt,0)],0),"attention_mask"in ke&&(ke.attention_mask=(0,A.cat)([ke.attention_mask,(0,A.zeros_like)(ke.attention_mask)],0));else if(ke.decoder_input_ids){const It=Ce(ke.decoder_input_ids).dims[0];if(It!==gt.dims[0]){if(gt.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${gt.dims[0]}) than the decoder inputs (${It}).`);gt=(0,A.cat)(Array.from({length:It},()=>gt),0)}}return ke.encoder_outputs=gt,ke}_prepare_decoder_input_ids_for_generation({batch_size:re,model_input_name:ke,model_kwargs:qe,decoder_start_token_id:Ue,bos_token_id:gt,generation_config:It}){let{decoder_input_ids:qt,...an}=qe;if(!(qt instanceof A.Tensor)){if(qt)Array.isArray(qt[0])||(qt=Array.from({length:re},()=>qt));else if(Ue??(Ue=gt),this.config.model_type==="musicgen")qt=Array.from({length:re*this.config.decoder.num_codebooks},()=>[Ue]);else if(Array.isArray(Ue)){if(Ue.length!==re)throw new Error(`\`decoder_start_token_id\` expcted to have length ${re} but got ${Ue.length}`);qt=Ue}else qt=Array.from({length:re},()=>[Ue]);qt=Ce(qt)}return qe.decoder_attention_mask=(0,A.ones_like)(qt),{input_ids:qt,model_inputs:an}}async generate({inputs:re=null,generation_config:ke=null,logits_processor:qe=null,stopping_criteria:Ue=null,streamer:gt=null,...It}){this._validate_model_class(),ke=this._prepare_generation_config(ke,It);let{inputs_tensor:qt,model_inputs:an,model_input_name:jn}=this._prepare_model_inputs({inputs:re,model_kwargs:It});const Vn=this.config.is_encoder_decoder;Vn&&("encoder_outputs"in an||(an=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:qt,model_inputs:an,model_input_name:jn,generation_config:ke})));let Tn;Vn?{input_ids:Tn,model_inputs:an}=this._prepare_decoder_input_ids_for_generation({batch_size:an[jn].dims.at(0),model_input_name:jn,model_kwargs:an,decoder_start_token_id:ke.decoder_start_token_id,bos_token_id:ke.bos_token_id,generation_config:ke}):Tn=an[jn];let dn=Tn.dims.at(-1);ke.max_new_tokens!==null&&(ke.max_length=dn+ke.max_new_tokens);const Rn=this._get_logits_processor(ke,dn,qe),Fn=this._get_stopping_criteria(ke,Ue),Sn=an[jn].dims.at(0),Wn=Y.LogitsSampler.getSampler(ke),ei=new Array(Sn).fill(0),Pr=Tn.tolist();gt&&gt.put(Pr);let rr,ur={};for(;;){if(an=this.prepare_inputs_for_generation(Pr,an,ke),rr=await this.forward(an),ke.output_attentions&&ke.return_dict_in_generate){const ki=this.getAttentions(rr);for(const Ho in ki)Ho in ur||(ur[Ho]=[]),ur[Ho].push(ki[Ho])}const ao=rr.logits.slice(null,-1,null),va=Rn(Pr,ao),xu=[];for(let ki=0;ki<va.dims.at(0);++ki){const Ho=va[ki],o_=await Wn(Ho);for(const[nm,rm]of o_){const wf=BigInt(nm);ei[ki]+=rm,Pr[ki].push(wf),xu.push([wf]);break}}if(gt&&gt.put(xu),Fn(Pr).every(ki=>ki))break;an=this._update_model_kwargs_for_generation({generated_input_ids:xu,outputs:rr,model_inputs:an,is_encoder_decoder:Vn})}gt&&gt.end();const ir=this.getPastKeyValues(rr,an.past_key_values,!0),jr=new A.Tensor("int64",Pr.flat(),[Pr.length,Pr[0].length]);if(ke.return_dict_in_generate)return{sequences:jr,past_key_values:ir,...ur};for(const ao of Object.values(rr))ao.location==="gpu-buffer"&&ao.dispose();return jr}getPastKeyValues(re,ke,qe=!1){const Ue=Object.create(null);for(const gt in re)if(gt.startsWith("present")){const It=gt.replace("present","past_key_values"),qt=gt.includes("encoder");if(qt&&ke?Ue[It]=ke[It]:Ue[It]=re[gt],ke&&(!qt||qe)){const an=ke[It];an.location==="gpu-buffer"&&an.dispose()}}return Ue}getAttentions(re){const ke={};for(const qe of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Ue in re)Ue.startsWith(qe)&&(qe in ke||(ke[qe]=[]),ke[qe].push(re[Ue]));return ke}addPastKeyValues(re,ke){var qe;if(ke)Object.assign(re,ke);else{const Ue=this.sessions.decoder_model_merged??this.sessions.model,gt=((qe=Ue==null?void 0:Ue.config)==null?void 0:qe.kv_cache_dtype)??"float32",It=gt==="float16"?new Uint16Array:[],qt=(0,o.getKeyValueShapes)(this.config);for(const an in qt)re[an]=new A.Tensor(gt,It,qt[an])}}async encode_image({pixel_values:re}){const ke=(await xe(this.sessions.vision_encoder,{pixel_values:re})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${ke.dims[1]}).`),this.config.num_image_tokens=ke.dims[1]),ke}async encode_text({input_ids:re}){return(await xe(this.sessions.embed_tokens,{input_ids:re})).inputs_embeds}}class Qe{}class et extends Qe{constructor({last_hidden_state:R,hidden_states:re=null,attentions:ke=null}){super(),this.last_hidden_state=R,this.hidden_states=re,this.attentions=ke}}class Ie extends me{}class rt extends Ie{}class vt extends Ie{async _call(R){return new Cr(await super._call(R))}}class nt extends Ie{async _call(R){return new _n(await super._call(R))}}class ce extends Ie{async _call(R){return new Mr(await super._call(R))}}class ze extends Ie{async _call(R){return new Dr(await super._call(R))}}class Ye extends me{}class lt extends Ye{}class We extends me{}class Ge extends We{}class ht extends We{async _call(R){return new Cr(await super._call(R))}}class bt extends We{async _call(R){return new _n(await super._call(R))}}class Ot extends We{async _call(R){return new Mr(await super._call(R))}}class Ct extends We{async _call(R){return new Dr(await super._call(R))}}class U extends me{}class se extends U{}class J extends U{async _call(R){return new Cr(await super._call(R))}}class ue extends U{async _call(R){return new _n(await super._call(R))}}class Me extends U{async _call(R){return new Mr(await super._call(R))}}class dt extends U{async _call(R){return new Dr(await super._call(R))}}class at extends me{}class Wt extends at{}class Tt extends at{async _call(R){return new Cr(await super._call(R))}}class St extends at{async _call(R){return new _n(await super._call(R))}}class Nt extends at{async _call(R){return new Mr(await super._call(R))}}class Dt extends at{async _call(R){return new Dr(await super._call(R))}}class gn extends me{}class An extends gn{}class pr extends gn{async _call(R){return new Cr(await super._call(R))}}class Xn extends gn{async _call(R){return new _n(await super._call(R))}}class mr extends gn{async _call(R){return new Mr(await super._call(R))}}class Hr extends gn{async _call(R){return new Dr(await super._call(R))}}class ft extends me{}class oe extends ft{}class Se extends ft{async _call(R){return new Cr(await super._call(R))}}class Re extends ft{async _call(R){return new _n(await super._call(R))}}class Oe extends ft{async _call(R){return new Mr(await super._call(R))}}class Ve extends ft{async _call(R){return new Dr(await super._call(R))}}class ut extends me{}class xt extends ut{}class yt extends ut{async _call(R){return new Cr(await super._call(R))}}class $t extends ut{async _call(R){return new _n(await super._call(R))}}class _t extends ut{async _call(R){return new Mr(await super._call(R))}}class Ut extends ut{async _call(R){return new Dr(await super._call(R))}}class Gt extends me{}class Rt extends Gt{}class Be extends Gt{async _call(R){return new _n(await super._call(R))}}class Ne extends Gt{async _call(R){return new Mr(await super._call(R))}}class mt extends Gt{async _call(R){return new Dr(await super._call(R))}}class Ht extends Gt{async _call(R){return new Cr(await super._call(R))}}class cn extends me{}class En extends cn{}class Qn extends cn{async _call(R){return new Cr(await super._call(R))}}class bn extends cn{async _call(R){return new _n(await super._call(R))}}class Dn extends cn{async _call(R){return new Mr(await super._call(R))}}class xn extends me{}class si extends xn{}class Zn extends xn{async _call(R){return new Cr(await super._call(R))}}class Ro extends xn{async _call(R){return new _n(await super._call(R))}}class cs extends xn{async _call(R){return new Dr(await super._call(R))}}class Ji extends me{}class ds extends Ji{}class ps extends Ji{async _call(R){return new Cr(await super._call(R))}}class fs extends Ji{async _call(R){return new _n(await super._call(R))}}class hs extends Ji{async _call(R){return new Mr(await super._call(R))}}class ms extends Ji{async _call(R){return new Dr(await super._call(R))}}class yo extends me{}class Zi extends yo{}class hi extends yo{async _call(R){return new Cr(await super._call(R))}}class zi extends yo{async _call(R){return new _n(await super._call(R))}}class Bo extends yo{async _call(R){return new Dr(await super._call(R))}}class Ei extends me{}class No extends Ei{}class Uo extends Ei{async _call(R){return new _n(await super._call(R))}}class jo extends Ei{async _call(R){return new Dr(await super._call(R))}}class nn extends Ei{async _call(R){return new Cr(await super._call(R))}}class wo extends me{constructor(){super(...arguments);Ee(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class gs extends wo{}class _s extends wo{}class Vo extends me{}class ys extends Vo{}class ws extends Vo{}class vo extends me{}class vs extends vo{}class we extends vo{}class C extends me{}class te extends C{}class le extends C{}class ve extends C{async _call(R){return new _n(await super._call(R))}}class Te extends me{}class He extends Te{}class Mt extends Te{}class At extends Te{async _call(R){return new _n(await super._call(R))}}class Pt extends Te{}class Bt extends me{}class sn extends Bt{}class zn extends Bt{}class hn extends me{}class er extends hn{}class gr extends hn{}class fn extends me{}class Ln extends fn{}class Nr extends fn{async _call(R){return new Cr(await super._call(R))}}class Kr extends fn{async _call(R){return new _n(await super._call(R))}}class Ae extends fn{async _call(R){return new Mr(await super._call(R))}}class _r extends fn{async _call(R){return new Dr(await super._call(R))}}class kr extends me{}class mi extends kr{}class Li extends kr{async _call(R){return new Cr(await super._call(R))}}class Zt extends kr{async _call(R){return new _n(await super._call(R))}}class Ir extends kr{async _call(R){return new Mr(await super._call(R))}}class lr extends kr{async _call(R){return new Dr(await super._call(R))}}class vn extends me{}class Nn extends vn{}class Ft extends vn{async _call(R){return new Cr(await super._call(R))}}class Mn extends vn{async _call(R){return new _n(await super._call(R))}}class bo extends vn{async _call(R){return new Mr(await super._call(R))}}class eo extends vn{async _call(R){return new Dr(await super._call(R))}}class Ri extends me{}class Kt extends Ri{}class na extends Ri{}class ot extends me{constructor(){super(...arguments);Ee(this,"requires_attention_mask",!1);Ee(this,"main_input_name","input_features");Ee(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Yt extends ot{}class qa extends ot{_prepare_generation_config(R,re){return super._prepare_generation_config(R,re,F.WhisperGenerationConfig)}_retrieve_init_tokens(R){const re=[R.decoder_start_token_id];let ke=R.language;const qe=R.task;if(R.is_multilingual){ke||(console.warn("No language specified - defaulting to English (en)."),ke="en");const gt=`<|${(0,O.whisper_language_to_code)(ke)}|>`;re.push(R.lang_to_id[gt]),re.push(R.task_to_id[qe??"transcribe"])}else if(ke||qe)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!R.return_timestamps&&R.no_timestamps_token_id&&re.at(-1)!==R.no_timestamps_token_id?re.push(R.no_timestamps_token_id):R.return_timestamps&&re.at(-1)===R.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),re.pop()),re.filter(Ue=>Ue!=null)}async generate({inputs:R=null,generation_config:re=null,logits_processor:ke=null,stopping_criteria:qe=null,...Ue}){re=this._prepare_generation_config(re,Ue);const gt=Ue.decoder_input_ids??this._retrieve_init_tokens(re);if(re.return_timestamps&&(ke??(ke=new T.LogitsProcessorList),ke.push(new T.WhisperTimeStampLogitsProcessor(re,gt))),re.begin_suppress_tokens&&(ke??(ke=new T.LogitsProcessorList),ke.push(new T.SuppressTokensAtBeginLogitsProcessor(re.begin_suppress_tokens,gt.length))),re.return_token_timestamps){if(!re.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");re.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),re.output_attentions=!0,re.return_dict_in_generate=!0}const It=await super.generate({inputs:R,generation_config:re,logits_processor:ke,decoder_input_ids:gt,...Ue});return re.return_token_timestamps&&(It.token_timestamps=this._extract_token_timestamps(It,re.alignment_heads,re.num_frames)),It}_extract_token_timestamps(R,re,ke=null,qe=.02){if(!R.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ke==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Ue=this.config.median_filter_width;Ue===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Ue=7);const gt=R.cross_attentions,It=Array.from({length:this.config.decoder_layers},(Fn,Sn)=>(0,A.cat)(gt.map(Wn=>Wn[Sn]),2)),qt=(0,A.stack)(re.map(([Fn,Sn])=>{if(Fn>=It.length)throw new Error(`Layer index ${Fn} is out of bounds for cross attentions (length ${It.length}).`);return ke?It[Fn].slice(null,Sn,null,[0,ke]):It[Fn].slice(null,Sn)})).transpose(1,0,2,3),[an,jn]=(0,A.std_mean)(qt,-2,0,!0),Vn=qt.clone();for(let Fn=0;Fn<Vn.dims[0];++Fn){const Sn=Vn[Fn];for(let Wn=0;Wn<Sn.dims[0];++Wn){const ei=Sn[Wn],Pr=an[Fn][Wn][0].data,rr=jn[Fn][Wn][0].data;for(let ur=0;ur<ei.dims[0];++ur){let ir=ei[ur].data;for(let jr=0;jr<ir.length;++jr)ir[jr]=(ir[jr]-rr[jr])/Pr[jr];ir.set((0,H.medianFilter)(ir,Ue))}}}const Tn=[(0,A.mean)(Vn,1)],dn=R.sequences.dims,Rn=new A.Tensor("float32",new Float32Array(dn[0]*dn[1]),dn);for(let Fn=0;Fn<dn[0];++Fn){const Sn=Tn[Fn].neg().squeeze_(0),[Wn,ei]=(0,H.dynamic_time_warping)(Sn.tolist()),Pr=Array.from({length:Wn.length-1},(ir,jr)=>Wn[jr+1]-Wn[jr]),rr=(0,w.mergeArrays)([1],Pr).map(ir=>!!ir),ur=[];for(let ir=0;ir<rr.length;++ir)rr[ir]&&ur.push(ei[ir]*qe);Rn[Fn].data.set(ur,1)}return Rn}}class Ha extends me{constructor(){super(...arguments);Ee(this,"main_input_name","pixel_values");Ee(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class dc extends me{constructor(){super(...arguments);Ee(this,"forward_params",["input_ids","pixel_values","attention_mask","position_ids","past_key_values"])}}class Wo extends dc{_merge_input_ids_with_image_features({inputs_embeds:R,image_features:re,input_ids:ke,attention_mask:qe}){const Ue=this.config.image_token_index,It=ke.tolist().map(Tn=>Tn.findIndex(dn=>dn==Ue)),qt=It.every(Tn=>Tn===-1),an=It.every(Tn=>Tn!==-1);if(!qt&&!an)throw new Error("Every input should contain either 0 or 1 image token.");if(qt)return{inputs_embeds:R,attention_mask:qe};const jn=[],Vn=[];for(let Tn=0;Tn<It.length;++Tn){const dn=It[Tn],Rn=R[Tn],Fn=re[Tn],Sn=qe[Tn];jn.push((0,A.cat)([Rn.slice([0,dn]),Fn,Rn.slice([dn+1,Rn.dims[0]])],0)),Vn.push((0,A.cat)([Sn.slice([0,dn]),(0,A.ones)([Fn.dims[0]]),Sn.slice([dn+1,Sn.dims[0]])],0))}return{inputs_embeds:(0,A.stack)(jn,0),attention_mask:(0,A.stack)(Vn,0)}}}class yn extends Wo{}class pc extends me{constructor(){super(...arguments);Ee(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);Ee(this,"main_input_name","inputs_embeds")}}class Ka extends pc{_merge_input_ids_with_image_features({inputs_embeds:R,image_features:re,input_ids:ke,attention_mask:qe}){return{inputs_embeds:(0,A.cat)([re,R],1),attention_mask:(0,A.cat)([(0,A.ones)(re.dims.slice(0,2)),qe],1)}}async _prepare_inputs_embeds({input_ids:R,pixel_values:re,inputs_embeds:ke,attention_mask:qe}){if(!R&&!re)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Ue,gt;return R&&(Ue=await this.encode_text({input_ids:R})),re&&(gt=await this.encode_image({pixel_values:re})),Ue&&gt?{inputs_embeds:ke,attention_mask:qe}=this._merge_input_ids_with_image_features({inputs_embeds:Ue,image_features:gt,input_ids:R,attention_mask:qe}):ke=Ue||gt,{inputs_embeds:ke,attention_mask:qe}}async forward({input_ids:R,pixel_values:re,attention_mask:ke,decoder_input_ids:qe,decoder_attention_mask:Ue,encoder_outputs:gt,past_key_values:It,inputs_embeds:qt,decoder_inputs_embeds:an}){if(qt||({inputs_embeds:qt,attention_mask:ke}=await this._prepare_inputs_embeds({input_ids:R,pixel_values:re,inputs_embeds:qt,attention_mask:ke})),!gt){let{last_hidden_state:Tn}=await it(this,{inputs_embeds:qt,attention_mask:ke});gt=Tn}if(!an){if(!qe)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");an=await this.encode_text({input_ids:qe})}return await be(this,{inputs_embeds:an,attention_mask:Ue,encoder_attention_mask:ke,encoder_hidden_states:gt,past_key_values:It},!0)}}class Mo extends me{}class fc extends Mo{}class Eh extends Mo{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="text_model"),super.from_pretrained(R,re)}}class Zr extends Mo{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="text_model"),super.from_pretrained(R,re)}}class kh extends Mo{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="vision_model"),super.from_pretrained(R,re)}}class hc extends Mo{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="vision_model"),super.from_pretrained(R,re)}}class Bi extends me{}class mc extends Bi{}class gc extends Bi{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="text_model"),super.from_pretrained(R,re)}}class _c extends Mo{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="vision_model"),super.from_pretrained(R,re)}}class yc extends me{}class wc extends yc{}class Xa extends me{}class vc extends Xa{}class bc extends Xa{}class Qa extends me{}class Mc extends Qa{}class gi extends Qa{}class Ya extends me{}class xc extends Ya{}class Tc extends Ya{}class Ja extends me{}class Sc extends Ja{}class Ec extends Ja{}class Za extends me{}class kc extends Za{}class Cc extends Za{}class el extends me{}class Ch extends el{}class _i extends el{}class tl extends me{}class ra extends tl{}class nl extends tl{}class ai extends me{}class Pc extends ai{}class $c extends ai{}class rl extends me{}class Ac extends rl{}class Fc extends rl{}class il extends me{}class Ic extends il{}class Oc extends il{}class ol extends me{}class Dc extends ol{}class yi extends ol{}class sl extends me{}class zc extends sl{}class Lc extends sl{}class al extends me{}class Rc extends al{}class Bc extends al{}class ll extends me{}class Nc extends ll{}class Uc extends ll{}class ul extends me{}class cl extends ul{}class dl extends ul{}class pl extends me{}class jc extends pl{}class fl extends pl{}class Vc extends me{}class Wc extends Vc{}class ia extends Vc{}class hl extends me{}class Gc extends hl{}class qc extends hl{}class Go extends me{}class Hc extends Go{}class Kc extends Go{}class oa extends me{}class Xc extends oa{}class Qc extends oa{}class ml extends me{}class Yc extends ml{}class Ph extends ml{async _call(R){return new _n(await super._call(R))}}class gl extends me{}class Jc extends gl{}class Zc extends gl{async _call(R){return new _n(await super._call(R))}}class $h extends me{}class ed extends $h{}class kn extends me{}class td extends kn{}class nd extends kn{async _call(R){return new _n(await super._call(R))}}class rd extends me{}class id extends rd{}class _l extends me{}class od extends _l{}class sd extends _l{async _call(R){return new _n(await super._call(R))}}class ad extends me{}class ld extends ad{async _call(R){return new _f(await super._call(R))}}class yl extends me{}class ud extends yl{}class cd extends yl{async _call(R){return new _n(await super._call(R))}}class wl extends me{}class dd extends wl{}class bs extends wl{async _call(R){return new _n(await super._call(R))}}class vl extends me{}class sa extends vl{}class pd extends vl{}class bl extends me{}class fd extends bl{}class hd extends bl{}class Ml extends me{}class md extends Ml{}class gd extends Ml{async _call(R){return new _n(await super._call(R))}}class aa extends me{}class _d extends aa{}class yd extends aa{async _call(R){return new Tl(await super._call(R))}}class xl extends aa{async _call(R){return new wd(await super._call(R))}}class Tl extends Qe{constructor({logits:R,pred_boxes:re}){super(),this.logits=R,this.pred_boxes=re}}class wd extends Qe{constructor({logits:R,pred_boxes:re,pred_masks:ke}){super(),this.logits=R,this.pred_boxes=re,this.pred_masks=ke}}class Sl extends me{}class vd extends Sl{}class bd extends Sl{async _call(R){return new El(await super._call(R))}}class El extends Qe{constructor({logits:R,pred_boxes:re}){super(),this.logits=R,this.pred_boxes=re}}class kl extends me{}class Cl extends kl{}class Pl extends kl{async _call(R){return new Md(await super._call(R))}}class Md extends Tl{}class $l extends me{}class xd extends $l{}class Td extends $l{async _call(R){return new _n(await super._call(R))}}class Al extends me{}class Sd extends Al{}class Fl extends Al{async _call(R){return new _n(await super._call(R))}}class Il extends me{}class Ed extends Il{}class kd extends Il{async _call(R){return new _n(await super._call(R))}}class Cd extends me{}class Pd extends Cd{}class $d extends Cd{async _call(R){return new _n(await super._call(R))}}class li extends me{}class Ad extends li{}class Fd extends li{}class Ol extends me{}class Id extends Ol{}class Od extends Ol{}class Dd extends me{}class zd extends Dd{}class la extends me{}class Ld extends la{}class Rd extends la{}class Ah extends la{}class Bd extends me{}class Nd extends Bd{}class Dl extends me{}class Ud extends Dl{}class jd extends Dl{}class zl extends me{}class Fh extends zl{}class to extends zl{}class no extends me{}class ro extends no{}class ua extends me{}class io extends ua{}class Or extends ua{async _call(R){return new _n(await super._call(R))}}class ca extends me{}class da extends ca{}class Ll extends ca{async _call(R){return new _n(await super._call(R))}}class Rl extends me{}class Vd extends Rl{}class Wd extends Rl{async _call(R){return new _n(await super._call(R))}}class Ms extends me{}class Bl extends Ms{}class Gd extends Ms{async _call(R){return new pa(await super._call(R))}}class pa extends Qe{constructor({logits:R,pred_boxes:re}){super(),this.logits=R,this.pred_boxes=re}}class qd extends me{}class Nl extends qd{async get_image_embeddings({pixel_values:R}){return await it(this,{pixel_values:R})}async forward(R){if((!R.image_embeddings||!R.image_positional_embeddings)&&(R={...R,...await this.get_image_embeddings(R)}),!R.input_labels&&R.input_points){const ke=R.input_points.dims.slice(0,-1),qe=ke.reduce((Ue,gt)=>Ue*gt,1);R.input_labels=new A.Tensor("int64",new BigInt64Array(qe).fill(1n),ke)}const re={image_embeddings:R.image_embeddings,image_positional_embeddings:R.image_positional_embeddings};return R.input_points&&(re.input_points=R.input_points),R.input_labels&&(re.input_labels=R.input_labels),R.input_boxes&&(re.input_boxes=R.input_boxes),await xe(this.sessions.prompt_encoder_mask_decoder,re)}async _call(R){return new fa(await super._call(R))}}class fa extends Qe{constructor({iou_scores:R,pred_masks:re}){super(),this.iou_scores=R,this.pred_masks=re}}class Ul extends me{}class Hd extends Ul{}class Ih extends Ul{}class jl extends me{}class Vl extends jl{}class xs extends jl{}class oo extends me{}class Wl extends oo{}class Kd extends oo{async _call(R){return new so(await super._call(R))}}class Xd extends oo{async _call(R){return new _n(await super._call(R))}}class Qd extends oo{async _call(R){return new Mr(await super._call(R))}}class Yd extends me{}class Jd extends Yd{}class Zd extends Yd{async _call(R){return new Mr(await super._call(R))}}class Oh extends me{}class Gl extends Oh{}class ha extends me{}class ep extends ha{}class tp extends ha{async _call(R){return new so(await super._call(R))}}class np extends ha{async _call(R){return new _n(await super._call(R))}}class xo extends me{}class rp extends xo{}class ma extends xo{async _call(R){return new so(await super._call(R))}}class ql extends xo{async _call(R){return new _n(await super._call(R))}}class Hl extends xo{async _call(R){return new Mr(await super._call(R))}}class ga extends me{}class ip extends ga{}class Kl extends ga{async _call(R){return new so(await super._call(R))}}class Dh extends ga{async _call(R){return new _n(await super._call(R))}}class zh extends me{}class op extends oo{}class Lh extends oo{async _call(R){return new so(await super._call(R))}}class sp extends oo{async _call(R){return new _n(await super._call(R))}}class To extends me{}class Rh extends To{}class ap extends To{async _call(R){return new so(await super._call(R))}}class lp extends To{async _call(R){return new _n(await super._call(R))}}class up extends To{async _call(R){return new gf(await super._call(R))}}class Xl extends To{async _call(R){return new Mr(await super._call(R))}}class _a extends me{}class Bh extends _a{}class cp extends _a{}class dp extends _a{async generate_speech(R,re,{threshold:ke=.5,minlenratio:qe=0,maxlenratio:Ue=20,vocoder:gt=null}={}){const It={input_ids:R},{encoder_outputs:qt,encoder_attention_mask:an}=await it(this,It),jn=qt.dims[1]/this.config.reduction_factor,Vn=Math.floor(jn*Ue),Tn=Math.floor(jn*qe),dn=this.config.num_mel_bins;let Rn=[],Fn=null,Sn=null,Wn=0;for(;;){++Wn;const rr=tt(!!Sn);let ur;Sn?ur=Sn.output_sequence_out:ur=new A.Tensor("float32",new Float32Array(dn),[1,1,dn]);let ir={use_cache_branch:rr,output_sequence:ur,encoder_attention_mask:an,speaker_embeddings:re,encoder_hidden_states:qt};this.addPastKeyValues(ir,Fn),Sn=await xe(this.sessions.decoder_model_merged,ir),Fn=this.getPastKeyValues(Sn,Fn);const{prob:jr,spectrum:ao}=Sn;if(Rn.push(ao),Wn>=Tn&&(Array.from(jr.data).filter(va=>va>=ke).length>0||Wn>=Vn))break}const ei=(0,A.cat)(Rn),{waveform:Pr}=await xe(gt.sessions.model,{spectrogram:ei});return{spectrogram:ei,waveform:Pr}}}class pp extends me{constructor(){super(...arguments);Ee(this,"main_input_name","spectrogram")}}class fp extends me{}class Nh extends fp{}class Ql extends me{}class hp extends Ql{}class mp extends Ql{}class gp extends me{}class _p extends gp{}class yp extends gp{}class Yl extends me{}class wp extends Yl{}class vp extends Yl{}class Jl extends me{}class ya extends Jl{}class Ts extends Jl{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="text_model"),super.from_pretrained(R,re)}}class Zl extends Jl{static async from_pretrained(R,re={}){return re.model_file_name??(re.model_file_name="audio_model"),super.from_pretrained(R,re)}}class bp extends me{}class eu extends bp{async _call(R){return new yf(await super._call(R))}}class wa extends me{}class Uh extends wa{}class tu extends wa{}class Mp extends wa{}class nu extends me{}class xp extends nu{}class jh extends nu{}class ru extends me{}class iu extends ru{}class Tp extends ru{async _call(R){return new _n(await super._call(R))}}class ou extends me{}class Vh extends ou{}class t_ extends ou{}class su extends me{constructor(){super(...arguments);Ee(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(re){const[ke,qe]=re.dims,Ue=this.config.decoder.num_codebooks,gt=qe-Ue;let It=0;for(let jn=0;jn<re.size;++jn){if(re.data[jn]===this.config.decoder.pad_token_id)continue;const Vn=jn%qe,Tn=Math.floor(jn/qe)%Ue,dn=Vn-Tn;dn>0&&dn<=gt&&(re.data[It++]=re.data[jn])}const qt=Math.floor(ke/Ue),an=It/(qt*Ue);return new A.Tensor(re.type,re.data.slice(0,It),[qt,Ue,an])}prepare_inputs_for_generation(re,ke,qe){let Ue=structuredClone(re);for(let It=0;It<Ue.length;++It)for(let qt=0;qt<Ue[It].length;++qt)It%this.config.decoder.num_codebooks>=qt&&(Ue[It][qt]=BigInt(this.config.decoder.pad_token_id));return qe.guidance_scale!==null&&qe.guidance_scale>1&&(Ue=Ue.concat(Ue)),super.prepare_inputs_for_generation(Ue,ke,qe)}async generate(re){const ke=await super.generate(re),qe=this._apply_and_filter_by_delay_pattern_mask(ke).unsqueeze_(0),{audio_values:Ue}=await xe(this.sessions.encodec_decode,{audio_codes:qe});return Ue}}class au extends me{}class Wh extends au{}class Sp extends au{async _call(R){return new _n(await super._call(R))}}class lu extends me{}class Ep extends lu{}class kp extends lu{async _call(R){return new _n(await super._call(R))}}class Cp extends me{}class Pp extends Cp{}class $p extends Cp{async _call(R){return new _n(await super._call(R))}}class uu extends me{}class Ap extends uu{}class Gh extends uu{async _call(R){return new _n(await super._call(R))}}class Fp extends me{}class Ip extends Fp{}class Un{static async from_pretrained(R,{progress_callback:re=null,config:ke=null,cache_dir:qe=null,local_files_only:Ue=!1,revision:gt="main",model_file_name:It=null,subfolder:qt="onnx",device:an=null,dtype:jn=null,use_external_data_format:Vn=null,session_options:Tn={}}={}){const dn={progress_callback:re,config:ke,cache_dir:qe,local_files_only:Ue,revision:gt,model_file_name:It,subfolder:qt,device:an,dtype:jn,use_external_data_format:Vn,session_options:Tn};if(dn.config=await o.AutoConfig.from_pretrained(R,dn),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const Rn of this.MODEL_CLASS_MAPPINGS){const Fn=Rn.get(dn.config.model_type);if(Fn)return await Fn[1].from_pretrained(R,dn)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${dn.config.model_type}", attempting to construct from base class.`),await me.from_pretrained(R,dn);throw Error(`Unsupported model type: ${dn.config.model_type}`)}}Ee(Un,"MODEL_CLASS_MAPPINGS",null),Ee(Un,"BASE_IF_FAIL",!1);const qh=new Map([["bert",["BertModel",rt]],["nomic_bert",["NomicBertModel",lt]],["roformer",["RoFormerModel",Ge]],["electra",["ElectraModel",Wt]],["esm",["EsmModel",En]],["convbert",["ConvBertModel",se]],["camembert",["CamembertModel",An]],["deberta",["DebertaModel",oe]],["deberta-v2",["DebertaV2Model",xt]],["mpnet",["MPNetModel",ds]],["albert",["AlbertModel",No]],["distilbert",["DistilBertModel",Rt]],["roberta",["RobertaModel",Ln]],["xlm",["XLMModel",mi]],["xlm-roberta",["XLMRobertaModel",Nn]],["clap",["ClapModel",ya]],["clip",["CLIPModel",fc]],["clipseg",["CLIPSegModel",vc]],["chinese_clip",["ChineseCLIPModel",wc]],["siglip",["SiglipModel",mc]],["mobilebert",["MobileBertModel",si]],["squeezebert",["SqueezeBertModel",Zi]],["wav2vec2",["Wav2Vec2Model",Wl]],["wav2vec2-bert",["Wav2Vec2BertModel",ip]],["unispeech",["UniSpeechModel",ep]],["unispeech-sat",["UniSpeechSatModel",rp]],["hubert",["HubertModel",op]],["wavlm",["WavLMModel",Rh]],["audio-spectrogram-transformer",["ASTModel",Kt]],["vits",["VitsModel",eu]],["pyannote",["PyAnnoteModel",Jd]],["wespeaker-resnet",["WeSpeakerResNetModel",Gl]],["detr",["DetrModel",_d]],["rt_detr",["RTDetrModel",vd]],["table-transformer",["TableTransformerModel",Cl]],["vit",["ViTModel",Yc]],["pvt",["PvtModel",Jc]],["vit_msn",["ViTMSNModel",td]],["vit_mae",["ViTMAEModel",ed]],["groupvit",["GroupViTModel",id]],["fastvit",["FastViTModel",od]],["mobilevit",["MobileViTModel",ud]],["mobilevitv2",["MobileViTV2Model",dd]],["owlvit",["OwlViTModel",sa]],["owlv2",["Owlv2Model",fd]],["beit",["BeitModel",md]],["deit",["DeiTModel",xd]],["hiera",["HieraModel",Sd]],["convnext",["ConvNextModel",io]],["convnextv2",["ConvNextV2Model",da]],["dinov2",["Dinov2Model",Vd]],["resnet",["ResNetModel",Ed]],["swin",["SwinModel",Pd]],["swin2sr",["Swin2SRModel",Ad]],["donut-swin",["DonutSwinModel",ro]],["yolos",["YolosModel",Bl]],["dpt",["DPTModel",Id]],["glpn",["GLPNModel",Fh]],["hifigan",["SpeechT5HifiGan",pp]],["efficientnet",["EfficientNetModel",iu]],["decision_transformer",["DecisionTransformerModel",Ip]],["mobilenet_v1",["MobileNetV1Model",Wh]],["mobilenet_v2",["MobileNetV2Model",Ep]],["mobilenet_v3",["MobileNetV3Model",Pp]],["mobilenet_v4",["MobileNetV4Model",Ap]],["maskformer",["MaskFormerModel",Ud]]]),n_=new Map([["t5",["T5Model",gs]],["longt5",["LongT5Model",ys]],["mt5",["MT5Model",vs]],["bart",["BartModel",te]],["mbart",["MBartModel",He]],["marian",["MarianModel",Hd]],["whisper",["WhisperModel",Yt]],["m2m_100",["M2M100Model",Vl]],["blenderbot",["BlenderbotModel",sn]],["blenderbot-small",["BlenderbotSmallModel",er]]]),Hh=new Map([["bloom",["BloomModel",Gc]],["jais",["JAISModel",xc]],["gpt2",["GPT2Model",Mc]],["gptj",["GPTJModel",Ch]],["gpt_bigcode",["GPTBigCodeModel",ra]],["gpt_neo",["GPTNeoModel",Sc]],["gpt_neox",["GPTNeoXModel",kc]],["codegen",["CodeGenModel",Pc]],["llama",["LlamaModel",Ac]],["granite",["GraniteModel",Ic]],["cohere",["CohereModel",Dc]],["gemma",["GemmaModel",zc]],["gemma2",["Gemma2Model",Rc]],["openelm",["OpenELMModel",Nc]],["qwen2",["Qwen2Model",cl]],["phi",["PhiModel",jc]],["phi3",["Phi3Model",Wc]],["mpt",["MptModel",Hc]],["opt",["OPTModel",Xc]],["mistral",["MistralModel",hp]],["starcoder2",["Starcoder2Model",_p]],["falcon",["FalconModel",wp]],["stablelm",["StableLmModel",xp]]]),cu=new Map([["speecht5",["SpeechT5ForSpeechToText",cp]],["whisper",["WhisperForConditionalGeneration",qa]]]),Op=new Map([["speecht5",["SpeechT5ForTextToSpeech",dp]]]),Dp=new Map([["vits",["VitsModel",eu]],["musicgen",["MusicgenForConditionalGeneration",su]]]),Kh=new Map([["bert",["BertForSequenceClassification",nt]],["roformer",["RoFormerForSequenceClassification",bt]],["electra",["ElectraForSequenceClassification",St]],["esm",["EsmForSequenceClassification",bn]],["convbert",["ConvBertForSequenceClassification",ue]],["camembert",["CamembertForSequenceClassification",Xn]],["deberta",["DebertaForSequenceClassification",Re]],["deberta-v2",["DebertaV2ForSequenceClassification",$t]],["mpnet",["MPNetForSequenceClassification",fs]],["albert",["AlbertForSequenceClassification",Uo]],["distilbert",["DistilBertForSequenceClassification",Be]],["roberta",["RobertaForSequenceClassification",Kr]],["xlm",["XLMForSequenceClassification",Zt]],["xlm-roberta",["XLMRobertaForSequenceClassification",Mn]],["bart",["BartForSequenceClassification",ve]],["mbart",["MBartForSequenceClassification",At]],["mobilebert",["MobileBertForSequenceClassification",Ro]],["squeezebert",["SqueezeBertForSequenceClassification",zi]]]),Ur=new Map([["bert",["BertForTokenClassification",ce]],["roformer",["RoFormerForTokenClassification",Ot]],["electra",["ElectraForTokenClassification",Nt]],["esm",["EsmForTokenClassification",Dn]],["convbert",["ConvBertForTokenClassification",Me]],["camembert",["CamembertForTokenClassification",mr]],["deberta",["DebertaForTokenClassification",Oe]],["deberta-v2",["DebertaV2ForTokenClassification",_t]],["mpnet",["MPNetForTokenClassification",hs]],["distilbert",["DistilBertForTokenClassification",Ne]],["roberta",["RobertaForTokenClassification",Ae]],["xlm",["XLMForTokenClassification",Ir]],["xlm-roberta",["XLMRobertaForTokenClassification",bo]]]),du=new Map([["t5",["T5ForConditionalGeneration",_s]],["longt5",["LongT5ForConditionalGeneration",ws]],["mt5",["MT5ForConditionalGeneration",we]],["bart",["BartForConditionalGeneration",le]],["mbart",["MBartForConditionalGeneration",Mt]],["marian",["MarianMTModel",Ih]],["m2m_100",["M2M100ForConditionalGeneration",xs]],["blenderbot",["BlenderbotForConditionalGeneration",zn]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",gr]]]),pu=new Map([["bloom",["BloomForCausalLM",qc]],["gpt2",["GPT2LMHeadModel",gi]],["jais",["JAISLMHeadModel",Tc]],["gptj",["GPTJForCausalLM",_i]],["gpt_bigcode",["GPTBigCodeForCausalLM",nl]],["gpt_neo",["GPTNeoForCausalLM",Ec]],["gpt_neox",["GPTNeoXForCausalLM",Cc]],["codegen",["CodeGenForCausalLM",$c]],["llama",["LlamaForCausalLM",Fc]],["granite",["GraniteForCausalLM",Oc]],["cohere",["CohereForCausalLM",yi]],["gemma",["GemmaForCausalLM",Lc]],["gemma2",["Gemma2ForCausalLM",Bc]],["openelm",["OpenELMForCausalLM",Uc]],["qwen2",["Qwen2ForCausalLM",dl]],["phi",["PhiForCausalLM",fl]],["phi3",["Phi3ForCausalLM",ia]],["mpt",["MptForCausalLM",Kc]],["opt",["OPTForCausalLM",Qc]],["mbart",["MBartForCausalLM",Pt]],["mistral",["MistralForCausalLM",mp]],["starcoder2",["Starcoder2ForCausalLM",yp]],["falcon",["FalconForCausalLM",vp]],["trocr",["TrOCRForCausalLM",Nh]],["stablelm",["StableLmForCausalLM",jh]]]),fu=new Map([["bert",["BertForMaskedLM",vt]],["roformer",["RoFormerForMaskedLM",ht]],["electra",["ElectraForMaskedLM",Tt]],["esm",["EsmForMaskedLM",Qn]],["convbert",["ConvBertForMaskedLM",J]],["camembert",["CamembertForMaskedLM",pr]],["deberta",["DebertaForMaskedLM",Se]],["deberta-v2",["DebertaV2ForMaskedLM",yt]],["mpnet",["MPNetForMaskedLM",ps]],["albert",["AlbertForMaskedLM",nn]],["distilbert",["DistilBertForMaskedLM",Ht]],["roberta",["RobertaForMaskedLM",Nr]],["xlm",["XLMWithLMHeadModel",Li]],["xlm-roberta",["XLMRobertaForMaskedLM",Ft]],["mobilebert",["MobileBertForMaskedLM",Zn]],["squeezebert",["SqueezeBertForMaskedLM",hi]]]),zp=new Map([["bert",["BertForQuestionAnswering",ze]],["roformer",["RoFormerForQuestionAnswering",Ct]],["electra",["ElectraForQuestionAnswering",Dt]],["convbert",["ConvBertForQuestionAnswering",dt]],["camembert",["CamembertForQuestionAnswering",Hr]],["deberta",["DebertaForQuestionAnswering",Ve]],["deberta-v2",["DebertaV2ForQuestionAnswering",Ut]],["mpnet",["MPNetForQuestionAnswering",ms]],["albert",["AlbertForQuestionAnswering",jo]],["distilbert",["DistilBertForQuestionAnswering",mt]],["roberta",["RobertaForQuestionAnswering",_r]],["xlm",["XLMForQuestionAnswering",lr]],["xlm-roberta",["XLMRobertaForQuestionAnswering",eo]],["mobilebert",["MobileBertForQuestionAnswering",cs]],["squeezebert",["SqueezeBertForQuestionAnswering",Bo]]]),qo=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Ha]]]),Xh=new Map([["llava",["LlavaForConditionalGeneration",Wo]],["moondream1",["Moondream1ForConditionalGeneration",yn]],["florence2",["Florence2ForConditionalGeneration",Ka]]]),Qh=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Ha]]]),Lp=new Map([["vit",["ViTForImageClassification",Ph]],["pvt",["PvtForImageClassification",Zc]],["vit_msn",["ViTMSNForImageClassification",nd]],["fastvit",["FastViTForImageClassification",sd]],["mobilevit",["MobileViTForImageClassification",cd]],["mobilevitv2",["MobileViTV2ForImageClassification",bs]],["beit",["BeitForImageClassification",gd]],["deit",["DeiTForImageClassification",Td]],["hiera",["HieraForImageClassification",Fl]],["convnext",["ConvNextForImageClassification",Or]],["convnextv2",["ConvNextV2ForImageClassification",Ll]],["dinov2",["Dinov2ForImageClassification",Wd]],["resnet",["ResNetForImageClassification",kd]],["swin",["SwinForImageClassification",$d]],["segformer",["SegformerForImageClassification",tu]],["efficientnet",["EfficientNetForImageClassification",Tp]],["mobilenet_v1",["MobileNetV1ForImageClassification",Sp]],["mobilenet_v2",["MobileNetV2ForImageClassification",kp]],["mobilenet_v3",["MobileNetV3ForImageClassification",$p]],["mobilenet_v4",["MobileNetV4ForImageClassification",Gh]]]),Rp=new Map([["detr",["DetrForObjectDetection",yd]],["rt_detr",["RTDetrForObjectDetection",bd]],["table-transformer",["TableTransformerForObjectDetection",Pl]],["yolos",["YolosForObjectDetection",Gd]]]),Bp=new Map([["owlvit",["OwlViTForObjectDetection",pd]],["owlv2",["Owlv2ForObjectDetection",hd]]]),Np=new Map([["detr",["DetrForSegmentation",xl]],["clipseg",["CLIPSegForImageSegmentation",bc]]]),hu=new Map([["segformer",["SegformerForSemanticSegmentation",Mp]],["sapiens",["SapiensForSemanticSegmentation",Ld]]]),Up=new Map([["detr",["DetrForSegmentation",xl]],["maskformer",["MaskFormerForInstanceSegmentation",jd]]]),jp=new Map([["sam",["SamModel",Nl]]]),Vp=new Map([["wav2vec2",["Wav2Vec2ForCTC",Kd]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Kl]],["unispeech",["UniSpeechForCTC",tp]],["unispeech-sat",["UniSpeechSatForCTC",ma]],["wavlm",["WavLMForCTC",ap]],["hubert",["HubertForCTC",Lh]]]),Wp=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Xd]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Dh]],["unispeech",["UniSpeechForSequenceClassification",np]],["unispeech-sat",["UniSpeechSatForSequenceClassification",ql]],["wavlm",["WavLMForSequenceClassification",lp]],["hubert",["HubertForSequenceClassification",sp]],["audio-spectrogram-transformer",["ASTForAudioClassification",na]]]),Gp=new Map([["wavlm",["WavLMForXVector",up]]]),mu=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",Hl]],["wavlm",["WavLMForAudioFrameClassification",Xl]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Qd]],["pyannote",["PyAnnoteForAudioFrameClassification",Zd]]]),qp=new Map([["vitmatte",["VitMatteForImageMatting",ld]]]),Yh=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Fd]]]),gu=new Map([["dpt",["DPTForDepthEstimation",Od]],["depth_anything",["DepthAnythingForDepthEstimation",zd]],["glpn",["GLPNForDepthEstimation",to]],["sapiens",["SapiensForDepthEstimation",Rd]],["depth_pro",["DepthProForDepthEstimation",Nd]]]),Hp=new Map([["sapiens",["SapiensForNormalEstimation",Ah]]]),Kp=new Map([["clip",["CLIPVisionModelWithProjection",hc]],["siglip",["SiglipVisionModel",_c]]]),Xp=[[qh,P.EncoderOnly],[n_,P.EncoderDecoder],[Hh,P.DecoderOnly],[Kh,P.EncoderOnly],[Ur,P.EncoderOnly],[du,P.Seq2Seq],[cu,P.Seq2Seq],[pu,P.DecoderOnly],[fu,P.EncoderOnly],[zp,P.EncoderOnly],[qo,P.Vision2Seq],[Xh,P.ImageTextToText],[Lp,P.EncoderOnly],[Np,P.EncoderOnly],[Up,P.EncoderOnly],[hu,P.EncoderOnly],[qp,P.EncoderOnly],[Yh,P.EncoderOnly],[gu,P.EncoderOnly],[Hp,P.EncoderOnly],[Rp,P.EncoderOnly],[Bp,P.EncoderOnly],[jp,P.MaskGeneration],[Vp,P.EncoderOnly],[Wp,P.EncoderOnly],[Op,P.Seq2Seq],[Dp,P.EncoderOnly],[Gp,P.EncoderOnly],[mu,P.EncoderOnly],[Kp,P.EncoderOnly]];for(const[S,R]of Xp)for(const[re,ke]of S.values())j.set(re,R),z.set(ke,re),V.set(re,ke);const r_=[["MusicgenForConditionalGeneration",su,P.Musicgen],["CLIPTextModelWithProjection",Zr,P.EncoderOnly],["SiglipTextModel",gc,P.EncoderOnly],["ClapTextModelWithProjection",Ts,P.EncoderOnly],["ClapAudioModelWithProjection",Zl,P.EncoderOnly]];for(const[S,R,re]of r_)j.set(S,re),z.set(R,S),V.set(S,R);class _u extends Un{}Ee(_u,"MODEL_CLASS_MAPPINGS",Xp.map(R=>R[0])),Ee(_u,"BASE_IF_FAIL",!0);class Qp extends Un{}Ee(Qp,"MODEL_CLASS_MAPPINGS",[Kh]);class Yp extends Un{}Ee(Yp,"MODEL_CLASS_MAPPINGS",[Ur]);class Jh extends Un{}Ee(Jh,"MODEL_CLASS_MAPPINGS",[du]);class Jp extends Un{}Ee(Jp,"MODEL_CLASS_MAPPINGS",[cu]);class Zp extends Un{}Ee(Zp,"MODEL_CLASS_MAPPINGS",[Op]);class ef extends Un{}Ee(ef,"MODEL_CLASS_MAPPINGS",[Dp]);class tf extends Un{}Ee(tf,"MODEL_CLASS_MAPPINGS",[pu]);class nf extends Un{}Ee(nf,"MODEL_CLASS_MAPPINGS",[fu]);class Zh extends Un{}Ee(Zh,"MODEL_CLASS_MAPPINGS",[zp]);class rf extends Un{}Ee(rf,"MODEL_CLASS_MAPPINGS",[qo]);class of extends Un{}Ee(of,"MODEL_CLASS_MAPPINGS",[Lp]);class sf extends Un{}Ee(sf,"MODEL_CLASS_MAPPINGS",[Np]);class af extends Un{}Ee(af,"MODEL_CLASS_MAPPINGS",[hu]);class lf extends Un{}Ee(lf,"MODEL_CLASS_MAPPINGS",[Up]);class uf extends Un{}Ee(uf,"MODEL_CLASS_MAPPINGS",[Rp]);class cf extends Un{}Ee(cf,"MODEL_CLASS_MAPPINGS",[Bp]);class df extends Un{}Ee(df,"MODEL_CLASS_MAPPINGS",[jp]);class pf extends Un{}Ee(pf,"MODEL_CLASS_MAPPINGS",[Vp]);class em extends Un{}Ee(em,"MODEL_CLASS_MAPPINGS",[Wp]);class Ss extends Un{}Ee(Ss,"MODEL_CLASS_MAPPINGS",[Gp]);class yu extends Un{}Ee(yu,"MODEL_CLASS_MAPPINGS",[mu]);class wu extends Un{}Ee(wu,"MODEL_CLASS_MAPPINGS",[Qh]);class vu extends Un{}Ee(vu,"MODEL_CLASS_MAPPINGS",[qp]);class bu extends Un{}Ee(bu,"MODEL_CLASS_MAPPINGS",[Yh]);class ff extends Un{}Ee(ff,"MODEL_CLASS_MAPPINGS",[gu]);class hf extends Un{}Ee(hf,"MODEL_CLASS_MAPPINGS",[Hp]);class Mu extends Un{}Ee(Mu,"MODEL_CLASS_MAPPINGS",[Kp]);class mf extends Qe{constructor({logits:R,past_key_values:re,encoder_outputs:ke,decoder_attentions:qe=null,cross_attentions:Ue=null}){super(),this.logits=R,this.past_key_values=re,this.encoder_outputs=ke,this.decoder_attentions=qe,this.cross_attentions=Ue}}class _n extends Qe{constructor({logits:R}){super(),this.logits=R}}class gf extends Qe{constructor({logits:R,embeddings:re}){super(),this.logits=R,this.embeddings=re}}class Mr extends Qe{constructor({logits:R}){super(),this.logits=R}}class Cr extends Qe{constructor({logits:R}){super(),this.logits=R}}class Dr extends Qe{constructor({start_logits:R,end_logits:re}){super(),this.start_logits=R,this.end_logits=re}}class so extends Qe{constructor({logits:R}){super(),this.logits=R}}class tm extends Qe{constructor({logits:R,past_key_values:re}){super(),this.logits=R,this.past_key_values=re}}class _f extends Qe{constructor({alphas:R}){super(),this.alphas=R}}class yf extends Qe{constructor({waveform:R,spectrogram:re}){super(),this.waveform=R,this.spectrogram=re}}},"./src/models/whisper/common_whisper.js":(e,t,r)=>{r.r(t),r.d(t,{WHISPER_LANGUAGE_MAPPING:()=>a,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>l,whisper_language_to_code:()=>p});const o=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],a=new Map(o),l=new Map([...o.map(([w,_])=>[_,w]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function p(w){w=w.toLowerCase();let _=l.get(w);if(_===void 0)if(a.has(w))_=w;else{const T=w.length===2?a.keys():a.values();throw new Error(`Language "${w}" is not supported. Must be one of: ${JSON.stringify(T)}`)}return _}},"./src/models/whisper/generation_whisper.js":(e,t,r)=>{r.r(t),r.d(t,{WhisperGenerationConfig:()=>a});var o=r("./src/generation/configuration_utils.js");class a extends o.GenerationConfig{constructor(){super(...arguments);Ee(this,"return_timestamps",null);Ee(this,"return_token_timestamps",null);Ee(this,"num_frames",null);Ee(this,"alignment_heads",null);Ee(this,"task",null);Ee(this,"language",null);Ee(this,"no_timestamps_token_id",null);Ee(this,"prompt_ids",null);Ee(this,"is_multilingual",null);Ee(this,"lang_to_id",null);Ee(this,"task_to_id",null);Ee(this,"max_initial_timestamp_index",1)}}},"./src/ops/registry.js":(e,t,r)=>{r.r(t),r.d(t,{TensorOpRegistry:()=>p});var o=r("./src/backends/onnx.js"),a=r("./src/utils/tensor.js");const l=async(w,_,y)=>{const T=await(0,o.createInferenceSession)(new Uint8Array(w),_);return async E=>{const A=Object.fromEntries(Object.entries(E).map(([W,Y])=>[W,Y.ort_tensor])),H=await T.run(A);return Array.isArray(y)?y.map(W=>new a.Tensor(H[W])):new a.Tensor(H[y])}};class p{static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=l([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=l([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=l([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=l([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=l([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=l([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}}Ee(p,"session_options",{})},"./src/pipelines.js":(e,t,r)=>{r.r(t),r.d(t,{AudioClassificationPipeline:()=>$e,AutomaticSpeechRecognitionPipeline:()=>tt,DepthEstimationPipeline:()=>Qe,DocumentQuestionAnsweringPipeline:()=>Pe,FeatureExtractionPipeline:()=>fe,FillMaskPipeline:()=>P,ImageClassificationPipeline:()=>it,ImageFeatureExtractionPipeline:()=>xe,ImageSegmentationPipeline:()=>be,ImageToImagePipeline:()=>me,ImageToTextPipeline:()=>Je,ObjectDetectionPipeline:()=>ae,Pipeline:()=>Y,QuestionAnsweringPipeline:()=>O,SummarizationPipeline:()=>V,Text2TextGenerationPipeline:()=>j,TextClassificationPipeline:()=>B,TextGenerationPipeline:()=>L,TextToAudioPipeline:()=>Ze,TokenClassificationPipeline:()=>F,TranslationPipeline:()=>z,ZeroShotAudioClassificationPipeline:()=>Ce,ZeroShotClassificationPipeline:()=>pe,ZeroShotImageClassificationPipeline:()=>Q,ZeroShotObjectDetectionPipeline:()=>ye,pipeline:()=>rt});var o=r("./src/tokenizers.js"),a=r("./src/models.js"),l=r("./src/processors.js"),p=r("./src/utils/generic.js"),w=r("./src/utils/core.js"),_=r("./src/utils/maths.js"),y=r("./src/utils/audio.js"),T=r("./src/utils/tensor.js"),E=r("./src/utils/image.js");async function A(nt){return Array.isArray(nt)||(nt=[nt]),await Promise.all(nt.map(ce=>E.RawImage.read(ce)))}async function H(nt,ce){return Array.isArray(nt)||(nt=[nt]),await Promise.all(nt.map(ze=>typeof ze=="string"||ze instanceof URL?(0,y.read_audio)(ze,ce):ze instanceof Float64Array?new Float32Array(ze):ze))}function W(nt,ce){ce&&(nt=nt.map(Ge=>Ge|0));const[ze,Ye,lt,We]=nt;return{xmin:ze,ymin:Ye,xmax:lt,ymax:We}}class Y extends p.Callable{constructor({task:ce,model:ze,tokenizer:Ye=null,processor:lt=null}){super(),this.task=ce,this.model=ze,this.tokenizer=Ye,this.processor=lt}async dispose(){await this.model.dispose()}}class B extends Y{constructor(ce){super(ce)}async _call(ce,{top_k:ze=1}={}){const Ye=this.tokenizer(ce,{padding:!0,truncation:!0}),lt=await this.model(Ye),We=this.model.config.problem_type==="multi_label_classification"?bt=>bt.sigmoid():bt=>new T.Tensor("float32",(0,_.softmax)(bt.data),bt.dims),Ge=this.model.config.id2label,ht=[];for(const bt of lt.logits){const Ot=We(bt),Ct=await(0,T.topk)(Ot,ze),U=Ct[0].tolist(),J=Ct[1].tolist().map((ue,Me)=>({label:Ge?Ge[ue]:`LABEL_${ue}`,score:U[Me]}));ze===1?ht.push(...J):ht.push(J)}return Array.isArray(ce)||ze===1?ht:ht[0]}}class F extends Y{constructor(ce){super(ce)}async _call(ce,{ignore_labels:ze=["O"]}={}){const Ye=Array.isArray(ce),lt=this.tokenizer(Ye?ce:[ce],{padding:!0,truncation:!0}),Ge=(await this.model(lt)).logits,ht=this.model.config.id2label,bt=[];for(let Ot=0;Ot<Ge.dims[0];++Ot){const Ct=lt.input_ids[Ot],U=Ge[Ot],se=[];for(let J=0;J<U.dims[0];++J){const ue=U[J],Me=(0,_.max)(ue.data)[1],dt=ht?ht[Me]:`LABEL_${Me}`;if(ze.includes(dt))continue;const at=this.tokenizer.decode([Ct[J].item()],{skip_special_tokens:!0});if(at==="")continue;const Wt=(0,_.softmax)(ue.data);se.push({entity:dt,score:Wt[Me],index:J,word:at})}bt.push(se)}return Ye?bt:bt[0]}}class O extends Y{constructor(ce){super(ce)}async _call(ce,ze,{top_k:Ye=1}={}){const lt=this.tokenizer(ce,{text_pair:ze,padding:!0,truncation:!0}),{start_logits:We,end_logits:Ge}=await this.model(lt),ht=lt.input_ids.tolist(),bt=lt.attention_mask.tolist(),Ot=this.tokenizer.all_special_ids,Ct=[];for(let U=0;U<We.dims[0];++U){const se=ht[U],J=se.findIndex(Tt=>Tt==this.tokenizer.sep_token_id);bt[U].map((Tt,St)=>Tt==1&&(St===0||St>J&&Ot.findIndex(Nt=>Nt==se[St])===-1));const ue=We[U].tolist(),Me=Ge[U].tolist();for(let Tt=1;Tt<ue.length;++Tt)(bt[U]==0||Tt<=J||Ot.findIndex(St=>St==se[Tt])!==-1)&&(ue[Tt]=-1/0,Me[Tt]=-1/0);const dt=(0,_.softmax)(ue).map((Tt,St)=>[Tt,St]),at=(0,_.softmax)(Me).map((Tt,St)=>[Tt,St]);dt[0][0]=0,at[0][0]=0;const Wt=(0,w.product)(dt,at).filter(Tt=>Tt[0][1]<=Tt[1][1]).map(Tt=>[Tt[0][1],Tt[1][1],Tt[0][0]*Tt[1][0]]).sort((Tt,St)=>St[2]-Tt[2]);for(let Tt=0;Tt<Math.min(Wt.length,Ye);++Tt){const[St,Nt,Dt]=Wt[Tt],gn=se.slice(St,Nt+1),An=this.tokenizer.decode(gn,{skip_special_tokens:!0});Ct.push({answer:An,score:Dt})}}return Ye===1?Ct[0]:Ct}}class P extends Y{constructor(ce){super(ce)}async _call(ce,{top_k:ze=5}={}){const Ye=this.tokenizer(ce,{padding:!0,truncation:!0}),{logits:lt}=await this.model(Ye),We=[],Ge=Ye.input_ids.tolist();for(let ht=0;ht<Ge.length;++ht){const bt=Ge[ht],Ot=bt.findIndex(ue=>ue==this.tokenizer.mask_token_id);if(Ot===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const Ct=lt[ht][Ot],U=await(0,T.topk)(new T.Tensor("float32",(0,_.softmax)(Ct.data),Ct.dims),ze),se=U[0].tolist(),J=U[1].tolist();We.push(J.map((ue,Me)=>{const dt=bt.slice();return dt[Ot]=ue,{score:se[Me],token:Number(ue),token_str:this.tokenizer.model.vocab[ue],sequence:this.tokenizer.decode(dt,{skip_special_tokens:!0})}}))}return Array.isArray(ce)?We:We[0]}}class j extends Y{constructor(ze){super(ze);Ee(this,"_key","generated_text")}async _call(ze,Ye={}){Array.isArray(ze)||(ze=[ze]),this.model.config.prefix&&(ze=ze.map(Ot=>this.model.config.prefix+Ot));const lt=this.model.config.task_specific_params;lt&&lt[this.task]&&lt[this.task].prefix&&(ze=ze.map(Ot=>lt[this.task].prefix+Ot));const We=this.tokenizer,Ge={padding:!0,truncation:!0};let ht;this instanceof z&&"_build_translation_inputs"in We?ht=We._build_translation_inputs(ze,Ge,Ye):ht=We(ze,Ge);const bt=await this.model.generate({...ht,...Ye});return We.batch_decode(bt,{skip_special_tokens:!0}).map(Ot=>({[this._key]:Ot}))}}class V extends j{constructor(ze){super(ze);Ee(this,"_key","summary_text")}}class z extends j{constructor(ze){super(ze);Ee(this,"_key","translation_text")}}function q(nt){return Array.isArray(nt)&&nt.every(ce=>"role"in ce&&"content"in ce)}class L extends Y{constructor(ce){super(ce)}async _call(ce,ze={}){let Ye=!1,lt=!1,We;if(typeof ce=="string")We=ce=[ce];else if(Array.isArray(ce)&&ce.every(J=>typeof J=="string"))Ye=!0,We=ce;else{if(q(ce))ce=[ce];else if(Array.isArray(ce)&&ce.every(q))Ye=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");lt=!0,We=ce.map(J=>this.tokenizer.apply_chat_template(J,{tokenize:!1,add_generation_prompt:!0}))}const Ge=ze.add_special_tokens??!1,ht=lt?!1:ze.return_full_text??!0;this.tokenizer.padding_side="left";const bt=this.tokenizer(We,{add_special_tokens:Ge,padding:!0,truncation:!0}),Ot=await this.model.generate({...bt,...ze}),Ct=this.tokenizer.batch_decode(Ot,{skip_special_tokens:!0});let U;!ht&&bt.input_ids.dims.at(-1)>0&&(U=this.tokenizer.batch_decode(bt.input_ids,{skip_special_tokens:!0}).map(J=>J.length));const se=Array.from({length:ce.length},J=>[]);for(let J=0;J<Ct.length;++J){const ue=Math.floor(J/Ot.dims[0]*ce.length);U&&(Ct[J]=Ct[J].slice(U[ue])),se[ue].push({generated_text:lt?[...ce[ue],{role:"assistant",content:Ct[J]}]:Ct[J]})}return!Ye&&se.length===1?se[0]:se}}class pe extends Y{constructor(ce){super(ce),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([ze,Ye])=>[ze.toLowerCase(),Ye])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(ce,ze,{hypothesis_template:Ye="This example is {}.",multi_label:lt=!1}={}){const We=Array.isArray(ce);We||(ce=[ce]),Array.isArray(ze)||(ze=[ze]);const Ge=ze.map(Ot=>Ye.replace("{}",Ot)),ht=lt||ze.length===1,bt=[];for(const Ot of ce){const Ct=[];for(const J of Ge){const ue=this.tokenizer(Ot,{text_pair:J,padding:!0,truncation:!0}),Me=await this.model(ue);ht?Ct.push([Me.logits.data[this.contradiction_id],Me.logits.data[this.entailment_id]]):Ct.push(Me.logits.data[this.entailment_id])}const se=(ht?Ct.map(J=>(0,_.softmax)(J)[1]):(0,_.softmax)(Ct)).map((J,ue)=>[J,ue]).sort((J,ue)=>ue[0]-J[0]);bt.push({sequence:Ot,labels:se.map(J=>ze[J[1]]),scores:se.map(J=>J[0])})}return We?bt:bt[0]}}class fe extends Y{constructor(ce){super(ce)}async _call(ce,{pooling:ze="none",normalize:Ye=!1,quantize:lt=!1,precision:We="binary"}={}){const Ge=this.tokenizer(ce,{padding:!0,truncation:!0}),ht=await this.model(Ge);let bt=ht.last_hidden_state??ht.logits??ht.token_embeddings;if(ze!=="none")if(ze==="mean")bt=(0,T.mean_pooling)(bt,Ge.attention_mask);else if(ze==="cls")bt=bt.slice(null,0);else throw Error(`Pooling method '${ze}' not supported.`);return Ye&&(bt=bt.normalize(2,-1)),lt&&(bt=(0,T.quantize_embeddings)(bt,We)),bt}}class xe extends Y{constructor(ce){super(ce)}async _call(ce,{pool:ze=null}={}){const Ye=await A(ce),{pixel_values:lt}=await this.processor(Ye),We=await this.model({pixel_values:lt});let Ge;if(ze){if(!("pooler_output"in We))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Ge=We.pooler_output}else Ge=We.last_hidden_state??We.logits??We.image_embeds;return Ge}}class $e extends Y{constructor(ce){super(ce)}async _call(ce,{top_k:ze=5}={}){const Ye=this.processor.feature_extractor.config.sampling_rate,lt=await H(ce,Ye),We=this.model.config.id2label,Ge=[];for(const ht of lt){const bt=await this.processor(ht),Ct=(await this.model(bt)).logits[0],U=await(0,T.topk)(new T.Tensor("float32",(0,_.softmax)(Ct.data),Ct.dims),ze),se=U[0].tolist(),ue=U[1].tolist().map((Me,dt)=>({label:We?We[Me]:`LABEL_${Me}`,score:se[dt]}));Ge.push(ue)}return Array.isArray(ce)?Ge:Ge[0]}}class Ce extends Y{constructor(ce){super(ce)}async _call(ce,ze,{hypothesis_template:Ye="This is a sound of {}."}={}){const lt=!Array.isArray(ce);lt&&(ce=[ce]);const We=ze.map(Ct=>Ye.replace("{}",Ct)),Ge=this.tokenizer(We,{padding:!0,truncation:!0}),ht=this.processor.feature_extractor.config.sampling_rate,bt=await H(ce,ht),Ot=[];for(const Ct of bt){const U=await this.processor(Ct),se=await this.model({...Ge,...U}),J=(0,_.softmax)(se.logits_per_audio.data);Ot.push([...J].map((ue,Me)=>({score:ue,label:ze[Me]})))}return lt?Ot[0]:Ot}}class tt extends Y{constructor(ce){super(ce)}async _call(ce,ze={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(ce,ze);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(ce,ze);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(ce,ze){ze.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),ze.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const Ye=!Array.isArray(ce);Ye&&(ce=[ce]);const lt=this.processor.feature_extractor.config.sampling_rate,We=await H(ce,lt),Ge=[];for(const ht of We){const bt=await this.processor(ht),Ct=(await this.model(bt)).logits[0],U=[];for(const J of Ct)U.push((0,_.max)(J.data)[1]);const se=this.tokenizer.decode(U);Ge.push({text:se})}return Ye?Ge[0]:Ge}async _call_whisper(ce,ze){const Ye=ze.return_timestamps??!1,lt=ze.chunk_length_s??0,We=ze.force_full_sequences??!1;let Ge=ze.stride_length_s??null;const ht={...ze};Ye==="word"&&(ht.return_token_timestamps=!0,ht.return_timestamps=!1);const bt=!Array.isArray(ce);bt&&(ce=[ce]);const Ot=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,Ct=this.processor.feature_extractor.config.hop_length,U=this.processor.feature_extractor.config.sampling_rate,se=await H(ce,U),J=[];for(const ue of se){let Me=[];if(lt>0){if(Ge===null)Ge=lt/6;else if(lt<=Ge)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const Wt=U*lt,Tt=U*Ge,St=Wt-2*Tt;let Nt=0;for(;;){const Dt=Nt+Wt,gn=ue.subarray(Nt,Dt),An=await this.processor(gn),pr=Nt===0,Xn=Dt>=ue.length;if(Me.push({stride:[gn.length,pr?0:Tt,Xn?0:Tt],input_features:An.input_features,is_last:Xn}),Xn)break;Nt+=St}}else Me=[{stride:[ue.length,0,0],input_features:(await this.processor(ue)).input_features,is_last:!0}];for(const Wt of Me){ht.num_frames=Math.floor(Wt.stride[0]/Ct);const Tt=await this.model.generate({inputs:Wt.input_features,...ht});Ye==="word"?(Wt.tokens=Tt.sequences.tolist()[0],Wt.token_timestamps=Tt.token_timestamps.tolist()[0].map(St=>(0,_.round)(St,2))):Wt.tokens=Tt[0].tolist(),Wt.stride=Wt.stride.map(St=>St/U)}const[dt,at]=this.tokenizer._decode_asr(Me,{time_precision:Ot,return_timestamps:Ye,force_full_sequences:We});J.push({text:dt,...at})}return bt?J[0]:J}}class Je extends Y{constructor(ce){super(ce)}async _call(ce,ze={}){const Ye=Array.isArray(ce),lt=await A(ce),{pixel_values:We}=await this.processor(lt),Ge=[];for(const ht of We){ht.dims=[1,...ht.dims];const bt=await this.model.generate({inputs:ht,...ze}),Ot=this.tokenizer.batch_decode(bt,{skip_special_tokens:!0}).map(Ct=>({generated_text:Ct.trim()}));Ge.push(Ot)}return Ye?Ge:Ge[0]}}class it extends Y{constructor(ce){super(ce)}async _call(ce,{top_k:ze=5}={}){const Ye=await A(ce),{pixel_values:lt}=await this.processor(Ye),We=await this.model({pixel_values:lt}),Ge=this.model.config.id2label,ht=[];for(const bt of We.logits){const Ot=await(0,T.topk)(new T.Tensor("float32",(0,_.softmax)(bt.data),bt.dims),ze),Ct=Ot[0].tolist(),se=Ot[1].tolist().map((J,ue)=>({label:Ge?Ge[J]:`LABEL_${J}`,score:Ct[ue]}));ht.push(se)}return Array.isArray(ce)?ht:ht[0]}}class be extends Y{constructor(ce){super(ce),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(ce,{threshold:ze=.5,mask_threshold:Ye=.5,overlap_mask_area_threshold:lt=.8,label_ids_to_fuse:We=null,target_sizes:Ge=null,subtask:ht=null}={}){if(Array.isArray(ce)&&ce.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Ot=await A(ce),Ct=Ot.map(at=>[at.height,at.width]),{pixel_values:U,pixel_mask:se}=await this.processor(Ot),J=await this.model({pixel_values:U,pixel_mask:se});let ue=null;if(ht!==null)ue=this.subtasks_mapping[ht];else for(let[at,Wt]of Object.entries(this.subtasks_mapping))if(Wt in this.processor.feature_extractor){ue=this.processor.feature_extractor[Wt].bind(this.processor.feature_extractor),ht=at;break}const Me=this.model.config.id2label,dt=[];if(ht==="panoptic"||ht==="instance"){const at=ue(J,ze,Ye,lt,We,Ge??Ct)[0],Wt=at.segmentation;for(const Tt of at.segments_info){const St=new Uint8ClampedArray(Wt.data.length);for(let Dt=0;Dt<Wt.data.length;++Dt)Wt.data[Dt]===Tt.id&&(St[Dt]=255);const Nt=new E.RawImage(St,Wt.dims[1],Wt.dims[0],1);dt.push({score:Tt.score,label:Me[Tt.label_id],mask:Nt})}}else if(ht==="semantic"){const{segmentation:at,labels:Wt}=ue(J,Ge??Ct)[0];for(const Tt of Wt){const St=new Uint8ClampedArray(at.data.length);for(let Dt=0;Dt<at.data.length;++Dt)at.data[Dt]===Tt&&(St[Dt]=255);const Nt=new E.RawImage(St,at.dims[1],at.dims[0],1);dt.push({score:null,label:Me[Tt],mask:Nt})}}else throw Error(`Subtask ${ht} not supported.`);return dt}}class Q extends Y{constructor(ce){super(ce)}async _call(ce,ze,{hypothesis_template:Ye="This is a photo of {}"}={}){const lt=Array.isArray(ce),We=await A(ce),Ge=ze.map(se=>Ye.replace("{}",se)),ht=this.tokenizer(Ge,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:bt}=await this.processor(We),Ot=await this.model({...ht,pixel_values:bt}),Ct=this.model.config.model_type==="siglip"?se=>se.sigmoid().data:se=>(0,_.softmax)(se.data),U=[];for(const se of Ot.logits_per_image){const ue=[...Ct(se)].map((Me,dt)=>({score:Me,label:ze[dt]}));ue.sort((Me,dt)=>dt.score-Me.score),U.push(ue)}return lt?U:U[0]}}class ae extends Y{constructor(ce){super(ce)}async _call(ce,{threshold:ze=.9,percentage:Ye=!1}={}){const lt=Array.isArray(ce);if(lt&&ce.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const We=await A(ce),Ge=Ye?null:We.map(J=>[J.height,J.width]),{pixel_values:ht,pixel_mask:bt}=await this.processor(We),Ot=await this.model({pixel_values:ht,pixel_mask:bt}),Ct=this.processor.feature_extractor.post_process_object_detection(Ot,ze,Ge),U=this.model.config.id2label,se=Ct.map(J=>J.boxes.map((ue,Me)=>({score:J.scores[Me],label:U[J.classes[Me]],box:W(ue,!Ye)})));return lt?se:se[0]}}class ye extends Y{constructor(ce){super(ce)}async _call(ce,ze,{threshold:Ye=.1,top_k:lt=null,percentage:We=!1}={}){const Ge=Array.isArray(ce),ht=await A(ce),bt=this.tokenizer(ze,{padding:!0,truncation:!0}),Ot=await this.processor(ht),Ct=[];for(let U=0;U<ht.length;++U){const se=ht[U],J=We?null:[[se.height,se.width]],ue=Ot.pixel_values[U].unsqueeze_(0),Me=await this.model({...bt,pixel_values:ue}),dt=this.processor.feature_extractor.post_process_object_detection(Me,Ye,J,!0)[0];let at=dt.boxes.map((Wt,Tt)=>({score:dt.scores[Tt],label:ze[dt.classes[Tt]],box:W(Wt,!We)})).sort((Wt,Tt)=>Tt.score-Wt.score);lt!==null&&(at=at.slice(0,lt)),Ct.push(at)}return Ge?Ct:Ct[0]}}class Pe extends Y{constructor(ce){super(ce)}async _call(ce,ze,Ye={}){const lt=(await A(ce))[0],{pixel_values:We}=await this.processor(lt),Ge=`<s_docvqa><s_question>${ze}</s_question><s_answer>`,ht=this.tokenizer(Ge,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,bt=await this.model.generate({inputs:We,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:ht,...Ye}),Ct=this.tokenizer.batch_decode(bt)[0].match(/<s_answer>(.*?)<\/s_answer>/);let U=null;return Ct&&Ct.length>=2&&(U=Ct[1].trim()),[{answer:U}]}}class Ze extends Y{constructor(ze){super(ze);Ee(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=ze.vocoder??null}async _call(ze,{speaker_embeddings:Ye=null}={}){return this.processor?this._call_text_to_spectrogram(ze,{speaker_embeddings:Ye}):this._call_text_to_waveform(ze)}async _call_text_to_waveform(ze){const Ye=this.tokenizer(ze,{padding:!0,truncation:!0}),{waveform:lt}=await this.model(Ye),We=this.model.config.sampling_rate;return{audio:lt.data,sampling_rate:We}}async _call_text_to_spectrogram(ze,{speaker_embeddings:Ye}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await a.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof Ye=="string"||Ye instanceof URL)&&(Ye=new Float32Array(await(await fetch(Ye)).arrayBuffer())),Ye instanceof Float32Array)Ye=new T.Tensor("float32",Ye,[1,Ye.length]);else if(!(Ye instanceof T.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:lt}=this.tokenizer(ze,{padding:!0,truncation:!0}),{waveform:We}=await this.model.generate_speech(lt,Ye,{vocoder:this.vocoder}),Ge=this.processor.feature_extractor.config.sampling_rate;return{audio:We.data,sampling_rate:Ge}}}class me extends Y{constructor(ce){super(ce)}async _call(ce){const ze=await A(ce),Ye=await this.processor(ze),lt=await this.model(Ye),We=[];for(const Ge of lt.reconstruction){const ht=Ge.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");We.push(E.RawImage.fromTensor(ht))}return We.length>1?We:We[0]}}class Qe extends Y{constructor(ce){super(ce)}async _call(ce){const ze=await A(ce),Ye=await this.processor(ze),{predicted_depth:lt}=await this.model(Ye),We=[];for(let Ge=0;Ge<ze.length;++Ge){const ht=(0,T.interpolate)(lt[Ge],ze[Ge].size.reverse(),"bilinear",!1),bt=ht.mul_(255/(0,_.max)(ht.data)[0]).to("uint8");We.push({predicted_depth:lt[Ge],depth:E.RawImage.fromTensor(bt)})}return We.length>1?We:We[0]}}const et=Object.freeze({"text-classification":{tokenizer:o.AutoTokenizer,pipeline:B,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:o.AutoTokenizer,pipeline:F,model:a.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:o.AutoTokenizer,pipeline:O,model:a.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:o.AutoTokenizer,pipeline:P,model:a.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:o.AutoTokenizer,pipeline:V,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:o.AutoTokenizer,pipeline:z,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:o.AutoTokenizer,pipeline:j,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:o.AutoTokenizer,pipeline:L,model:a.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:o.AutoTokenizer,pipeline:pe,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:$e,model:a.AutoModelForAudioClassification,processor:l.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:o.AutoTokenizer,pipeline:Ce,model:a.AutoModel,processor:l.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:o.AutoTokenizer,pipeline:tt,model:[a.AutoModelForSpeechSeq2Seq,a.AutoModelForCTC],processor:l.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:o.AutoTokenizer,pipeline:Ze,model:[a.AutoModelForTextToWaveform,a.AutoModelForTextToSpectrogram],processor:[l.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:o.AutoTokenizer,pipeline:Je,model:a.AutoModelForVision2Seq,processor:l.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:it,model:a.AutoModelForImageClassification,processor:l.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:be,model:[a.AutoModelForImageSegmentation,a.AutoModelForSemanticSegmentation,a.AutoModelForUniversalSegmentation],processor:l.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:o.AutoTokenizer,pipeline:Q,model:a.AutoModel,processor:l.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:ae,model:a.AutoModelForObjectDetection,processor:l.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:o.AutoTokenizer,pipeline:ye,model:a.AutoModelForZeroShotObjectDetection,processor:l.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:o.AutoTokenizer,pipeline:Pe,model:a.AutoModelForDocumentQuestionAnswering,processor:l.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:me,model:a.AutoModelForImageToImage,processor:l.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Qe,model:a.AutoModelForDepthEstimation,processor:l.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:o.AutoTokenizer,pipeline:fe,model:a.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:l.AutoProcessor,pipeline:xe,model:[a.AutoModelForImageFeatureExtraction,a.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Ie=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function rt(nt,ce=null,{progress_callback:ze=null,config:Ye=null,cache_dir:lt=null,local_files_only:We=!1,revision:Ge="main",device:ht=null,dtype:bt=null,model_file_name:Ot=null,session_options:Ct={}}={}){nt=Ie[nt]??nt;const U=et[nt.split("_",1)[0]];if(!U)throw Error(`Unsupported pipeline: ${nt}. Must be one of [${Object.keys(et)}]`);ce||(ce=U.default.model,console.log(`No model specified. Using default model: "${ce}".`));const se={progress_callback:ze,config:Ye,cache_dir:lt,local_files_only:We,revision:Ge,device:ht,dtype:bt,model_file_name:Ot,session_options:Ct},J=new Map([["tokenizer",U.tokenizer],["model",U.model],["processor",U.processor]]),ue=await vt(J,ce,se);ue.task=nt,(0,w.dispatchCallback)(ze,{status:"ready",task:nt,model:ce});const Me=U.pipeline;return new Me(ue)}async function vt(nt,ce,ze){const Ye=Object.create(null),lt=[];for(const[We,Ge]of nt.entries()){if(!Ge)continue;let ht;Array.isArray(Ge)?ht=new Promise(async(bt,Ot)=>{var U,se;let Ct;for(const J of Ge){if(J===null){bt(null);return}try{bt(await J.from_pretrained(ce,ze));return}catch(ue){if((U=ue.message)!=null&&U.includes("Unsupported model type"))Ct=ue;else if((se=ue.message)!=null&&se.includes("Could not locate file"))Ct=ue;else{Ot(ue);return}}}Ot(Ct)}):ht=Ge.from_pretrained(ce,ze),Ye[We]=ht,lt.push(ht)}await Promise.all(lt);for(const[We,Ge]of Object.entries(Ye))Ye[We]=await Ge;return Ye}},"./src/processors.js":(e,t,r)=>{r.r(t),r.d(t,{ASTFeatureExtractor:()=>Me,AutoProcessor:()=>Hr,BeitFeatureExtractor:()=>ze,BitImageProcessor:()=>fe,CLIPFeatureExtractor:()=>$e,CLIPImageProcessor:()=>Ce,ChineseCLIPFeatureExtractor:()=>tt,ClapFeatureExtractor:()=>dt,ConvNextFeatureExtractor:()=>it,ConvNextImageProcessor:()=>be,DPTFeatureExtractor:()=>L,DPTImageProcessor:()=>pe,DeiTFeatureExtractor:()=>ce,DetrFeatureExtractor:()=>Ge,DonutFeatureExtractor:()=>Ye,DonutImageProcessor:()=>lt,EfficientNetImageProcessor:()=>ye,FeatureExtractor:()=>P,Florence2Processor:()=>mr,GLPNFeatureExtractor:()=>xe,ImageFeatureExtractor:()=>j,MaskFormerFeatureExtractor:()=>ht,MobileNetV1FeatureExtractor:()=>Pe,MobileNetV2FeatureExtractor:()=>Ze,MobileNetV3FeatureExtractor:()=>me,MobileNetV4FeatureExtractor:()=>Qe,MobileViTFeatureExtractor:()=>et,MobileViTImageProcessor:()=>Ie,NougatImageProcessor:()=>We,OwlViTFeatureExtractor:()=>rt,OwlViTProcessor:()=>Xn,Owlv2ImageProcessor:()=>vt,Processor:()=>St,PvtImageProcessor:()=>q,PyAnnoteFeatureExtractor:()=>at,PyAnnoteProcessor:()=>An,RTDetrImageProcessor:()=>nt,SamImageProcessor:()=>Ot,SamProcessor:()=>Nt,SapiensFeatureExtractor:()=>V,SeamlessM4TFeatureExtractor:()=>ue,SegformerFeatureExtractor:()=>z,SiglipImageProcessor:()=>Je,SpeechT5FeatureExtractor:()=>Tt,SpeechT5Processor:()=>pr,Swin2SRImageProcessor:()=>Ct,ViTFeatureExtractor:()=>Q,ViTImageProcessor:()=>ae,VitMatteImageProcessor:()=>U,Wav2Vec2FeatureExtractor:()=>J,Wav2Vec2ProcessorWithLM:()=>gn,WeSpeakerFeatureExtractor:()=>Wt,WhisperFeatureExtractor:()=>se,WhisperProcessor:()=>Dt,YolosFeatureExtractor:()=>bt});var o=r("./src/utils/generic.js"),a=r("./src/utils/core.js"),l=r("./src/utils/hub.js"),p=r("./src/utils/maths.js"),w=r("./src/utils/tensor.js");r("./src/utils/image.js");var _=r("./src/utils/audio.js");function y([ft,oe,Se,Re]){return[ft-Se/2,oe-Re/2,ft+Se/2,oe+Re/2]}function T(ft,oe=.5,Se=null,Re=!1){const Oe=ft.logits,Ve=ft.pred_boxes,[ut,xt,yt]=Oe.dims;if(Se!==null&&Se.length!==ut)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let $t=[];for(let _t=0;_t<ut;++_t){let Ut=Se!==null?Se[_t]:null,Gt={boxes:[],classes:[],scores:[]},Rt=Oe[_t],Be=Ve[_t];for(let Ne=0;Ne<xt;++Ne){let mt=Rt[Ne],Ht=[],cn;if(Re){cn=mt.sigmoid().data;for(let En=0;En<cn.length;++En)cn[En]>oe&&Ht.push(En)}else{let En=(0,p.max)(mt.data)[1];if(En===yt-1||(cn=(0,p.softmax)(mt.data),cn[En]<oe))continue;Ht.push(En)}for(const En of Ht){let Qn=Be[Ne].data;Qn=y(Qn),Ut!==null&&(Qn=Qn.map((bn,Dn)=>bn*Ut[(Dn+1)%2])),Gt.boxes.push(Qn),Gt.classes.push(En),Gt.scores.push(cn[En])}}$t.push(Gt)}return $t}function E(ft,oe=null){const Se=ft.logits,Re=Se.dims[0];if(oe!==null&&oe.length!==Re)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const Oe=[];for(let Ve=0;Ve<Re;++Ve){const ut=oe!==null?oe[Ve]:null;let xt=Se[Ve];ut!==null&&(xt=(0,w.interpolate)(xt,ut,"bilinear",!1));const[yt,$t]=ut??xt.dims.slice(-2),_t=new w.Tensor("int32",new Int32Array(yt*$t),[yt,$t]),Ut=xt[0].data,Gt=_t.data;for(let Ne=1;Ne<xt.dims[0];++Ne){const mt=xt[Ne].data;for(let Ht=0;Ht<mt.length;++Ht)mt[Ht]>Ut[Ht]&&(Ut[Ht]=mt[Ht],Gt[Ht]=Ne)}const Rt=new Array(xt.dims[0]);for(let Ne=0;Ne<Gt.length;++Ne){const mt=Gt[Ne];Rt[mt]=mt}const Be=Rt.filter(Ne=>Ne!==void 0);Oe.push({segmentation:_t,labels:Be})}return Oe}function A(ft,oe,Se,Re){const Oe=[],Ve=[],ut=[];for(let xt=0;xt<ft.dims[0];++xt){const yt=ft[xt],$t=oe[xt],_t=(0,p.max)(yt.data)[1];if(_t===Re)continue;const Gt=(0,p.softmax)(yt.data)[_t];Gt>Se&&(Oe.push($t),Ve.push(Gt),ut.push(_t))}return[Oe,Ve,ut]}function H(ft,oe,Se,Re=.5,Oe=.8){const Ve=[];let ut=0,xt=0;const yt=oe[Se].data;for(let _t=0;_t<ft.length;++_t)ft[_t]===Se&&(Ve.push(_t),++ut),yt[_t]>=Re&&++xt;let $t=ut>0&&xt>0;return $t&&($t=ut/xt>Oe),[$t,Ve]}function W(ft,oe,Se,Re,Oe,Ve=null,ut=null){const[xt,yt]=ut??ft[0].dims,$t=new w.Tensor("int32",new Int32Array(xt*yt),[xt,yt]),_t=[];if(ut!==null)for(let Ne=0;Ne<ft.length;++Ne)ft[Ne]=(0,w.interpolate)(ft[Ne],ut,"bilinear",!1);const Ut=new Int32Array(ft[0].data.length),Gt=new Float32Array(ft[0].data.length);for(let Ne=0;Ne<ft.length;++Ne){let mt=oe[Ne];const Ht=ft[Ne].data;for(let cn=0;cn<Ht.length;++cn)Ht[cn]*=mt,Ht[cn]>Gt[cn]&&(Ut[cn]=Ne,Gt[cn]=Ht[cn])}let Rt=0;const Be=$t.data;for(let Ne=0;Ne<Se.length;++Ne){const mt=Se[Ne],[Ht,cn]=H(Ut,ft,Ne,Re,Oe);if(Ht){++Rt;for(const En of cn)Be[En]=Rt;_t.push({id:Rt,label_id:mt,score:oe[Ne]})}}return[$t,_t]}function Y(ft,oe=.5,Se=.5,Re=.8,Oe=null,Ve=null){Oe===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),Oe=new Set);const ut=ft.class_queries_logits??ft.logits,yt=(ft.masks_queries_logits??ft.pred_masks).sigmoid();let[$t,_t,Ut]=ut.dims;if(Ut-=1,Ve!==null&&Ve.length!==$t)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Gt=[];for(let Rt=0;Rt<$t;++Rt){let Be=Ve!==null?Ve[Rt]:null,Ne=ut[Rt],mt=yt[Rt],[Ht,cn,En]=A(Ne,mt,oe,Ut);if(En.length===0){let[Dn,xn]=Be??mt.dims.slice(-2),si=new w.Tensor("int32",new Int32Array(Dn*xn).fill(-1),[Dn,xn]);Gt.push({segmentation:si,segments_info:[]});continue}let[Qn,bn]=W(Ht,cn,En,Se,Re,Oe,Be);Gt.push({segmentation:Qn,segments_info:bn})}return Gt}function B(ft,oe){var Se;if(!(ft instanceof Float32Array||ft instanceof Float64Array))throw new Error(`${oe} expects input to be a Float32Array or a Float64Array, but got ${((Se=ft==null?void 0:ft.constructor)==null?void 0:Se.name)??typeof ft} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function F(ft,oe,Se=0,Re=null){const Oe=ft/oe;let Ve=(0,p.bankers_round)(Oe)*oe;return Re!==null&&Ve>Re&&(Ve=Math.floor(Oe)*oe),Ve<Se&&(Ve=Math.ceil(Oe)*oe),Ve}function O([ft,oe],Se){return[Math.max(Math.floor(ft/Se),1)*Se,Math.max(Math.floor(oe/Se),1)*Se]}class P extends o.Callable{constructor(oe){super(),this.config=oe}}class j extends P{constructor(oe){super(oe),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(oe,Se,Re=2){const Oe=oe.height,Ve=oe.width,ut=Se.height,xt=Se.width;let yt=Math.min(Oe,ut),$t=Math.min(Ve,xt);return yt===Oe&&$t===Ve?oe:(Oe>Ve?$t=Math.floor(Ve*yt/Oe):Ve>Oe&&(yt=Math.floor(Oe*$t/Ve)),await oe.resize($t,yt,{resample:Re}))}async crop_margin(oe,Se=200){const Re=oe.clone().grayscale(),Oe=(0,p.min)(Re.data)[0],ut=(0,p.max)(Re.data)[0]-Oe;if(ut===0)return oe;const xt=Se/255;let yt=Re.width,$t=Re.height,_t=0,Ut=0;const Gt=Re.data;for(let Rt=0;Rt<Re.height;++Rt){const Be=Rt*Re.width;for(let Ne=0;Ne<Re.width;++Ne)(Gt[Be+Ne]-Oe)/ut<xt&&(yt=Math.min(yt,Ne),$t=Math.min($t,Rt),_t=Math.max(_t,Ne),Ut=Math.max(Ut,Rt))}return oe=await oe.crop([yt,$t,_t,Ut]),oe}pad_image(oe,Se,Re,{mode:Oe="constant",center:Ve=!1,constant_values:ut=0}={}){const[xt,yt,$t]=Se;let _t,Ut;if(typeof Re=="number"?(_t=Re,Ut=Re):(_t=Re.width,Ut=Re.height),_t!==yt||Ut!==xt){const Gt=new Float32Array(_t*Ut*$t);if(Array.isArray(ut))for(let Ne=0;Ne<Gt.length;++Ne)Gt[Ne]=ut[Ne%$t];else ut!==0&&Gt.fill(ut);const[Rt,Be]=Ve?[Math.floor((_t-yt)/2),Math.floor((Ut-xt)/2)]:[0,0];for(let Ne=0;Ne<xt;++Ne){const mt=(Ne+Be)*_t,Ht=Ne*yt;for(let cn=0;cn<yt;++cn){const En=(mt+cn+Rt)*$t,Qn=(Ht+cn)*$t;for(let bn=0;bn<$t;++bn)Gt[En+bn]=oe[Qn+bn]}}if(Oe==="symmetric"){if(Ve)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const Ne=xt-1,mt=yt-1;for(let Ht=0;Ht<Ut;++Ht){const cn=Ht*_t,En=(0,a.calculateReflectOffset)(Ht,Ne)*yt;for(let Qn=0;Qn<_t;++Qn){if(Ht<xt&&Qn<yt)continue;const bn=(cn+Qn)*$t,Dn=(En+(0,a.calculateReflectOffset)(Qn,mt))*$t;for(let xn=0;xn<$t;++xn)Gt[bn+xn]=oe[Dn+xn]}}}oe=Gt,Se=[Ut,_t,$t]}return[oe,Se]}rescale(oe){for(let Se=0;Se<oe.length;++Se)oe[Se]=this.rescale_factor*oe[Se]}get_resize_output_image_size(oe,Se){const[Re,Oe]=oe.size;let Ve,ut;if(this.do_thumbnail){const{height:xt,width:yt}=Se;Ve=Math.min(xt,yt)}else Number.isInteger(Se)?(Ve=Se,ut=this.config.max_size??Ve):Se!==void 0&&(Ve=Se.shortest_edge,ut=Se.longest_edge);if(Ve!==void 0||ut!==void 0){const xt=Ve===void 0?1:Math.max(Ve/Re,Ve/Oe),yt=Re*xt,$t=Oe*xt,_t=ut===void 0?1:Math.min(ut/yt,ut/$t);let Ut=Math.floor(Number((yt*_t).toFixed(2))),Gt=Math.floor(Number(($t*_t).toFixed(2)));return this.size_divisibility!==void 0&&([Ut,Gt]=O([Ut,Gt],this.size_divisibility)),[Ut,Gt]}else if(Se!==void 0&&Se.width!==void 0&&Se.height!==void 0){let xt=Se.width,yt=Se.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let $t=yt/Oe,_t=xt/Re;Math.abs(1-_t)<Math.abs(1-$t)?$t=_t:_t=$t,yt=F($t*Oe,this.config.ensure_multiple_of),xt=F(_t*Re,this.config.ensure_multiple_of)}return[xt,yt]}else{if(this.size_divisibility!==void 0)return O([Re,Oe],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(Se)}`)}}async resize(oe){const[Se,Re]=this.get_resize_output_image_size(oe,this.size);return await oe.resize(Se,Re,{resample:this.resample})}async preprocess(oe,{do_normalize:Se=null,do_pad:Re=null,do_convert_rgb:Oe=null,do_convert_grayscale:Ve=null,do_flip_channel_order:ut=null}={}){this.do_crop_margin&&(oe=await this.crop_margin(oe));const[xt,yt]=oe.size;if(Oe??this.do_convert_rgb?oe=oe.rgb():Ve&&(oe=oe.grayscale()),this.do_resize&&(oe=await this.resize(oe)),this.do_thumbnail&&(oe=await this.thumbnail(oe,this.size,this.resample)),this.do_center_crop){let Rt,Be;Number.isInteger(this.crop_size)?(Rt=this.crop_size,Be=this.crop_size):(Rt=this.crop_size.width,Be=this.crop_size.height),oe=await oe.center_crop(Rt,Be)}const $t=[oe.height,oe.width];let _t=Float32Array.from(oe.data),Ut=[oe.height,oe.width,oe.channels];if(this.do_rescale&&this.rescale(_t),Se??this.do_normalize){let Rt=this.image_mean;Array.isArray(this.image_mean)||(Rt=new Array(oe.channels).fill(Rt));let Be=this.image_std;if(Array.isArray(this.image_std)||(Be=new Array(oe.channels).fill(Rt)),Rt.length!==oe.channels||Be.length!==oe.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${Rt.length}) and \`image_std\` (${Be.length}) must match the number of channels in the image (${oe.channels}).`);for(let Ne=0;Ne<_t.length;Ne+=oe.channels)for(let mt=0;mt<oe.channels;++mt)_t[Ne+mt]=(_t[Ne+mt]-Rt[mt])/Be[mt]}if(Re??this.do_pad){if(this.pad_size)[_t,Ut]=this.pad_image(_t,[oe.height,oe.width,oe.channels],this.pad_size);else if(this.size_divisibility){const[Rt,Be]=O([Ut[1],Ut[0]],this.size_divisibility);[_t,Ut]=this.pad_image(_t,Ut,{width:Rt,height:Be})}}if(ut??this.do_flip_channel_order){if(Ut[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let Rt=0;Rt<_t.length;Rt+=3){const Be=_t[Rt];_t[Rt]=_t[Rt+2],_t[Rt+2]=Be}}const Gt=new w.Tensor("float32",_t,Ut).permute(2,0,1);return{original_size:[yt,xt],reshaped_input_size:$t,pixel_values:Gt}}async _call(oe,...Se){Array.isArray(oe)||(oe=[oe]);const Re=await Promise.all(oe.map(Ve=>this.preprocess(Ve)));return{pixel_values:(0,w.stack)(Re.map(Ve=>Ve.pixel_values),0),original_sizes:Re.map(Ve=>Ve.original_size),reshaped_input_sizes:Re.map(Ve=>Ve.reshaped_input_size)}}}class V extends j{post_process_semantic_segmentation(...oe){return E(...oe)}}class z extends j{post_process_semantic_segmentation(...oe){return E(...oe)}}class q extends j{}class L extends j{}class pe extends L{}class fe extends j{}class xe extends j{}class $e extends j{}class Ce extends $e{}class tt extends j{}class Je extends j{}class it extends j{constructor(oe){super(oe),this.crop_pct=this.config.crop_pct??224/256}async resize(oe){var Re;const Se=(Re=this.size)==null?void 0:Re.shortest_edge;if(Se===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(Se<384){const Oe=Math.floor(Se/this.crop_pct),[Ve,ut]=this.get_resize_output_image_size(oe,{shortest_edge:Oe});oe=await oe.resize(Ve,ut,{resample:this.resample}),oe=await oe.center_crop(Se,Se)}else oe=await oe.resize(Se,Se,{resample:this.resample});return oe}}class be extends it{}class Q extends j{}class ae extends j{}class ye extends j{constructor(oe){super(oe),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(Se=>Se*Se))}}class Pe extends j{}class Ze extends j{}class me extends j{}class Qe extends j{}class et extends j{}class Ie extends et{}class rt extends j{post_process_object_detection(...oe){return T(...oe)}}class vt extends rt{}class nt extends j{post_process_object_detection(...oe){return T(...oe)}}class ce extends j{}class ze extends j{}class Ye extends j{pad_image(oe,Se,Re,Oe={}){const[Ve,ut,xt]=Se;let yt=this.image_mean;Array.isArray(this.image_mean)||(yt=new Array(xt).fill(yt));let $t=this.image_std;Array.isArray($t)||($t=new Array(xt).fill(yt));const _t=yt.map((Ut,Gt)=>-Ut/$t[Gt]);return super.pad_image(oe,Se,Re,{center:!0,constant_values:_t,...Oe})}}class lt extends Ye{}class We extends Ye{}class Ge extends j{async _call(oe){const Se=await super._call(oe),Re=[Se.pixel_values.dims[0],64,64],Oe=(0,w.full)(Re,1n);return{...Se,pixel_mask:Oe}}post_process_object_detection(...oe){return T(...oe)}post_process_panoptic_segmentation(...oe){return Y(...oe)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class ht extends j{post_process_panoptic_segmentation(...oe){return Y(...oe)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class bt extends j{post_process_object_detection(...oe){return T(...oe)}}class Ot extends j{reshape_input_points(oe,Se,Re,Oe=!1){oe=structuredClone(oe);let Ve=(0,a.calculateDimensions)(oe);if(Ve.length===3)Oe||(Ve=[1,...Ve]),oe=[oe];else if(Ve.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let ut=0;ut<oe.length;++ut){let xt=Se[ut],yt=Re[ut],$t=[yt[0]/xt[0],yt[1]/xt[1]];for(let _t=0;_t<oe[ut].length;++_t)for(let Ut=0;Ut<oe[ut][_t].length;++Ut)for(let Gt=0;Gt<oe[ut][_t][Ut].length;++Gt)oe[ut][_t][Ut][Gt]*=$t[Gt%2]}return new w.Tensor("float32",Float32Array.from(oe.flat(1/0)),Ve)}add_input_labels(oe,Se){let Re=(0,a.calculateDimensions)(oe);if(Re.length===2)Re=[1,...Re],oe=[oe];else if(Re.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(Re.some((Oe,Ve)=>Oe!==Se.dims[Ve]))throw Error(`The first ${Re.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new w.Tensor("int64",oe.flat(1/0).map(BigInt),Re)}async _call(oe,{input_points:Se=null,input_labels:Re=null,input_boxes:Oe=null}={}){const Ve=await super._call(oe);if(Se&&(Ve.input_points=this.reshape_input_points(Se,Ve.original_sizes,Ve.reshaped_input_sizes)),Re){if(!Ve.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");Ve.input_labels=this.add_input_labels(Re,Ve.input_points)}return Oe&&(Ve.input_boxes=this.reshape_input_points(Oe,Ve.original_sizes,Ve.reshaped_input_sizes,!0)),Ve}async post_process_masks(oe,Se,Re,{mask_threshold:Oe=0,binarize:Ve=!0,pad_size:ut=null}={}){const xt=[];ut=ut??this.pad_size;const yt=[ut.height,ut.width];for(let $t=0;$t<Se.length;++$t){const _t=Se[$t],Ut=Re[$t];let Gt=await(0,w.interpolate_4d)(oe[$t],{mode:"bilinear",size:yt});if(Gt=Gt.slice(null,null,[0,Ut[0]],[0,Ut[1]]),Gt=await(0,w.interpolate_4d)(Gt,{mode:"bilinear",size:_t}),Ve){const Rt=Gt.data,Be=new Uint8Array(Rt.length);for(let Ne=0;Ne<Rt.length;++Ne)Rt[Ne]>Oe&&(Be[Ne]=1);Gt=new w.Tensor("bool",Be,Gt.dims)}xt.push(Gt)}return xt}generate_crop_boxes(oe,Se,{crop_n_layers:Re=0,overlap_ratio:Oe=512/1500,points_per_crop:Ve=32,crop_n_points_downscale_factor:ut=1}={}){}}class Ct extends j{pad_image(oe,Se,Re,Oe={}){const[Ve,ut,xt]=Se;return super.pad_image(oe,Se,{width:ut+(Re-ut%Re)%Re,height:Ve+(Re-Ve%Re)%Re},{mode:"symmetric",center:!1,constant_values:-1,...Oe})}}class U extends j{async _call(oe,Se){Array.isArray(oe)||(oe=[oe]),Array.isArray(Se)||(Se=[Se]);const Re=await Promise.all(oe.map(ut=>this.preprocess(ut))),Oe=await Promise.all(Se.map(ut=>this.preprocess(ut,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,w.stack)(Re.map((ut,xt)=>(0,w.cat)([ut.pixel_values,Oe[xt].pixel_values],0)),0),original_sizes:Re.map(ut=>ut.original_size),reshaped_input_sizes:Re.map(ut=>ut.reshaped_input_size)}}}class se extends P{constructor(oe){var Se;super(oe),(Se=this.config).mel_filters??(Se.mel_filters=(0,_.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,_.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(oe){const Se=await(0,_.spectrogram)(oe,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),Re=Se.data,Oe=(0,p.max)(Re)[0];for(let Ve=0;Ve<Re.length;++Ve)Re[Ve]=(Math.max(Re[Ve],Oe-8)+4)/4;return Se}async _call(oe){B(oe,"WhisperFeatureExtractor");let Se;return oe.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),Se=oe.slice(0,this.config.n_samples)):(Se=new Float32Array(this.config.n_samples),Se.set(oe)),{input_features:(await this._extract_fbank_features(Se)).unsqueeze_(0)}}}class J extends P{_zero_mean_unit_var_norm(oe){const Re=oe.reduce((Ve,ut)=>Ve+ut,0)/oe.length,Oe=oe.reduce((Ve,ut)=>Ve+(ut-Re)**2,0)/oe.length;return oe.map(Ve=>(Ve-Re)/Math.sqrt(Oe+1e-7))}async _call(oe){B(oe,"Wav2Vec2FeatureExtractor"),oe instanceof Float64Array&&(oe=new Float32Array(oe));let Se=oe;this.config.do_normalize&&(Se=this._zero_mean_unit_var_norm(Se));const Re=[1,Se.length];return{input_values:new w.Tensor("float32",Se,Re),attention_mask:new w.Tensor("int64",new BigInt64Array(Se.length).fill(1n),Re)}}}class ue extends P{constructor(oe){super(oe);const Se=this.config.sampling_rate,Re=(0,_.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Se/2),Se,null,"kaldi",!0);for(let Oe=0;Oe<Re.length;++Oe)Re[Oe].push(0);this.mel_filters=Re,this.window=(0,_.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(oe,Se){return oe=oe.map(Re=>Re*32768),(0,_.spectrogram)(oe,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Se,transpose:!0})}async _call(oe,{padding:Se=!0,pad_to_multiple_of:Re=2,do_normalize_per_mel_bins:Oe=!0,return_attention_mask:Ve=!0}={}){B(oe,"SeamlessM4TFeatureExtractor");let ut=await this._extract_fbank_features(oe,this.config.max_length);if(Oe){const[Be,Ne]=ut.dims,mt=ut.data;for(let Ht=0;Ht<Ne;++Ht){let cn=0;for(let Dn=0;Dn<Be;++Dn)cn+=mt[Dn*Ne+Ht];const En=cn/Be;let Qn=0;for(let Dn=0;Dn<Be;++Dn)Qn+=(mt[Dn*Ne+Ht]-En)**2;Qn/=Be-1;const bn=Math.sqrt(Qn+1e-7);for(let Dn=0;Dn<Be;++Dn){const xn=Dn*Ne+Ht;mt[xn]=(mt[xn]-En)/bn}}}let xt;if(Se){const[Be,Ne]=ut.dims,mt=ut.data,Ht=Be%Re;if(Ht>0){const cn=new Float32Array(Ne*(Be+Ht));cn.set(mt),cn.fill(this.config.padding_value,mt.length);const En=Be+Ht;ut=new w.Tensor(ut.type,cn,[En,Ne]),Ve&&(xt=new w.Tensor("int64",new BigInt64Array(En),[1,En]),xt.data.fill(1n,0,Be))}}const[yt,$t]=ut.dims,_t=this.config.stride;if(yt%_t!==0)throw new Error(`The number of frames (${yt}) must be a multiple of the stride (${_t}).`);const Gt=ut.view(1,Math.floor(yt/_t),$t*_t),Rt={input_features:Gt};if(Ve){const Be=Gt.dims[1],Ne=new BigInt64Array(Be);if(xt){const mt=xt.data;for(let Ht=1,cn=0;Ht<yt;Ht+=_t,++cn)Ne[cn]=mt[Ht]}else Ne.fill(1n);Rt.attention_mask=new w.Tensor("int64",Ne,[1,Be])}return Rt}}class Me extends P{constructor(oe){super(oe);const Se=this.config.sampling_rate,Re=(0,_.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Se/2),Se,null,"kaldi",!0);for(let Oe=0;Oe<Re.length;++Oe)Re[Oe].push(0);this.mel_filters=Re,this.window=(0,_.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(oe,Se){return(0,_.spectrogram)(oe,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:Se,transpose:!0})}async _call(oe){B(oe,"ASTFeatureExtractor");const Se=await this._extract_fbank_features(oe,this.config.max_length);if(this.config.do_normalize){const Re=this.std*2,Oe=Se.data;for(let Ve=0;Ve<Oe.length;++Ve)Oe[Ve]=(Oe[Ve]-this.mean)/Re}return{input_values:Se.unsqueeze_(0)}}}class dt extends P{constructor(oe){super(oe),this.mel_filters=(0,_.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,_.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,_.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(oe,Se,Re,Oe){let Ve;const ut=oe.length-Se;if(ut>0)if(Re==="rand_trunc"){const xt=Math.floor(Math.random()*(ut+1));oe=oe.subarray(xt,xt+Se),Ve=await this._extract_fbank_features(oe,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${Re}" not implemented`);else{if(ut<0){let xt=new Float64Array(Se);if(xt.set(oe),Oe==="repeat")for(let yt=oe.length;yt<Se;yt+=oe.length)xt.set(oe.subarray(0,Math.min(oe.length,Se-yt)),yt);else if(Oe==="repeatpad")for(let yt=oe.length;yt<-ut;yt+=oe.length)xt.set(oe,yt);oe=xt}if(Re==="fusion")throw new Error(`Truncation strategy "${Re}" not implemented`);Ve=await this._extract_fbank_features(oe,this.mel_filters_slaney,this.config.nb_max_samples)}return Ve.unsqueeze_(0)}async _extract_fbank_features(oe,Se,Re=null){return(0,_.spectrogram)(oe,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:Se,log_mel:"dB",max_num_frames:Re,do_pad:!1,transpose:!0})}async _call(oe,{max_length:Se=null}={}){return B(oe,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(oe,Se??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class at extends P{async _call(oe){B(oe,"PyAnnoteFeatureExtractor"),oe instanceof Float64Array&&(oe=new Float32Array(oe));const Se=[1,1,oe.length];return{input_values:new w.Tensor("float32",oe,Se)}}samples_to_frames(oe){return(oe-this.config.offset)/this.config.step}post_process_speaker_diarization(oe,Se){const Re=Se/this.samples_to_frames(Se)/this.config.sampling_rate,Oe=[];for(const Ve of oe.tolist()){const ut=[];let xt=-1;for(let yt=0;yt<Ve.length;++yt){const $t=(0,p.softmax)(Ve[yt]),[_t,Ut]=(0,p.max)($t),[Gt,Rt]=[yt,yt+1];Ut!==xt?(xt=Ut,ut.push({id:Ut,start:Gt,end:Rt,score:_t})):(ut.at(-1).end=Rt,ut.at(-1).score+=_t)}Oe.push(ut.map(({id:yt,start:$t,end:_t,score:Ut})=>({id:yt,start:$t*Re,end:_t*Re,confidence:Ut/(_t-$t)})))}return Oe}}class Wt extends P{constructor(oe){super(oe);const Se=this.config.sampling_rate,Re=(0,_.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(Se/2),Se,null,"kaldi",!0);for(let Oe=0;Oe<Re.length;++Oe)Re[Oe].push(0);this.mel_filters=Re,this.window=(0,_.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(oe){return oe=oe.map(Se=>Se*32768),(0,_.spectrogram)(oe,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(oe){B(oe,"WeSpeakerFeatureExtractor");const Se=(await this._extract_fbank_features(oe)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const Re=Se.mean(1).data,Oe=Se.data,[Ve,ut,xt]=Se.dims;for(let yt=0;yt<Ve;++yt){const $t=yt*ut*xt,_t=yt*xt;for(let Ut=0;Ut<ut;++Ut){const Gt=$t+Ut*xt;for(let Rt=0;Rt<xt;++Rt)Oe[Gt+Rt]-=Re[_t+Rt]}}}return{input_features:Se}}}class Tt extends P{}class St extends o.Callable{constructor(oe){super(),this.feature_extractor=oe}async _call(oe,...Se){return await this.feature_extractor(oe,...Se)}}class Nt extends St{async _call(...oe){return await this.feature_extractor(...oe)}post_process_masks(...oe){return this.feature_extractor.post_process_masks(...oe)}reshape_input_points(...oe){return this.feature_extractor.reshape_input_points(...oe)}}class Dt extends St{async _call(oe){return await this.feature_extractor(oe)}}class gn extends St{async _call(oe){return await this.feature_extractor(oe)}}class An extends St{async _call(oe){return await this.feature_extractor(oe)}post_process_speaker_diarization(...oe){return this.feature_extractor.post_process_speaker_diarization(...oe)}}class pr extends St{async _call(oe){return await this.feature_extractor(oe)}}class Xn extends St{}class mr extends St{constructor(oe){super(oe);const{tasks_answer_post_processing_type:Se,task_prompts_without_inputs:Re,task_prompts_with_input:Oe}=oe.config;this.tasks_answer_post_processing_type=new Map(Object.entries(Se??{})),this.task_prompts_without_inputs=new Map(Object.entries(Re??{})),this.task_prompts_with_input=new Map(Object.entries(Oe??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(oe){typeof oe=="string"&&(oe=[oe]);const Se=[];for(const Re of oe)if(this.task_prompts_without_inputs.has(Re))Se.push(this.task_prompts_without_inputs.get(Re));else{for(const[Oe,Ve]of this.task_prompts_with_input)if(Re.includes(Oe)){Se.push(Ve.replaceAll("{input}",Re).replaceAll(Oe,""));break}Se.length!==oe.length&&Se.push(Re)}return Se}post_process_generation(oe,Se,Re){const Oe=this.tasks_answer_post_processing_type.get(Se)??"pure_text";oe=oe.replaceAll("<s>","").replaceAll("</s>","");let Ve;switch(Oe){case"pure_text":Ve=oe;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const ut=Oe==="ocr"?"quad_boxes":"bboxes",xt=oe.matchAll(this.regexes[ut]),yt=[],$t=[];for(const[_t,Ut,...Gt]of xt)yt.push(Ut?Ut.trim():yt.at(-1)??""),$t.push(Gt.map((Rt,Be)=>(Number(Rt)+.5)/this.size_per_bin*Re[Be%2]));Ve={labels:yt,[ut]:$t};break;default:throw new Error(`Task "${Se}" (of type "${Oe}") not yet implemented.`)}return{[Se]:Ve}}}class Hr{static async from_pretrained(oe,{progress_callback:Se=null,config:Re=null,cache_dir:Oe=null,local_files_only:Ve=!1,revision:ut="main"}={}){let xt=Re??await(0,l.getModelJSON)(oe,"preprocessor_config.json",!0,{progress_callback:Se,config:Re,cache_dir:Oe,local_files_only:Ve,revision:ut}),yt=xt.feature_extractor_type??xt.image_processor_type,$t=this.FEATURE_EXTRACTOR_CLASS_MAPPING[yt];if(!$t)if(xt.size!==void 0)console.warn(`Feature extractor type "${yt}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),$t=j;else throw new Error(`Unknown Feature Extractor type: ${yt}`);let _t=this.PROCESSOR_CLASS_MAPPING[xt.processor_class]??St,Ut=new $t(xt);return new _t(Ut)}}Ee(Hr,"FEATURE_EXTRACTOR_CLASS_MAPPING",{ImageFeatureExtractor:j,WhisperFeatureExtractor:se,ViTFeatureExtractor:Q,MobileViTFeatureExtractor:et,MobileViTImageProcessor:Ie,MobileNetV1FeatureExtractor:Pe,MobileNetV2FeatureExtractor:Ze,MobileNetV3FeatureExtractor:me,MobileNetV4FeatureExtractor:Qe,OwlViTFeatureExtractor:rt,Owlv2ImageProcessor:vt,CLIPFeatureExtractor:$e,CLIPImageProcessor:Ce,Florence2Processor:mr,ChineseCLIPFeatureExtractor:tt,SiglipImageProcessor:Je,ConvNextFeatureExtractor:it,ConvNextImageProcessor:be,SegformerFeatureExtractor:z,SapiensFeatureExtractor:V,BitImageProcessor:fe,DPTImageProcessor:pe,DPTFeatureExtractor:L,PvtImageProcessor:q,GLPNFeatureExtractor:xe,BeitFeatureExtractor:ze,DeiTFeatureExtractor:ce,DetrFeatureExtractor:Ge,RTDetrImageProcessor:nt,MaskFormerFeatureExtractor:ht,YolosFeatureExtractor:bt,DonutFeatureExtractor:Ye,DonutImageProcessor:lt,NougatImageProcessor:We,EfficientNetImageProcessor:ye,ViTImageProcessor:ae,VitMatteImageProcessor:U,SamImageProcessor:Ot,Swin2SRImageProcessor:Ct,Wav2Vec2FeatureExtractor:J,SeamlessM4TFeatureExtractor:ue,SpeechT5FeatureExtractor:Tt,ASTFeatureExtractor:Me,ClapFeatureExtractor:dt,PyAnnoteFeatureExtractor:at,WeSpeakerFeatureExtractor:Wt}),Ee(Hr,"PROCESSOR_CLASS_MAPPING",{WhisperProcessor:Dt,Wav2Vec2ProcessorWithLM:gn,PyAnnoteProcessor:An,SamProcessor:Nt,SpeechT5Processor:pr,OwlViTProcessor:Xn,Florence2Processor:mr})},"./src/tokenizers.js":(e,t,r)=>{r.r(t),r.d(t,{AlbertTokenizer:()=>ut,AutoTokenizer:()=>vs,BartTokenizer:()=>Qn,BertTokenizer:()=>Ve,BlenderbotSmallTokenizer:()=>_s,BlenderbotTokenizer:()=>gs,BloomTokenizer:()=>si,CLIPTokenizer:()=>Uo,CamembertTokenizer:()=>Ne,CodeGenTokenizer:()=>No,CodeLlamaTokenizer:()=>cs,CohereTokenizer:()=>vo,ConvBertTokenizer:()=>Gt,DebertaTokenizer:()=>$t,DebertaV2Tokenizer:()=>_t,DistilBertTokenizer:()=>Be,ElectraTokenizer:()=>Ht,EsmTokenizer:()=>hs,FalconTokenizer:()=>ps,GPT2Tokenizer:()=>En,GPTNeoXTokenizer:()=>fs,GemmaTokenizer:()=>yo,Grok1Tokenizer:()=>Zi,HerbertTokenizer:()=>Ut,LlamaTokenizer:()=>Ro,M2M100Tokenizer:()=>Bo,MBart50Tokenizer:()=>Dn,MBartTokenizer:()=>bn,MPNetTokenizer:()=>ds,MarianTokenizer:()=>nn,MobileBertTokenizer:()=>xt,NllbTokenizer:()=>zi,NougatTokenizer:()=>ys,PreTrainedTokenizer:()=>Oe,Qwen2Tokenizer:()=>ms,RoFormerTokenizer:()=>Rt,RobertaTokenizer:()=>xn,SiglipTokenizer:()=>jo,SpeechT5Tokenizer:()=>Vo,SqueezeBertTokenizer:()=>yt,T5Tokenizer:()=>cn,TokenizerModel:()=>xe,VitsTokenizer:()=>ws,Wav2Vec2CTCTokenizer:()=>wo,WhisperTokenizer:()=>Ei,XLMRobertaTokenizer:()=>Ji,XLMTokenizer:()=>mt,is_chinese_char:()=>P});var o=r("./src/utils/generic.js"),a=r("./src/utils/core.js"),l=r("./src/utils/hub.js"),p=r("./src/utils/maths.js"),w=r("./src/utils/tensor.js"),_=r("./src/utils/data-structures.js"),y=r("./node_modules/@huggingface/jinja/dist/index.js"),T=r("./src/models/whisper/common_whisper.js");r("./src/utils/constants.js");async function E(we,C){const te=await Promise.all([(0,l.getModelJSON)(we,"tokenizer.json",!0,C),(0,l.getModelJSON)(we,"tokenizer_config.json",!0,C)]);return C.legacy!==null&&(te[1].legacy=C.legacy),te}function A(we,C){const te=[];let le=0;for(const ve of we.matchAll(C)){const Te=ve[0];le<ve.index&&te.push(we.slice(le,ve.index)),Te.length>0&&te.push(Te),le=ve.index+Te.length}return le<we.length&&te.push(we.slice(le)),te}function H(we,C=!0){if(we.Regex!==void 0){let te=we.Regex.replace(/\\([#&~])/g,"$1");for(const[le,ve]of pe)te=te.replaceAll(le,ve);return new RegExp(te,"gu")}else if(we.String!==void 0){const te=(0,a.escapeRegExp)(we.String);return new RegExp(C?te:`(${te})`,"gu")}else return console.warn("Unknown pattern type:",we),null}function W(we){return new Map(Object.entries(we))}function Y(we){const C=we.dims;switch(C.length){case 1:return we.tolist();case 2:if(C[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return we.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${C.length}.`)}}function B(we){return we.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function F(we){return we.replace(new RegExp("\\p{M}","gu"),"")}function O(we){return F(we.toLowerCase())}function P(we){return we>=19968&&we<=40959||we>=13312&&we<=19903||we>=131072&&we<=173791||we>=173824&&we<=177983||we>=177984&&we<=178207||we>=178208&&we<=183983||we>=63744&&we<=64255||we>=194560&&we<=195103}function j(we,C,te){const le=[];let ve=0;for(;ve<we.length;){if(le.push(we[ve]),(C.get(we[ve])??te)!==te){++ve;continue}for(;++ve<we.length&&(C.get(we[ve])??te)===te;)C.get(le.at(-1))!==te&&(le[le.length-1]+=we[ve])}return le}function V(we){return we.match(/\S+/g)||[]}const z="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",q=new RegExp(`^[${z}]+$`,"gu"),L=".,!?…。，、।۔،",pe=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${L}])]+`,` ?[^\\s${L}]+`]]);class fe{constructor(C){this.content=C.content,this.id=C.id,this.single_word=C.single_word??!1,this.lstrip=C.lstrip??!1,this.rstrip=C.rstrip??!1,this.special=C.special??!1,this.normalized=C.normalized??null}}class xe extends o.Callable{constructor(C){super(),this.config=C,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(C,...te){switch(C.type){case"WordPiece":return new $e(C);case"Unigram":return new Ce(C,...te);case"BPE":return new it(C);default:if(C.vocab)return Array.isArray(C.vocab)?new Ce(C,...te):new be(C,...te);throw new Error(`Unknown TokenizerModel type: ${C.type}`)}}_call(C){return C=this.encode(C),this.fuse_unk&&(C=j(C,this.tokens_to_ids,this.unk_token_id)),C}encode(C){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(C){return C.map(te=>this.tokens_to_ids.get(te)??this.unk_token_id)}convert_ids_to_tokens(C){return C.map(te=>this.vocab[te]??this.unk_token)}}class $e extends xe{constructor(C){super(C),this.tokens_to_ids=W(C.vocab),this.unk_token_id=this.tokens_to_ids.get(C.unk_token),this.unk_token=C.unk_token,this.max_input_chars_per_word=C.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[te,le]of this.tokens_to_ids)this.vocab[le]=te}encode(C){const te=[];for(const le of C){const ve=[...le];if(ve.length>this.max_input_chars_per_word){te.push(this.unk_token);continue}let Te=!1,He=0;const Mt=[];for(;He<ve.length;){let At=ve.length,Pt=null;for(;He<At;){let Bt=ve.slice(He,At).join("");if(He>0&&(Bt=this.config.continuing_subword_prefix+Bt),this.tokens_to_ids.has(Bt)){Pt=Bt;break}--At}if(Pt===null){Te=!0;break}Mt.push(Pt),He=At}Te?te.push(this.unk_token):te.push(...Mt)}return te}}class Ce extends xe{constructor(C,te){super(C);const le=C.vocab.length;this.vocab=new Array(le),this.scores=new Array(le);for(let ve=0;ve<le;++ve){const Te=C.vocab[ve];this.vocab[ve]=Te[0],this.scores[ve]=Te[1]}this.unk_token_id=C.unk_id,this.unk_token=this.vocab[C.unk_id],this.tokens_to_ids=new Map(this.vocab.map((ve,Te)=>[ve,Te])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=te.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,p.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new _.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(C){const te=C.chars,le=1;let ve=0;for(;ve<te.length;){let Te=!1;const He=te.slice(ve).join(""),Mt=this.trie.commonPrefixSearch(He);for(const At of Mt){const Pt=this.tokens_to_ids.get(At),Bt=this.scores[Pt],sn=(0,a.len)(At);C.insert(ve,sn,Bt,Pt),!Te&&sn===le&&(Te=!0)}Te||C.insert(ve,le,this.unk_score,this.unk_token_id),ve+=le}}tokenize(C){const te=new _.TokenLattice(C,this.bos_token_id,this.eos_token_id);return this.populateNodes(te),te.tokens()}encode(C){const te=[];for(const le of C){const ve=this.tokenize(le);te.push(...ve)}return te}}const tt=(()=>{const we=[...Array.from({length:94},(ve,Te)=>Te+33),...Array.from({length:12},(ve,Te)=>Te+161),...Array.from({length:82},(ve,Te)=>Te+174)],C=we.slice();let te=0;for(let ve=0;ve<256;++ve)we.includes(ve)||(we.push(ve),C.push(256+te),te+=1);const le=C.map(ve=>String.fromCharCode(ve));return Object.fromEntries(we.map((ve,Te)=>[ve,le[Te]]))})(),Je=(0,a.reverseDictionary)(tt);class it extends xe{constructor(C){super(C),this.tokens_to_ids=W(C.vocab),this.unk_token_id=this.tokens_to_ids.get(C.unk_token),this.unk_token=C.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[le,ve]of this.tokens_to_ids)this.vocab[ve]=le;const te=Array.isArray(C.merges[0]);this.merges=te?C.merges:C.merges.map(le=>le.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((le,ve)=>[JSON.stringify(le),ve])),this.end_of_word_suffix=C.end_of_word_suffix,this.continuing_subword_suffix=C.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(C){if(C.length===0)return[];const te=this.cache.get(C);if(te!==void 0)return te;const le=Array.from(C);this.end_of_word_suffix&&(le[le.length-1]+=this.end_of_word_suffix);let ve=[];if(le.length>1){const Te=new _.PriorityQueue((At,Pt)=>At.score<Pt.score);let He={token:le[0],bias:0,prev:null,next:null},Mt=He;for(let At=1;At<le.length;++At){const Pt={bias:At/le.length,token:le[At],prev:Mt,next:null};Mt.next=Pt,this._add_node(Te,Mt),Mt=Pt}for(;!Te.isEmpty();){const At=Te.pop();if(At.deleted||!At.next||At.next.deleted)continue;if(At.deleted=!0,At.next.deleted=!0,At.prev){const Bt={...At.prev};At.prev.deleted=!0,At.prev=Bt,Bt.prev?Bt.prev.next=Bt:He=Bt}const Pt={token:At.token+At.next.token,bias:At.bias,prev:At.prev,next:At.next.next};Pt.prev?(Pt.prev.next=Pt,this._add_node(Te,Pt.prev)):He=Pt,Pt.next&&(Pt.next.prev=Pt,this._add_node(Te,Pt))}for(let At=He;At!==null;At=At.next)ve.push(At.token)}else ve=le;if(this.continuing_subword_suffix)for(let Te=0;Te<ve.length-1;++Te)ve[Te]+=this.continuing_subword_suffix;return this.cache.set(C,ve),ve}_add_node(C,te){const le=this.bpe_ranks.get(JSON.stringify([te.token,te.next.token]));le!==void 0&&(te.score=le+te.bias,C.push(te))}encode(C){const te=[];for(const le of C){if(this.ignore_merges&&this.tokens_to_ids.has(le)){te.push(le);continue}const ve=this.bpe(le);for(const Te of ve)if(this.tokens_to_ids.has(Te))te.push(Te);else if(this.byte_fallback){const He=Array.from(this.text_encoder.encode(Te)).map(Mt=>`<0x${Mt.toString(16).toUpperCase().padStart(2,"0")}>`);He.every(Mt=>this.tokens_to_ids.has(Mt))?te.push(...He):te.push(this.unk_token)}else te.push(this.unk_token)}return te}}class be extends xe{constructor(C,te){super(C),this.tokens_to_ids=W(te.target_lang?C.vocab[te.target_lang]:C.vocab),this.bos_token=te.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=te.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=te.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=te.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[le,ve]of this.tokens_to_ids)this.vocab[ve]=le}encode(C){return C}}class Q extends o.Callable{constructor(C){super(),this.config=C}static fromConfig(C){if(C===null)return null;switch(C.type){case"BertNormalizer":return new vt(C);case"Precompiled":return new pr(C);case"Sequence":return new rt(C);case"Replace":return new ae(C);case"NFC":return new ye(C);case"NFKC":return new Pe(C);case"NFKD":return new Ze(C);case"Strip":return new me(C);case"StripAccents":return new Qe(C);case"Lowercase":return new et(C);case"Prepend":return new Ie(C);default:throw new Error(`Unknown Normalizer type: ${C.type}`)}}normalize(C){throw Error("normalize should be implemented in subclass.")}_call(C){return this.normalize(C)}}class ae extends Q{normalize(C){const te=H(this.config.pattern);return te===null?C:C.replaceAll(te,this.config.content)}}class ye extends Q{normalize(C){return C=C.normalize("NFC"),C}}class Pe extends Q{normalize(C){return C=C.normalize("NFKC"),C}}class Ze extends Q{normalize(C){return C=C.normalize("NFKD"),C}}class me extends Q{normalize(C){return this.config.strip_left&&this.config.strip_right?C=C.trim():(this.config.strip_left&&(C=C.trimStart()),this.config.strip_right&&(C=C.trimEnd())),C}}class Qe extends Q{normalize(C){return C=F(C),C}}class et extends Q{normalize(C){return C=C.toLowerCase(),C}}class Ie extends Q{normalize(C){return C=this.config.prepend+C,C}}class rt extends Q{constructor(C){super(C),this.normalizers=C.normalizers.map(te=>Q.fromConfig(te))}normalize(C){return this.normalizers.reduce((te,le)=>le.normalize(te),C)}}class vt extends Q{_tokenize_chinese_chars(C){const te=[];for(let le=0;le<C.length;++le){const ve=C[le],Te=ve.charCodeAt(0);P(Te)?(te.push(" "),te.push(ve),te.push(" ")):te.push(ve)}return te.join("")}stripAccents(C){return C.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(C){switch(C){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(C)}}_clean_text(C){const te=[];for(const le of C){const ve=le.charCodeAt(0);ve===0||ve===65533||this._is_control(le)||(/^\s$/.test(le)?te.push(" "):te.push(le))}return te.join("")}normalize(C){return this.config.clean_text&&(C=this._clean_text(C)),this.config.handle_chinese_chars&&(C=this._tokenize_chinese_chars(C)),this.config.lowercase?(C=C.toLowerCase(),this.config.strip_accents!==!1&&(C=this.stripAccents(C))):this.config.strip_accents&&(C=this.stripAccents(C)),C}}class nt extends o.Callable{static fromConfig(C){if(C===null)return null;switch(C.type){case"BertPreTokenizer":return new ce(C);case"Sequence":return new Xn(C);case"Whitespace":return new mr(C);case"WhitespaceSplit":return new Hr(C);case"Metaspace":return new gn(C);case"ByteLevel":return new ze(C);case"Split":return new Ye(C);case"Punctuation":return new lt(C);case"Digits":return new We(C);case"Replace":return new ft(C);default:throw new Error(`Unknown PreTokenizer type: ${C.type}`)}}pre_tokenize_text(C,te){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(C,te){return(Array.isArray(C)?C.map(le=>this.pre_tokenize_text(le,te)):this.pre_tokenize_text(C,te)).flat()}_call(C,te){return this.pre_tokenize(C,te)}}class ce extends nt{constructor(C){super(),this.pattern=new RegExp(`[^\\s${z}]+|[${z}]`,"gu")}pre_tokenize_text(C,te){return C.trim().match(this.pattern)||[]}}class ze extends nt{constructor(C){super(),this.config=C,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=tt,this.text_encoder=new TextEncoder}pre_tokenize_text(C,te){return this.add_prefix_space&&!C.startsWith(" ")&&(C=" "+C),(this.use_regex?C.match(this.pattern)||[]:[C]).map(ve=>Array.from(this.text_encoder.encode(ve),Te=>this.byte_encoder[Te]).join(""))}}class Ye extends nt{constructor(C){super(),this.config=C,this.pattern=H(this.config.pattern,this.config.invert)}pre_tokenize_text(C,te){return this.pattern===null?[]:this.config.invert?C.match(this.pattern)||[]:A(C,this.pattern)}}class lt extends nt{constructor(C){super(),this.config=C,this.pattern=new RegExp(`[^${z}]+|[${z}]+`,"gu")}pre_tokenize_text(C,te){return C.match(this.pattern)||[]}}class We extends nt{constructor(C){super(),this.config=C;const te=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(te,"gu")}pre_tokenize_text(C,te){return C.match(this.pattern)||[]}}class Ge extends o.Callable{constructor(C){super(),this.config=C}static fromConfig(C){if(C===null)return null;switch(C.type){case"TemplateProcessing":return new Ot(C);case"ByteLevel":return new Ct(C);case"RobertaProcessing":return new bt(C);case"BertProcessing":return new ht(C);case"Sequence":return new U(C);default:throw new Error(`Unknown PostProcessor type: ${C.type}`)}}post_process(C,...te){throw Error("post_process should be implemented in subclass.")}_call(C,...te){return this.post_process(C,...te)}}class ht extends Ge{constructor(C){super(C),this.cls=C.cls[0],this.sep=C.sep[0]}post_process(C,te=null,{add_special_tokens:le=!0}={}){le&&(C=(0,a.mergeArrays)([this.cls],C,[this.sep]));let ve=new Array(C.length).fill(0);if(te!==null){const Te=le&&this instanceof bt?[this.sep]:[],He=le?[this.sep]:[];C=(0,a.mergeArrays)(C,Te,te,He),ve=(0,a.mergeArrays)(ve,new Array(te.length+Te.length+He.length).fill(1))}return{tokens:C,token_type_ids:ve}}}class bt extends ht{}class Ot extends Ge{constructor(C){super(C),this.single=C.single,this.pair=C.pair}post_process(C,te=null,{add_special_tokens:le=!0}={}){const ve=te===null?this.single:this.pair;let Te=[],He=[];for(const Mt of ve)"SpecialToken"in Mt?le&&(Te.push(Mt.SpecialToken.id),He.push(Mt.SpecialToken.type_id)):"Sequence"in Mt&&(Mt.Sequence.id==="A"?(Te=(0,a.mergeArrays)(Te,C),He=(0,a.mergeArrays)(He,new Array(C.length).fill(Mt.Sequence.type_id))):Mt.Sequence.id==="B"&&(Te=(0,a.mergeArrays)(Te,te),He=(0,a.mergeArrays)(He,new Array(te.length).fill(Mt.Sequence.type_id))));return{tokens:Te,token_type_ids:He}}}class Ct extends Ge{post_process(C,te=null){return te&&(C=(0,a.mergeArrays)(C,te)),{tokens:C}}}class U extends Ge{constructor(C){super(C),this.processors=C.processors.map(te=>Ge.fromConfig(te))}post_process(C,te=null,le={}){let ve;for(const Te of this.processors)if(Te instanceof Ct)C=Te.post_process(C).tokens,te&&(te=Te.post_process(te).tokens);else{const He=Te.post_process(C,te,le);C=He.tokens,ve=He.token_type_ids}return{tokens:C,token_type_ids:ve}}}class se extends o.Callable{constructor(C){super(),this.config=C,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=C.trim_offsets}static fromConfig(C){if(C===null)return null;switch(C.type){case"WordPiece":return new at(C);case"Metaspace":return new An(C);case"ByteLevel":return new Wt(C);case"Replace":return new J(C);case"ByteFallback":return new ue(C);case"Fuse":return new Me(C);case"Strip":return new dt(C);case"Sequence":return new St(C);case"CTC":return new Tt(C);case"BPEDecoder":return new Nt(C);default:throw new Error(`Unknown Decoder type: ${C.type}`)}}_call(C){return this.decode(C)}decode(C){return this.decode_chain(C).join("")}decode_chain(C){throw Error("`decode_chain` should be implemented in subclass.")}}class J extends se{decode_chain(C){const te=H(this.config.pattern);return te===null?C:C.map(le=>le.replaceAll(te,this.config.content))}}class ue extends se{constructor(C){super(C),this.text_decoder=new TextDecoder}decode_chain(C){const te=[];let le=[];for(const ve of C){let Te=null;if(ve.length===6&&ve.startsWith("<0x")&&ve.endsWith(">")){const He=parseInt(ve.slice(3,5),16);isNaN(He)||(Te=He)}if(Te!==null)le.push(Te);else{if(le.length>0){const He=this.text_decoder.decode(Uint8Array.from(le));te.push(He),le=[]}te.push(ve)}}if(le.length>0){const ve=this.text_decoder.decode(Uint8Array.from(le));te.push(ve),le=[]}return te}}class Me extends se{decode_chain(C){return[C.join("")]}}class dt extends se{constructor(C){super(C),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(C){return C.map(te=>{let le=0;for(let Te=0;Te<this.start&&te[Te]===this.content;++Te){le=Te+1;continue}let ve=te.length;for(let Te=0;Te<this.stop;++Te){const He=te.length-Te-1;if(te[He]===this.content){ve=He;continue}else break}return te.slice(le,ve)})}}class at extends se{constructor(C){super(C),this.cleanup=C.cleanup}decode_chain(C){return C.map((te,le)=>(le!==0&&(te.startsWith(this.config.prefix)?te=te.replace(this.config.prefix,""):te=" "+te),this.cleanup&&(te=B(te)),te))}}class Wt extends se{constructor(C){super(C),this.byte_decoder=Je,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(C){const te=C.join(""),le=new Uint8Array([...te].map(Te=>this.byte_decoder[Te]));return this.text_decoder.decode(le)}decode_chain(C){const te=[];let le=[];for(const ve of C)this.added_tokens.find(Te=>Te.content===ve)!==void 0?(le.length>0&&(te.push(this.convert_tokens_to_string(le)),le=[]),te.push(ve)):le.push(ve);return le.length>0&&te.push(this.convert_tokens_to_string(le)),te}}class Tt extends se{constructor(C){super(C),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(C){if(C.length===0)return"";const te=[C[0]];for(let Te=1;Te<C.length;++Te)C[Te]!==te.at(-1)&&te.push(C[Te]);let ve=te.filter(Te=>Te!==this.pad_token).join("");return this.cleanup&&(ve=B(ve).replaceAll(this.word_delimiter_token," ").trim()),ve}decode_chain(C){return[this.convert_tokens_to_string(C)]}}class St extends se{constructor(C){super(C),this.decoders=C.decoders.map(te=>se.fromConfig(te))}decode_chain(C){return this.decoders.reduce((te,le)=>le.decode_chain(te),C)}}class Nt extends se{constructor(C){super(C),this.suffix=this.config.suffix}decode_chain(C){return C.map((te,le)=>te.replaceAll(this.suffix,le===C.length-1?"":" "))}}class Dt extends se{decode_chain(C){let te="";for(let le=1;le<C.length;le+=2)te+=C[le];return[te]}}class gn extends nt{constructor(C){super(),this.addPrefixSpace=C.add_prefix_space,this.replacement=C.replacement,this.strRep=C.str_rep||this.replacement,this.prepend_scheme=C.prepend_scheme??"always"}pre_tokenize_text(C,{section_index:te=void 0}={}){let le=C.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!le.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&te===0)&&(le=this.strRep+le),[le]}}class An extends se{constructor(C){super(C),this.addPrefixSpace=C.add_prefix_space,this.replacement=C.replacement}decode_chain(C){const te=[];for(let le=0;le<C.length;++le){let ve=C[le].replaceAll(this.replacement," ");this.addPrefixSpace&&le==0&&ve.startsWith(" ")&&(ve=ve.substring(1)),te.push(ve)}return te}}class pr extends Q{constructor(C){super(C),this.charsmap=C.precompiled_charsmap}normalize(C){return C=C.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),C=C.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),C.includes("～")?C=C.split("～").map(le=>le.normalize("NFKC")).join("～"):C=C.normalize("NFKC"),C}}class Xn extends nt{constructor(C){super(),this.tokenizers=C.pretokenizers.map(te=>nt.fromConfig(te))}pre_tokenize_text(C,te){return this.tokenizers.reduce((le,ve)=>ve.pre_tokenize(le,te),[C])}}class mr extends nt{constructor(C){super()}pre_tokenize_text(C,te){return C.match(/\w+|[^\w\s]+/g)||[]}}class Hr extends nt{constructor(C){super()}pre_tokenize_text(C,te){return V(C)}}class ft extends nt{constructor(C){super(),this.config=C,this.pattern=H(this.config.pattern),this.content=this.config.content}pre_tokenize_text(C,te){return this.pattern===null?[C]:[C.replaceAll(this.pattern,this.config.content)]}}const oe=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function Se(we,C,te,le){for(const ve of Object.keys(we)){const Te=C-we[ve].length,He=te(ve),Mt=new Array(Te).fill(He);we[ve]=le==="right"?(0,a.mergeArrays)(we[ve],Mt):(0,a.mergeArrays)(Mt,we[ve])}}function Re(we,C){for(const te of Object.keys(we))we[te].length=C}class Oe extends o.Callable{constructor(te,le){super();Ee(this,"return_token_type_ids",!1);Ee(this,"padding_side","right");this._tokenizer_config=le,this.normalizer=Q.fromConfig(te.normalizer),this.pre_tokenizer=nt.fromConfig(te.pre_tokenizer),this.model=xe.fromConfig(te.model,le),this.post_processor=Ge.fromConfig(te.post_processor),this.decoder=se.fromConfig(te.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const ve of te.added_tokens){const Te=new fe(ve);this.added_tokens.push(Te),this.model.tokens_to_ids.set(Te.content,Te.id),this.model.vocab[Te.id]=Te.content,Te.special&&(this.special_tokens.push(Te.content),this.all_special_ids.push(Te.id))}if(this.additional_special_tokens=le.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort((ve,Te)=>Te.content.length-ve.content.length).map(ve=>`${ve.lstrip?"\\s*":""}(${(0,a.escapeRegExp)(ve.content)})${ve.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=le.model_max_length,this.remove_space=le.remove_space,this.clean_up_tokenization_spaces=le.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=le.do_lowercase_and_remove_accent??!1,le.padding_side&&(this.padding_side=le.padding_side),this.legacy=!1,this.chat_template=le.chat_template??null,Array.isArray(this.chat_template)){const ve=Object.create(null);for(const{name:Te,template:He}of this.chat_template){if(typeof Te!="string"||typeof He!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');ve[Te]=He}this.chat_template=ve}this._compiled_template_cache=new Map}getToken(...te){for(const le of te){const ve=this._tokenizer_config[le];if(ve)if(typeof ve=="object"){if(ve.__type==="AddedToken")return ve.content;throw Error(`Unknown token: ${ve}`)}else return ve}return null}static async from_pretrained(te,{progress_callback:le=null,config:ve=null,cache_dir:Te=null,local_files_only:He=!1,revision:Mt="main",legacy:At=null}={}){const Pt=await E(te,{progress_callback:le,config:ve,cache_dir:Te,local_files_only:He,revision:Mt,legacy:At});return new this(...Pt)}_call(te,{text_pair:le=null,add_special_tokens:ve=!0,padding:Te=!1,truncation:He=null,max_length:Mt=null,return_tensor:At=!0,return_token_type_ids:Pt=null}={}){const Bt=Array.isArray(te);let sn;if(Bt){if(te.length===0)throw Error("text array must be non-empty");if(le!==null){if(Array.isArray(le)){if(te.length!==le.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");sn=te.map((hn,er)=>this._encode_plus(hn,{text_pair:le[er],add_special_tokens:ve,return_token_type_ids:Pt}))}else sn=te.map(hn=>this._encode_plus(hn,{add_special_tokens:ve,return_token_type_ids:Pt}))}else{if(te==null)throw Error("text may not be null or undefined");if(Array.isArray(le))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");sn=[this._encode_plus(te,{text_pair:le,add_special_tokens:ve,return_token_type_ids:Pt})]}if(Mt===null?Te==="max_length"?Mt=this.model_max_length:Mt=(0,p.max)(sn.map(hn=>hn.input_ids.length))[0]:He||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),Mt=Math.min(Mt,this.model_max_length??1/0),Te||He)for(let hn=0;hn<sn.length;++hn)sn[hn].input_ids.length!==Mt&&(sn[hn].input_ids.length>Mt?He&&Re(sn[hn],Mt):Te&&Se(sn[hn],Mt,er=>er==="input_ids"?this.pad_token_id:0,this.padding_side));const zn={};if(At){if(!(Te&&He)&&sn.some(er=>{var gr;for(const fn of Object.keys(er))if(er[fn].length!==((gr=sn[0][fn])==null?void 0:gr.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const hn=[sn.length,sn[0].input_ids.length];for(const er of Object.keys(sn[0]))zn[er]=new w.Tensor("int64",BigInt64Array.from(sn.flatMap(gr=>gr[er]).map(BigInt)),hn)}else{for(const hn of Object.keys(sn[0]))zn[hn]=sn.map(er=>er[hn]);if(!Bt)for(const hn of Object.keys(zn))zn[hn]=zn[hn][0]}return zn}_encode_text(te){return te===null?null:(this.added_tokens_regex?te.split(this.added_tokens_regex).filter(Te=>Te):[te]).map((Te,He)=>{if(this.added_tokens.find(At=>At.content===Te)!==void 0)return Te;{if(this.remove_space===!0&&(Te=Te.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(Te=O(Te)),this.normalizer!==null&&(Te=this.normalizer(Te)),Te.length===0)return[];const At=this.pre_tokenizer!==null?this.pre_tokenizer(Te,{section_index:He}):[Te];return this.model(At)}}).flat()}_encode_plus(te,{text_pair:le=null,add_special_tokens:ve=!0,return_token_type_ids:Te=null}={}){const{tokens:He,token_type_ids:Mt}=this._tokenize_helper(te,{pair:le,add_special_tokens:ve}),At=this.model.convert_tokens_to_ids(He),Pt={input_ids:At,attention_mask:new Array(At.length).fill(1)};return(Te??this.return_token_type_ids)&&Mt&&(Pt.token_type_ids=Mt),Pt}_tokenize_helper(te,{pair:le=null,add_special_tokens:ve=!1}={}){const Te=this._encode_text(te),He=this._encode_text(le);return this.post_processor?this.post_processor(Te,He,{add_special_tokens:ve}):{tokens:(0,a.mergeArrays)(Te??[],He??[])}}tokenize(te,{pair:le=null,add_special_tokens:ve=!1}={}){return this._tokenize_helper(te,{pair:le,add_special_tokens:ve}).tokens}encode(te,{text_pair:le=null,add_special_tokens:ve=!0,return_token_type_ids:Te=null}={}){return this._encode_plus(te,{text_pair:le,add_special_tokens:ve,return_token_type_ids:Te}).input_ids}batch_decode(te,le={}){return te instanceof w.Tensor&&(te=te.tolist()),te.map(ve=>this.decode(ve,le))}decode(te,le={}){if(te instanceof w.Tensor&&(te=Y(te)),!Array.isArray(te)||te.length===0||!(0,a.isIntegralNumber)(te[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(te,le)}decode_single(te,{skip_special_tokens:le=!1,clean_up_tokenization_spaces:ve=null}){let Te=this.model.convert_ids_to_tokens(te);le&&(Te=Te.filter(Mt=>!this.special_tokens.includes(Mt)));let He=this.decoder?this.decoder(Te):Te.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(He=He.replaceAll(this.decoder.end_of_word_suffix," "),le&&(He=He.trim())),(ve??this.clean_up_tokenization_spaces)&&(He=B(He)),He}get_chat_template({chat_template:te=null,tools:le=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const ve=this.chat_template;if(te!==null&&Object.hasOwn(ve,te))te=ve[te];else if(te===null)if(le!==null&&"tool_use"in ve)te=ve.tool_use;else if("default"in ve)te=ve.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(ve).sort()}.`)}else if(te===null)if(this.chat_template)te=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return te}apply_chat_template(te,{tools:le=null,documents:ve=null,chat_template:Te=null,add_generation_prompt:He=!1,tokenize:Mt=!0,padding:At=!1,truncation:Pt=!1,max_length:Bt=null,return_tensor:sn=!0,return_dict:zn=!1,tokenizer_kwargs:hn={},...er}={}){if(Te=this.get_chat_template({chat_template:Te,tools:le}),typeof Te!="string")throw Error(`chat_template must be a string, but got ${typeof Te}`);let gr=this._compiled_template_cache.get(Te);gr===void 0&&(gr=new y.Template(Te),this._compiled_template_cache.set(Te,gr));const fn=Object.create(null);for(const Nr of oe){const Kr=this.getToken(Nr);Kr&&(fn[Nr]=Kr)}const Ln=gr.render({messages:te,add_generation_prompt:He,tools:le,documents:ve,...fn,...er});if(Mt){const Nr=this._call(Ln,{add_special_tokens:!1,padding:At,truncation:Pt,max_length:Bt,return_tensor:sn,...hn});return zn?Nr:Nr.input_ids}return Ln}}class Ve extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class ut extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class xt extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class yt extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class $t extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class _t extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class Ut extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class Gt extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class Rt extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class Be extends Oe{}class Ne extends Oe{}class mt extends Oe{constructor(te,le){super(te,le);Ee(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Ht extends Oe{constructor(){super(...arguments);Ee(this,"return_token_type_ids",!0)}}class cn extends Oe{}class En extends Oe{}class Qn extends Oe{}class bn extends Oe{constructor(C,te){super(C,te),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(le=>this.languageRegex.test(le)),this.lang_to_token=le=>le}_build_translation_inputs(C,te,le){return hi(this,C,te,le)}}class Dn extends bn{}class xn extends Oe{}class si extends Oe{}const Zn="▁";class Ro extends Oe{constructor(te,le){super(te,le);Ee(this,"padding_side","left");this.legacy=le.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new gn({replacement:Zn,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(te){if(te===null)return null;if(this.legacy||te.length===0)return super._encode_text(te);let le=super._encode_text(Zn+te.replaceAll(Zn," "));return le.length>1&&le[0]===Zn&&this.special_tokens.includes(le[1])&&(le=le.slice(1)),le}}class cs extends Oe{}class Ji extends Oe{}class ds extends Oe{}class ps extends Oe{}class fs extends Oe{}class hs extends Oe{}class ms extends Oe{}class yo extends Oe{}class Zi extends Oe{}function hi(we,C,te,le){if(!("language_codes"in we)||!Array.isArray(we.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in we)||!(we.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in we)||typeof we.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const ve=le.src_lang,Te=le.tgt_lang;if(!we.language_codes.includes(Te))throw new Error(`Target language code "${Te}" is not valid. Must be one of: {${we.language_codes.join(", ")}}`);if(ve!==void 0){if(!we.language_codes.includes(ve))throw new Error(`Source language code "${ve}" is not valid. Must be one of: {${we.language_codes.join(", ")}}`);for(const He of we.post_processor.config.single)if("SpecialToken"in He&&we.languageRegex.test(He.SpecialToken.id)){He.SpecialToken.id=we.lang_to_token(ve);break}}return le.forced_bos_token_id=we.model.convert_tokens_to_ids([we.lang_to_token(Te)])[0],we._call(C,te)}class zi extends Oe{constructor(C,te){super(C,te),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(le=>this.languageRegex.test(le)),this.lang_to_token=le=>le}_build_translation_inputs(C,te,le){return hi(this,C,te,le)}}class Bo extends Oe{constructor(C,te){super(C,te),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(le=>this.languageRegex.test(le)).map(le=>le.slice(2,-2)),this.lang_to_token=le=>`__${le}__`}_build_translation_inputs(C,te,le){return hi(this,C,te,le)}}class Ei extends Oe{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(C,{return_timestamps:te=!1,return_language:le=!1,time_precision:ve=null,force_full_sequences:Te=!0}={}){if(ve===null)throw Error("Must specify time_precision");let He=null;const Mt=te==="word";function At(){return{language:He,timestamp:[null,null],text:""}}const Pt=[];let Bt=At(),sn=0;const zn=this.timestamp_begin;let hn=[],er=[],gr=!1,fn=null;const Ln=new Set(this.all_special_ids);for(const Ae of C){const _r=Ae.tokens,kr=Mt?Ae.token_timestamps:null;let mi=null,Li=zn;if("stride"in Ae){const[lr,vn,Nn]=Ae.stride;if(sn-=vn,fn=lr-Nn,vn&&(Li=vn/ve+zn),Nn)for(let Ft=_r.length-1;Ft>=0;--Ft){const Mn=Number(_r[Ft]);if(Mn>=zn){if(mi!==null&&(Mn-zn)*ve<fn)break;mi=Mn}}}let Zt=[],Ir=[];for(let lr=0;lr<_r.length;++lr){const vn=Number(_r[lr]);if(Ln.has(vn)){const Nn=this.decode([vn]),Ft=T.WHISPER_LANGUAGE_MAPPING.get(Nn.slice(2,-2));if(Ft!==void 0){if(He!==null&&Ft!==He&&!te){hn.push(Zt);const Mn=this.findLongestCommonSequence(hn)[0],bo=this.decode(Mn);Bt.text=bo,Pt.push(Bt),hn=[],Zt=[],Bt=At()}He=Bt.language=Ft}}else if(vn>=zn){const Nn=(vn-zn)*ve+sn,Ft=(0,p.round)(Nn,2);if(mi!==null&&vn>=mi)gr=!0;else if(gr||hn.length>0&&vn<Li)gr=!1;else if(Bt.timestamp[0]===null)Bt.timestamp[0]=Ft;else if(Ft!==Bt.timestamp[0]){Bt.timestamp[1]=Ft,hn.push(Zt),Mt&&er.push(Ir);const[Mn,bo]=this.findLongestCommonSequence(hn,er),eo=this.decode(Mn);Bt.text=eo,Mt&&(Bt.words=this.collateWordTimestamps(Mn,bo,He)),Pt.push(Bt),hn=[],Zt=[],er=[],Ir=[],Bt=At()}}else if(Zt.push(vn),Mt){let Nn=(0,p.round)(kr[lr]+sn,2),Ft;if(lr+1<kr.length){Ft=(0,p.round)(kr[lr+1]+sn,2);const Mn=this.decode([vn]);q.test(Mn)&&(Ft=(0,p.round)(Math.min(Nn+ve,Ft),2))}else Ft=null;Ir.push([Nn,Ft])}}if("stride"in Ae){const[lr,vn,Nn]=Ae.stride;sn+=lr-Nn}Zt.length>0?(hn.push(Zt),Mt&&er.push(Ir)):hn.every(lr=>lr.length===0)&&(Bt=At(),hn=[],Zt=[],er=[],Ir=[])}if(hn.length>0){if(Te&&te)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[Ae,_r]=this.findLongestCommonSequence(hn,er),kr=this.decode(Ae);Bt.text=kr,Mt&&(Bt.words=this.collateWordTimestamps(Ae,_r,He)),Pt.push(Bt)}let Nr=Object.create(null);const Kr=Pt.map(Ae=>Ae.text).join("");if(te||le){for(let Ae=0;Ae<Pt.length;++Ae){const _r=Pt[Ae];te||delete _r.timestamp,le||delete _r.language}if(Mt){const Ae=[];for(const _r of Pt)for(const kr of _r.words)Ae.push(kr);Nr={chunks:Ae}}else Nr={chunks:Pt}}return[Kr,Nr]}findLongestCommonSequence(C,te=null){let le=C[0],ve=le.length,Te=[];const He=Array.isArray(te)&&te.length>0;let Mt=He?[]:null,At=He?te[0]:null;for(let Pt=1;Pt<C.length;++Pt){const Bt=C[Pt];let sn=0,zn=[ve,ve,0,0];const hn=Bt.length;for(let Ae=1;Ae<ve+hn;++Ae){const _r=Math.max(0,ve-Ae),kr=Math.min(ve,ve+hn-Ae),mi=le.slice(_r,kr),Li=Math.max(0,Ae-ve),Zt=Math.min(hn,Ae),Ir=Bt.slice(Li,Zt);if(mi.length!==Ir.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let lr;He?lr=mi.filter((Ft,Mn)=>Ft===Ir[Mn]&&At[_r+Mn]<=te[Pt][Li+Mn]).length:lr=mi.filter((Ft,Mn)=>Ft===Ir[Mn]).length;const vn=Ae/1e4,Nn=lr/Ae+vn;lr>1&&Nn>sn&&(sn=Nn,zn=[_r,kr,Li,Zt])}const[er,gr,fn,Ln]=zn,Nr=Math.floor((gr+er)/2),Kr=Math.floor((Ln+fn)/2);Te.push(...le.slice(0,Nr)),le=Bt.slice(Kr),ve=le.length,He&&(Mt.push(...At.slice(0,Nr)),At=te[Pt].slice(Kr))}return Te.push(...le),He?(Mt.push(...At),[Te,Mt]):[Te,[]]}collateWordTimestamps(C,te,le){const[ve,Te,He]=this.combineTokensIntoWords(C,le),Mt=[];for(let At=0;At<ve.length;++At){const Pt=He[At];Mt.push({text:ve[At],timestamp:[te[Pt.at(0)][0],te[Pt.at(-1)][1]]})}return Mt}combineTokensIntoWords(C,te,le=`"'“¡¿([{-`,ve=`"'.。,，!！?？:：”)]}、`){te=te??"english";let Te,He,Mt;return["chinese","japanese","thai","lao","myanmar"].includes(te)?[Te,He,Mt]=this.splitTokensOnUnicode(C):[Te,He,Mt]=this.splitTokensOnSpaces(C),this.mergePunctuations(Te,He,Mt,le,ve)}decode(C,te){let le;return te!=null&&te.decode_with_timestamps?(C instanceof w.Tensor&&(C=Y(C)),le=this.decodeWithTimestamps(C,te)):le=super.decode(C,te),le}decodeWithTimestamps(C,te){const le=(te==null?void 0:te.time_precision)??.02,ve=Array.from(this.all_special_ids).at(-1)+1;let Te=[[]];for(let He of C)if(He=Number(He),He>=ve){const Mt=((He-ve)*le).toFixed(2);Te.push(`<|${Mt}|>`),Te.push([])}else Te[Te.length-1].push(He);return Te=Te.map(He=>typeof He=="string"?He:super.decode(He,te)),Te.join("")}splitTokensOnUnicode(C){const te=this.decode(C,{decode_with_timestamps:!0}),le="�",ve=[],Te=[],He=[];let Mt=[],At=[],Pt=0;for(let Bt=0;Bt<C.length;++Bt){const sn=C[Bt];Mt.push(sn),At.push(Bt);const zn=this.decode(Mt,{decode_with_timestamps:!0});(!zn.includes(le)||te[Pt+zn.indexOf(le)]===le)&&(ve.push(zn),Te.push(Mt),He.push(At),Mt=[],At=[],Pt+=zn.length)}return[ve,Te,He]}splitTokensOnSpaces(C){const[te,le,ve]=this.splitTokensOnUnicode(C),Te=[],He=[],Mt=[],At=new RegExp(`^[${z}]$`,"gu");for(let Pt=0;Pt<te.length;++Pt){const Bt=te[Pt],sn=le[Pt],zn=ve[Pt],hn=sn[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),er=Bt.startsWith(" "),gr=Bt.trim(),fn=At.test(gr);if(hn||er||fn||Te.length===0)Te.push(Bt),He.push(sn),Mt.push(zn);else{const Ln=Te.length-1;Te[Ln]+=Bt,He[Ln].push(...sn),Mt[Ln].push(...zn)}}return[Te,He,Mt]}mergePunctuations(C,te,le,ve,Te){const He=structuredClone(C),Mt=structuredClone(te),At=structuredClone(le);let Pt=He.length-2,Bt=He.length-1;for(;Pt>=0;)He[Pt].startsWith(" ")&&ve.includes(He[Pt].trim())?(He[Bt]=He[Pt]+He[Bt],Mt[Bt]=(0,a.mergeArrays)(Mt[Pt],Mt[Bt]),At[Bt]=(0,a.mergeArrays)(At[Pt],At[Bt]),He[Pt]="",Mt[Pt]=[],At[Pt]=[]):Bt=Pt,--Pt;for(Pt=0,Bt=1;Bt<He.length;)!He[Pt].endsWith(" ")&&Te.includes(He[Bt])?(He[Pt]+=He[Bt],Mt[Pt]=(0,a.mergeArrays)(Mt[Pt],Mt[Bt]),At[Pt]=(0,a.mergeArrays)(At[Pt],At[Bt]),He[Bt]="",Mt[Bt]=[],At[Bt]=[]):Pt=Bt,++Bt;return[He.filter(sn=>sn),Mt.filter(sn=>sn.length>0),At.filter(sn=>sn.length>0)]}}class No extends Oe{}class Uo extends Oe{}class jo extends Oe{}class nn extends Oe{constructor(C,te){super(C,te),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(le=>this.languageRegex.test(le)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(C){if(C===null)return null;const[te,...le]=C.trim().split(this.languageRegex);if(le.length===0)return super._encode_text(te);if(le.length===2){const[ve,Te]=le;return this.supported_language_codes.includes(ve)||console.warn(`Unsupported language code "${ve}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,a.mergeArrays)([ve],super._encode_text(Te))}}}class wo extends Oe{}class gs extends Oe{}class _s extends Oe{}class Vo extends Oe{}class ys extends Oe{}class ws extends Oe{constructor(C,te){super(C,te),this.decoder=new Dt({})}}class vo extends Oe{}class vs{static async from_pretrained(C,{progress_callback:te=null,config:le=null,cache_dir:ve=null,local_files_only:Te=!1,revision:He="main",legacy:Mt=null}={}){var zn;const[At,Pt]=await E(C,{progress_callback:te,config:le,cache_dir:ve,local_files_only:Te,revision:He,legacy:Mt}),Bt=((zn=Pt.tokenizer_class)==null?void 0:zn.replace(/Fast$/,""))??"PreTrainedTokenizer";let sn=this.TOKENIZER_CLASS_MAPPING[Bt];return sn||(console.warn(`Unknown tokenizer class "${Bt}", attempting to construct from base class.`),sn=Oe),new sn(At,Pt)}}Ee(vs,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:cn,DistilBertTokenizer:Be,CamembertTokenizer:Ne,DebertaTokenizer:$t,DebertaV2Tokenizer:_t,BertTokenizer:Ve,HerbertTokenizer:Ut,ConvBertTokenizer:Gt,RoFormerTokenizer:Rt,XLMTokenizer:mt,ElectraTokenizer:Ht,MobileBertTokenizer:xt,SqueezeBertTokenizer:yt,AlbertTokenizer:ut,GPT2Tokenizer:En,BartTokenizer:Qn,MBartTokenizer:bn,MBart50Tokenizer:Dn,RobertaTokenizer:xn,WhisperTokenizer:Ei,CodeGenTokenizer:No,CLIPTokenizer:Uo,SiglipTokenizer:jo,MarianTokenizer:nn,BloomTokenizer:si,NllbTokenizer:zi,M2M100Tokenizer:Bo,LlamaTokenizer:Ro,CodeLlamaTokenizer:cs,XLMRobertaTokenizer:Ji,MPNetTokenizer:ds,FalconTokenizer:ps,GPTNeoXTokenizer:fs,EsmTokenizer:hs,Wav2Vec2CTCTokenizer:wo,BlenderbotTokenizer:gs,BlenderbotSmallTokenizer:_s,SpeechT5Tokenizer:Vo,NougatTokenizer:ys,VitsTokenizer:ws,Qwen2Tokenizer:ms,GemmaTokenizer:yo,Grok1Tokenizer:Zi,CohereTokenizer:vo,PreTrainedTokenizer:Oe})},"./src/utils/audio.js":(e,t,r)=>{r.r(t),r.d(t,{hamming:()=>T,hanning:()=>y,mel_filter_bank:()=>F,read_audio:()=>w,spectrogram:()=>z,window_function:()=>q});var o=r("./src/utils/hub.js"),a=r("./src/utils/maths.js"),l=r("./src/utils/core.js"),p=r("./src/utils/tensor.js");async function w(L,pe){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const fe=await(await(0,o.getFile)(L)).arrayBuffer(),xe=new AudioContext({sampleRate:pe});typeof pe>"u"&&console.warn(`No sampling rate provided, using default of ${xe.sampleRate}Hz.`);const $e=await xe.decodeAudioData(fe);let Ce;if($e.numberOfChannels===2){const tt=Math.sqrt(2),Je=$e.getChannelData(0),it=$e.getChannelData(1);Ce=new Float32Array(Je.length);for(let be=0;be<$e.length;++be)Ce[be]=tt*(Je[be]+it[be])/2}else Ce=$e.getChannelData(0);return Ce}function _(L,pe){if(L<1)return new Float64Array;if(L===1)return new Float64Array([1]);const fe=1-pe,xe=2*Math.PI/(L-1),$e=new Float64Array(L);for(let Ce=0;Ce<L;++Ce)$e[Ce]=pe-fe*Math.cos(Ce*xe);return $e}function y(L){return _(L,.5)}function T(L){return _(L,.54)}const E={htk:L=>2595*Math.log10(1+L/700),kaldi:L=>1127*Math.log(1+L/700),slaney:(L,pe=1e3,fe=15,xe=27/Math.log(6.4))=>L>=pe?fe+Math.log(L/pe)*xe:3*L/200};function A(L,pe="htk"){const fe=E[pe];if(!fe)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof L=="number"?fe(L):L.map(xe=>fe(xe))}const H={htk:L=>700*(10**(L/2595)-1),kaldi:L=>700*(Math.exp(L/1127)-1),slaney:(L,pe=1e3,fe=15,xe=Math.log(6.4)/27)=>L>=fe?pe*Math.exp(xe*(L-fe)):200*L/3};function W(L,pe="htk"){const fe=H[pe];if(!fe)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof L=="number"?fe(L):L.map(xe=>fe(xe))}function Y(L,pe){const fe=Float64Array.from({length:pe.length-1},(tt,Je)=>pe[Je+1]-pe[Je]),xe=Array.from({length:L.length},()=>new Array(pe.length));for(let tt=0;tt<L.length;++tt){const Je=xe[tt];for(let it=0;it<pe.length;++it)Je[it]=pe[it]-L[tt]}const $e=pe.length-2,Ce=Array.from({length:$e},()=>new Array(L.length));for(let tt=0;tt<L.length;++tt){const Je=xe[tt];for(let it=0;it<$e;++it){const be=-Je[it]/fe[it],Q=Je[it+2]/fe[it+1];Ce[it][tt]=Math.max(0,Math.min(be,Q))}}return Ce}function B(L,pe,fe){const xe=(pe-L)/(fe-1);return Float64Array.from({length:fe},($e,Ce)=>L+xe*Ce)}function F(L,pe,fe,xe,$e,Ce=null,tt="htk",Je=!1){if(Ce!==null&&Ce!=="slaney")throw new Error('norm must be one of null or "slaney"');const it=A(fe,tt),be=A(xe,tt),Q=B(it,be,pe+2);let ae=W(Q,tt),ye;if(Je){const Ze=$e/(L*2);ye=A(Float64Array.from({length:L},(me,Qe)=>Qe*Ze),tt),ae=Q}else ye=B(0,Math.floor($e/2),L);const Pe=Y(ye,ae);if(Ce!==null&&Ce==="slaney")for(let Ze=0;Ze<pe;++Ze){const me=Pe[Ze],Qe=2/(ae[Ze+2]-ae[Ze]);for(let et=0;et<L;++et)me[et]*=Qe}return Pe}function O(L,pe,fe){const xe=new L.constructor(L.length+pe+fe),$e=L.length-1;for(let Ce=0;Ce<L.length;++Ce)xe[pe+Ce]=L[Ce];for(let Ce=1;Ce<=pe;++Ce)xe[pe-Ce]=L[(0,l.calculateReflectOffset)(Ce,$e)];for(let Ce=1;Ce<=fe;++Ce)xe[$e+pe+Ce]=L[(0,l.calculateReflectOffset)($e-Ce,$e)];return xe}function P(L,pe,fe,xe,$e){if(fe<=0)throw new Error("reference must be greater than zero");if(xe<=0)throw new Error("min_value must be greater than zero");fe=Math.max(xe,fe);const Ce=Math.log10(fe);for(let tt=0;tt<L.length;++tt)L[tt]=pe*Math.log10(Math.max(xe,L[tt])-Ce);if($e!==null){if($e<=0)throw new Error("db_range must be greater than zero");const tt=(0,a.max)(L)[0]-$e;for(let Je=0;Je<L.length;++Je)L[Je]=Math.max(L[Je],tt)}return L}function j(L,pe=1,fe=1e-5,xe=null){return P(L,20,pe,fe,xe)}function V(L,pe=1,fe=1e-10,xe=null){return P(L,10,pe,fe,xe)}async function z(L,pe,fe,xe,{fft_length:$e=null,power:Ce=1,center:tt=!0,pad_mode:Je="reflect",onesided:it=!0,preemphasis:be=null,mel_filters:Q=null,mel_floor:ae=1e-10,log_mel:ye=null,reference:Pe=1,min_value:Ze=1e-10,db_range:me=null,remove_dc_offset:Qe=null,min_num_frames:et=null,max_num_frames:Ie=null,do_pad:rt=!0,transpose:vt=!1}={}){const nt=pe.length;if($e===null&&($e=fe),fe>$e)throw Error(`frame_length (${fe}) may not be larger than fft_length (${$e})`);if(nt!==fe)throw new Error(`Length of the window (${nt}) must equal frame_length (${fe})`);if(xe<=0)throw new Error("hop_length must be greater than zero");if(Ce===null&&Q!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(tt){if(Je!=="reflect")throw new Error(`pad_mode="${Je}" not implemented yet.`);const se=Math.floor(($e-1)/2)+1;L=O(L,se,se)}let ce=Math.floor(1+Math.floor((L.length-fe)/xe));et!==null&&ce<et&&(ce=et);const ze=it?Math.floor($e/2)+1:$e;let Ye=ce,lt=ce;Ie!==null&&(Ie>ce?rt&&(lt=Ie):lt=Ye=Ie);const We=new a.FFT($e),Ge=new Float64Array($e),ht=new Float64Array(We.outputBufferSize),bt=new Float32Array(ze*lt);for(let se=0;se<Ye;++se){const J=se*xe,ue=Math.min(L.length-J,fe);ue!==fe&&Ge.fill(0,0,fe);for(let Me=0;Me<ue;++Me)Ge[Me]=L[J+Me];if(Qe){let Me=0;for(let at=0;at<ue;++at)Me+=Ge[at];const dt=Me/ue;for(let at=0;at<ue;++at)Ge[at]-=dt}if(be!==null){for(let Me=ue-1;Me>=1;--Me)Ge[Me]-=be*Ge[Me-1];Ge[0]*=1-be}for(let Me=0;Me<pe.length;++Me)Ge[Me]*=pe[Me];We.realTransform(ht,Ge);for(let Me=0;Me<ze;++Me){const dt=Me<<1;bt[Me*lt+se]=ht[dt]**2+ht[dt+1]**2}}if(Ce!==null&&Ce!==2){const se=2/Ce;for(let J=0;J<bt.length;++J)bt[J]**=se}const Ot=Q.length;let Ct=await(0,p.matmul)(new p.Tensor("float32",Q.flat(),[Ot,ze]),new p.Tensor("float32",bt,[ze,lt]));vt&&(Ct=Ct.transpose(1,0));const U=Ct.data;for(let se=0;se<U.length;++se)U[se]=Math.max(ae,U[se]);if(Ce!==null&&ye!==null){const se=Math.min(U.length,Ye*Ot);switch(ye){case"log":for(let J=0;J<se;++J)U[J]=Math.log(U[J]);break;case"log10":for(let J=0;J<se;++J)U[J]=Math.log10(U[J]);break;case"dB":if(Ce===1)j(U,Pe,Ze,me);else if(Ce===2)V(U,Pe,Ze,me);else throw new Error(`Cannot use log_mel option '${ye}' with power ${Ce}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${ye}'`)}}return Ct}function q(L,pe,{periodic:fe=!0,frame_length:xe=null,center:$e=!0}={}){const Ce=fe?L+1:L;let tt;switch(pe){case"boxcar":tt=new Float64Array(Ce).fill(1);break;case"hann":case"hann_window":tt=y(Ce);break;case"hamming":tt=T(Ce);break;case"povey":tt=y(Ce).map(Je=>Math.pow(Je,.85));break;default:throw new Error(`Unknown window type ${pe}.`)}if(fe&&(tt=tt.subarray(0,L)),xe===null)return tt;if(L>xe)throw new Error(`Length of the window (${L}) may not be larger than frame_length (${xe})`);return tt}},"./src/utils/constants.js":(e,t,r)=>{r.r(t),r.d(t,{GITHUB_ISSUE_URL:()=>o});const o="https://github.com/huggingface/transformers.js/issues/new/choose"},"./src/utils/core.js":(e,t,r)=>{r.r(t),r.d(t,{calculateDimensions:()=>_,calculateReflectOffset:()=>A,dispatchCallback:()=>o,escapeRegExp:()=>l,isIntegralNumber:()=>w,isTypedArray:()=>p,len:()=>W,mergeArrays:()=>T,pick:()=>H,pop:()=>y,product:()=>E,reverseDictionary:()=>a});function o(Y,B){Y&&Y(B)}function a(Y){return Object.fromEntries(Object.entries(Y).map(([B,F])=>[F,B]))}function l(Y){return Y.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function p(Y){var B,F,O;return((O=(F=(B=Y==null?void 0:Y.prototype)==null?void 0:B.__proto__)==null?void 0:F.constructor)==null?void 0:O.name)==="TypedArray"}function w(Y){return Number.isInteger(Y)||typeof Y=="bigint"}function _(Y){const B=[];let F=Y;for(;Array.isArray(F);)B.push(F.length),F=F[0];return B}function y(Y,B,F=void 0){const O=Y[B];if(O!==void 0)return delete Y[B],O;if(F===void 0)throw Error(`Key ${B} does not exist in object.`);return F}function T(...Y){return Array.prototype.concat.apply([],Y)}function E(...Y){return Y.reduce((B,F)=>B.flatMap(O=>F.map(P=>[O,P])))}function A(Y,B){return Math.abs((Y+B)%(2*B)-B)}function H(Y,B){return Object.assign({},...B.map(F=>{if(Y[F]!==void 0)return{[F]:Y[F]}}))}function W(Y){let B=0;for(const F of Y)++B;return B}},"./src/utils/data-structures.js":(e,t,r)=>{r.r(t),r.d(t,{CharTrie:()=>a,PriorityQueue:()=>o,TokenLattice:()=>p});class o{constructor(y=(E,A)=>E>A,T=1/0){this._heap=[],this._comparator=y,this._maxSize=T}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...y){return this.extend(y)}extend(y){for(const T of y)if(this.size<this._maxSize)this._heap.push(T),this._siftUp();else{const E=this._smallest();this._comparator(T,this._heap[E])&&(this._heap[E]=T,this._siftUpFrom(E))}return this.size}pop(){const y=this.peek(),T=this.size-1;return T>0&&this._swap(0,T),this._heap.pop(),this._siftDown(),y}replace(y){const T=this.peek();return this._heap[0]=y,this._siftDown(),T}_parent(y){return(y+1>>>1)-1}_left(y){return(y<<1)+1}_right(y){return y+1<<1}_greater(y,T){return this._comparator(this._heap[y],this._heap[T])}_swap(y,T){const E=this._heap[y];this._heap[y]=this._heap[T],this._heap[T]=E}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(y){for(;y>0&&this._greater(y,this._parent(y));)this._swap(y,this._parent(y)),y=this._parent(y)}_siftDown(){let y=0;for(;this._left(y)<this.size&&this._greater(this._left(y),y)||this._right(y)<this.size&&this._greater(this._right(y),y);){const T=this._right(y)<this.size&&this._greater(this._right(y),this._left(y))?this._right(y):this._left(y);this._swap(y,T),y=T}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class a{constructor(){this.root=l.default()}extend(y){for(const T of y)this.push(T)}push(y){let T=this.root;for(const E of y){let A=T.children.get(E);A===void 0&&(A=l.default(),T.children.set(E,A)),T=A}T.isLeaf=!0}*commonPrefixSearch(y){let T=this.root;if(T===void 0)return;let E="";for(const A of y){if(E+=A,T=T.children.get(A),T===void 0)return;T.isLeaf&&(yield E)}}}class l{constructor(y,T){this.isLeaf=y,this.children=T}static default(){return new l(!1,new Map)}}class p{constructor(y,T,E){this.chars=Array.from(y),this.len=this.chars.length,this.bosTokenId=T,this.eosTokenId=E,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const A=new w(this.bosTokenId,0,0,0,0),H=new w(this.eosTokenId,1,this.len,0,0);this.nodes.push(A.clone()),this.nodes.push(H.clone()),this.beginNodes[this.len].push(H),this.endNodes[0].push(A)}insert(y,T,E,A){const H=this.nodes.length,W=new w(A,H,y,T,E);this.beginNodes[y].push(W),this.endNodes[y+T].push(W),this.nodes.push(W)}viterbi(){const y=this.len;let T=0;for(;T<=y;){if(this.beginNodes[T].length==0)return[];for(let Y of this.beginNodes[T]){Y.prev=null;let B=0,F=null;for(let O of this.endNodes[T]){const P=O.backtraceScore+Y.score;(F===null||P>B)&&(F=O.clone(),B=P)}if(F!==null)Y.prev=F,Y.backtraceScore=B;else return[]}++T}const E=[],H=this.beginNodes[y][0].prev;if(H===null)return[];let W=H.clone();for(;W.prev!==null;)E.push(W.clone()),W=W.clone().prev.clone();return E.reverse(),E}piece(y){return this.chars.slice(y.pos,y.pos+y.length).join("")}tokens(){return this.viterbi().map(T=>this.piece(T))}tokenIds(){return this.viterbi().map(T=>T.tokenId)}}class w{constructor(y,T,E,A,H){this.tokenId=y,this.nodeId=T,this.pos=E,this.length=A,this.score=H,this.prev=null,this.backtraceScore=0}clone(){const y=new w(this.tokenId,this.nodeId,this.pos,this.length,this.score);return y.prev=this.prev,y.backtraceScore=this.backtraceScore,y}}},"./src/utils/devices.js":(e,t,r)=>{r.r(t),r.d(t,{DEVICE_TYPES:()=>o});const o=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,t,r)=>{r.r(t),r.d(t,{DATA_TYPES:()=>p,DEFAULT_DEVICE_DTYPE_MAPPING:()=>w,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>_,isWebGpuFp16Supported:()=>l});var o=r("./src/env.js"),a=r("./src/utils/devices.js");const l=function(){let y;return async function(){if(y===void 0)if(!o.apis.IS_WEBGPU_AVAILABLE)y=!1;else try{y=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{y=!1}return y}}(),p=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),w=Object.freeze({[a.DEVICE_TYPES.wasm]:p.q8}),_=Object.freeze({[p.fp32]:"",[p.fp16]:"_fp16",[p.int8]:"_int8",[p.uint8]:"_uint8",[p.q8]:"_quantized",[p.q4]:"_q4",[p.q4f16]:"_q4f16",[p.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,t,r)=>{r.r(t),r.d(t,{Callable:()=>o});const o=class{constructor(){let a=function(...l){return a._call(...l)};return Object.setPrototypeOf(a,new.target.prototype)}_call(...a){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,t,r)=>{r.r(t),r.d(t,{getFile:()=>T,getModelFile:()=>Y,getModelJSON:()=>B});var o=r("?7a2c"),a=r("?a42a"),l=r("./src/env.js"),p=r("./src/utils/core.js");const w={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class _{constructor(j){if(this.filePath=j,this.headers=new Headers,this.exists=o.existsSync(j),this.exists){this.status=200,this.statusText="OK";let V=o.statSync(j);this.headers.set("content-length",V.size.toString()),this.updateContentType();let z=this;this.body=new ReadableStream({start(q){z.arrayBuffer().then(L=>{q.enqueue(new Uint8Array(L)),q.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const j=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",w[j]??"application/octet-stream")}clone(){let j=new _(this.filePath);return j.exists=this.exists,j.status=this.status,j.statusText=this.statusText,j.headers=new Headers(this.headers),j}async arrayBuffer(){return(await o.promises.readFile(this.filePath)).buffer}async blob(){const j=await o.promises.readFile(this.filePath);return new Blob([j],{type:this.headers.get("content-type")})}async text(){return await o.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function y(P,j=null,V=null){let z;try{z=new URL(P)}catch{return!1}return!(j&&!j.includes(z.protocol)||V&&!V.includes(z.hostname))}async function T(P){var j;if(l.env.useFS&&!y(P,["http:","https:","blob:"]))return new _(P);if(typeof process<"u"&&((j=process==null?void 0:process.release)==null?void 0:j.name)==="node"){const V=!!(Qo!=null&&Qo.TESTING_REMOTELY),z=l.env.version,q=new Headers;if(q.set("User-Agent",`transformers.js/${z}; is_ci/${V};`),y(P,["http:","https:"],["huggingface.co","hf.co"])){const pe=(Qo==null?void 0:Qo.HF_TOKEN)??(Qo==null?void 0:Qo.HF_ACCESS_TOKEN);pe&&q.set("Authorization",`Bearer ${pe}`)}return fetch(P,{headers:q})}else return fetch(P)}const E={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function A(P,j,V){if(!V)return null;const z=E[P]??`Error (${P}) occurred while trying to load file`;throw Error(`${z}: "${j}".`)}class H{constructor(j){this.path=j}async match(j){let V=a.join(this.path,j),z=new _(V);if(z.exists)return z}async put(j,V){const z=Buffer.from(await V.arrayBuffer());let q=a.join(this.path,j);try{await o.promises.mkdir(a.dirname(q),{recursive:!0}),await o.promises.writeFile(q,z)}catch(L){console.warn("An error occurred while writing the file to cache:",L)}}}async function W(P,...j){for(let V of j)try{let z=await P.match(V);if(z)return z}catch{continue}}async function Y(P,j,V=!0,z={}){if(!l.env.allowLocalModels){if(z.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!l.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,p.dispatchCallback)(z.progress_callback,{status:"initiate",name:P,file:j});let q;if(!q&&l.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{q=await caches.open("transformers-cache")}catch(ye){console.warn("An error occurred while opening the browser cache:",ye)}}if(!q&&l.env.useFSCache&&(q=new H(z.cache_dir??l.env.cacheDir)),!q&&l.env.useCustomCache){if(!l.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!l.env.customCache.match||!l.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");q=l.env.customCache}const L=z.revision??"main";let pe=O(P,j),fe=O(l.env.localModelPath,pe),xe=O(l.env.remoteHost,l.env.remotePathTemplate.replaceAll("{model}",P).replaceAll("{revision}",encodeURIComponent(L)),j),$e=L==="main"?pe:O(P,L,j),Ce,tt=q instanceof H?$e:xe,Je=!1,it;q&&(it=await W(q,fe,tt));const be=it!==void 0;if(it===void 0){if(l.env.allowLocalModels)if(y(pe,["http:","https:"])){if(z.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${pe}.`);if(!l.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${pe}.`)}else try{it=await T(fe),Ce=fe}catch(Pe){console.warn(`Unable to load from local path "${fe}": "${Pe}"`)}if(it===void 0||it.status===404){if(z.local_files_only||!l.env.allowRemoteModels){if(V)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${fe}".`);return null}if(it=await T(xe),it.status!==200)return A(it.status,xe,V);Ce=tt}Je=q&&typeof Response<"u"&&it instanceof Response&&it.status===200}(0,p.dispatchCallback)(z.progress_callback,{status:"download",name:P,file:j});const Q={status:"progress",name:P,file:j};let ae;return z.progress_callback?be&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(ae=new Uint8Array(await it.arrayBuffer()),(0,p.dispatchCallback)(z.progress_callback,{...Q,progress:100,loaded:ae.length,total:ae.length})):ae=await F(it,ye=>{(0,p.dispatchCallback)(z.progress_callback,{...Q,...ye})}):ae=new Uint8Array(await it.arrayBuffer()),Je&&Ce&&await q.match(Ce)===void 0&&await q.put(Ce,new Response(ae,{headers:it.headers})).catch(ye=>{console.warn(`Unable to add response to browser cache: ${ye}.`)}),(0,p.dispatchCallback)(z.progress_callback,{status:"done",name:P,file:j}),ae}async function B(P,j,V=!0,z={}){let q=await Y(P,j,V,z);if(q===null)return{};let pe=new TextDecoder("utf-8").decode(q);return JSON.parse(pe)}async function F(P,j){const V=P.headers.get("Content-Length");V===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let z=parseInt(V??"0"),q=new Uint8Array(z),L=0;const pe=P.body.getReader();async function fe(){const{done:xe,value:$e}=await pe.read();if(xe)return;let Ce=L+$e.length;if(Ce>z){z=Ce;let Je=new Uint8Array(z);Je.set(q),q=Je}q.set($e,L),L=Ce;const tt=L/z*100;return j({progress:tt,loaded:L,total:z}),fe()}return await fe(),q}function O(...P){return P=P.map((j,V)=>(V&&(j=j.replace(new RegExp("^/"),"")),V!==P.length-1&&(j=j.replace(new RegExp("/$"),"")),j)),P.join("/")}},"./src/utils/image.js":(e,t,r)=>{r.r(t),r.d(t,{RawImage:()=>W});var o=r("./src/utils/hub.js"),a=r("./src/env.js"),l=r("./src/utils/tensor.js"),p=r("?2b25");const w=typeof self<"u",_=w&&self.constructor.name==="DedicatedWorkerGlobalScope";let y,T,E;if(w)y=(Y,B)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(Y,B)},E=self.createImageBitmap,T=self.ImageData;else if(p)E=async Y=>{const F=(await Y.metadata()).channels,{data:O,info:P}=await Y.rotate().raw().toBuffer({resolveWithObject:!0}),j=new W(new Uint8ClampedArray(O),P.width,P.height,P.channels);return F!==void 0&&F!==P.channels&&j.convert(F),j};else throw new Error("Unable to load image processing library.");const A={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},H=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class W{constructor(B,F,O,P){this.data=B,this.width=F,this.height=O,this.channels=P}get size(){return[this.width,this.height]}static async read(B){if(B instanceof W)return B;if(typeof B=="string"||B instanceof URL)return await this.fromURL(B);throw new Error(`Unsupported input type: ${typeof B}`)}static fromCanvas(B){if(!w)throw new Error("fromCanvas() is only supported in browser environments.");const O=B.getContext("2d").getImageData(0,0,B.width,B.height).data;return new W(O,B.width,B.height,4)}static async fromURL(B){const F=await(0,o.getFile)(B);if(F.status!==200)throw new Error(`Unable to read image from "${B}" (${F.status} ${F.statusText})`);const O=await F.blob();return this.fromBlob(O)}static async fromBlob(B){if(w){const F=await E(B),O=y(F.width,F.height).getContext("2d");return O.drawImage(F,0,0),new this(O.getImageData(0,0,F.width,F.height).data,F.width,F.height,4)}else{const F=p(await B.arrayBuffer());return await E(F)}}static fromTensor(B,F="CHW"){if(B.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${B.dims.length} dimensions.`);if(F==="CHW")B=B.transpose(1,2,0);else if(F!=="HWC")throw new Error(`Unsupported channel format: ${F}`);if(!(B.data instanceof Uint8ClampedArray||B.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${B.type}`);switch(B.dims[2]){case 1:case 2:case 3:case 4:return new W(B.data,B.dims[1],B.dims[0],B.dims[2]);default:throw new Error(`Unsupported number of channels: ${B.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const B=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let F=0,O=0;F<this.data.length;F+=this.channels){const P=this.data[F],j=this.data[F+1],V=this.data[F+2];B[O++]=Math.round(.2989*P+.587*j+.114*V)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(B,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const B=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let F=0,O=0;F<this.data.length;++F)B[O++]=this.data[F],B[O++]=this.data[F],B[O++]=this.data[F];break;case 4:for(let F=0,O=0;F<this.data.length;F+=4)B[O++]=this.data[F],B[O++]=this.data[F+1],B[O++]=this.data[F+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(B,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const B=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let F=0,O=0;F<this.data.length;++F)B[O++]=this.data[F],B[O++]=this.data[F],B[O++]=this.data[F],B[O++]=255;break;case 3:for(let F=0,O=0;F<this.data.length;F+=3)B[O++]=this.data[F],B[O++]=this.data[F+1],B[O++]=this.data[F+2],B[O++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(B,this.width,this.height,4)}async resize(B,F,{resample:O=2}={}){let P=A[O]??O;if(w){const j=this.channels,V=this.toCanvas(),z=y(B,F).getContext("2d");return z.drawImage(V,0,0,B,F),new W(z.getImageData(0,0,B,F).data,B,F,4).convert(j)}else{let j=this.toSharp();switch(P){case"box":case"hamming":(P==="box"||P==="hamming")&&(console.warn(`Resampling method ${P} is not yet supported. Using bilinear instead.`),P="bilinear");case"nearest":case"bilinear":case"bicubic":j=j.affine([B/this.width,0,0,F/this.height],{interpolator:P});break;case"lanczos":j=j.resize({width:B,height:F,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${P} is not supported.`)}return await E(j)}}async pad([B,F,O,P]){if(B=Math.max(B,0),F=Math.max(F,0),O=Math.max(O,0),P=Math.max(P,0),B===0&&F===0&&O===0&&P===0)return this;if(w){const j=this.channels,V=this.toCanvas(),z=this.width+B+F,q=this.height+O+P,L=y(z,q).getContext("2d");return L.drawImage(V,0,0,this.width,this.height,B,O,z,q),new W(L.getImageData(0,0,z,q).data,z,q,4).convert(j)}else{const j=this.toSharp().extend({left:B,right:F,top:O,bottom:P});return await E(j)}}async crop([B,F,O,P]){if(B=Math.max(B,0),F=Math.max(F,0),O=Math.min(O,this.width-1),P=Math.min(P,this.height-1),B===0&&F===0&&O===this.width-1&&P===this.height-1)return this;const j=O-B+1,V=P-F+1;if(w){const z=this.channels,q=this.toCanvas(),L=y(j,V).getContext("2d");return L.drawImage(q,B,F,j,V,0,0,j,V),new W(L.getImageData(0,0,j,V).data,j,V,4).convert(z)}else{const z=this.toSharp().extract({left:B,top:F,width:j,height:V});return await E(z)}}async center_crop(B,F){if(this.width===B&&this.height===F)return this;const O=(this.width-B)/2,P=(this.height-F)/2;if(w){const j=this.channels,V=this.toCanvas(),z=y(B,F).getContext("2d");let q=0,L=0,pe=0,fe=0;return O>=0?q=O:pe=-O,P>=0?L=P:fe=-P,z.drawImage(V,q,L,B,F,pe,fe,B,F),new W(z.getImageData(0,0,B,F).data,B,F,4).convert(j)}else{let j=this.toSharp();if(O>=0&&P>=0)j=j.extract({left:Math.floor(O),top:Math.floor(P),width:B,height:F});else if(O<=0&&P<=0){const V=Math.floor(-P),z=Math.floor(-O);j=j.extend({top:V,left:z,right:B-this.width-z,bottom:F-this.height-V})}else{let V=[0,0],z=0;P<0?(V[0]=Math.floor(-P),V[1]=F-this.height-V[0]):z=Math.floor(P);let q=[0,0],L=0;O<0?(q[0]=Math.floor(-O),q[1]=B-this.width-q[0]):L=Math.floor(O),j=j.extend({top:V[0],bottom:V[1],left:q[0],right:q[1]}).extract({left:L,top:z,width:B,height:F})}return await E(j)}}async toBlob(B="image/png",F=1){if(!w)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:B,quality:F})}toTensor(B="CHW"){let F=new l.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(B!=="HWC")if(B==="CHW")F=F.permute(2,0,1);else throw new Error(`Unsupported channel format: ${B}`);return F}toCanvas(){if(!w)throw new Error("toCanvas() is only supported in browser environments.");const B=this.clone().rgba(),F=y(B.width,B.height),O=new T(B.data,B.width,B.height);return F.getContext("2d").putImageData(O,0,0),F}_update(B,F,O,P=null){return this.data=B,this.width=F,this.height=O,P!==null&&(this.channels=P),this}clone(){return new W(this.data.slice(),this.width,this.height,this.channels)}convert(B){if(this.channels===B)return this;switch(B){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(B){if(w){if(_)throw new Error("Unable to save an image from a Web Worker.");const F=B.split(".").pop().toLowerCase(),O=H.get(F)??"image/png",P=await this.toBlob(O),j=URL.createObjectURL(P),V=document.createElement("a");V.href=j,V.download=B,V.click(),V.remove()}else{if(a.env.useFS)return await this.toSharp().toFile(B);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(w)throw new Error("toSharp() is only supported in server-side environments.");return p(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}},"./src/utils/maths.js":(e,t,r)=>{r.r(t),r.d(t,{FFT:()=>Y,bankers_round:()=>O,cos_sim:()=>_,dot:()=>w,dynamic_time_warping:()=>P,interpolate_data:()=>o,log_softmax:()=>p,magnitude:()=>y,max:()=>E,medianFilter:()=>B,min:()=>T,permute_data:()=>a,round:()=>F,softmax:()=>l});function o(j,[V,z,q],[L,pe],fe="bilinear",xe=!1){const $e=pe/q,Ce=L/z,tt=new j.constructor(L*pe*V),Je=z*q,it=L*pe;for(let be=0;be<L;++be)for(let Q=0;Q<pe;++Q){const ae=be*pe+Q,ye=(Q+.5)/$e-.5,Pe=(be+.5)/Ce-.5;let Ze=Math.floor(ye),me=Math.floor(Pe);const Qe=Math.min(Ze+1,q-1),et=Math.min(me+1,z-1);Ze=Math.max(Ze,0),me=Math.max(me,0);const Ie=ye-Ze,rt=Pe-me,vt=(1-Ie)*(1-rt),nt=Ie*(1-rt),ce=(1-Ie)*rt,ze=Ie*rt,Ye=me*q,lt=et*q,We=Ye+Ze,Ge=Ye+Qe,ht=lt+Ze,bt=lt+Qe;for(let Ot=0;Ot<V;++Ot){const Ct=Ot*Je;tt[Ot*it+ae]=vt*j[Ct+We]+nt*j[Ct+Ge]+ce*j[Ct+ht]+ze*j[Ct+bt]}}return tt}function a(j,V,z){const q=new Array(z.length),L=new Array(z.length);for(let xe=z.length-1,$e=1;xe>=0;--xe)L[xe]=$e,q[xe]=V[z[xe]],$e*=q[xe];const pe=z.map((xe,$e)=>L[z.indexOf($e)]),fe=new j.constructor(j.length);for(let xe=0;xe<j.length;++xe){let $e=0;for(let Ce=V.length-1,tt=xe;Ce>=0;--Ce)$e+=tt%V[Ce]*pe[Ce],tt=Math.floor(tt/V[Ce]);fe[$e]=j[xe]}return[fe,q]}function l(j){const V=E(j)[0],z=j.map(pe=>Math.exp(pe-V)),q=z.reduce((pe,fe)=>pe+fe,0);return z.map(pe=>pe/q)}function p(j){const V=E(j)[0];let z=0;for(let pe=0;pe<j.length;++pe)z+=Math.exp(j[pe]-V);const q=Math.log(z);return j.map(pe=>pe-V-q)}function w(j,V){let z=0;for(let q=0;q<j.length;++q)z+=j[q]*V[q];return z}function _(j,V){const z=w(j,V),q=y(j),L=y(V);return z/(q*L)}function y(j){return Math.sqrt(j.reduce((V,z)=>V+z*z,0))}function T(j){if(j.length===0)throw Error("Array must not be empty");let V=j[0],z=0;for(let q=1;q<j.length;++q)j[q]<V&&(V=j[q],z=q);return[V,z]}function E(j){if(j.length===0)throw Error("Array must not be empty");let V=j[0],z=0;for(let q=1;q<j.length;++q)j[q]>V&&(V=j[q],z=q);return[Number(V),z]}function A(j){return j>0&&(j&j-1)===0}class H{constructor(V){if(this.size=V|0,this.size<=1||!A(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=V<<1,this.table=new Float64Array(this.size*2);for(let q=0;q<this.table.length;q+=2){const L=Math.PI*q/this.size;this.table[q]=Math.cos(L),this.table[q+1]=-Math.sin(L)}let z=0;for(let q=1;this.size>q;q<<=1)++z;this._width=z%2===0?z-1:z,this._bitrev=new Int32Array(1<<this._width);for(let q=0;q<this._bitrev.length;++q){this._bitrev[q]=0;for(let L=0;L<this._width;L+=2){const pe=this._width-L-2;this._bitrev[q]|=(q>>>L&3)<<pe}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(V,z){const q=z||new Array(V.length>>>1);for(let L=0;L<V.length;L+=2)q[L>>>1]=V[L];return q}toComplexArray(V,z){const q=z||this.createComplexArray();for(let L=0;L<q.length;L+=2)q[L]=V[L>>>1],q[L+1]=0;return q}transform(V,z){if(V===z)throw new Error("Input and output buffers must be different");this._transform4(V,z,1)}realTransform(V,z){if(V===z)throw new Error("Input and output buffers must be different");this._realTransform4(V,z,1)}inverseTransform(V,z){if(V===z)throw new Error("Input and output buffers must be different");this._transform4(V,z,-1);for(let q=0;q<V.length;++q)V[q]/=this.size}_transform4(V,z,q){const L=this._csize;let fe=1<<this._width,xe=L/fe<<1,$e,Ce;const tt=this._bitrev;if(xe===4)for($e=0,Ce=0;$e<L;$e+=xe,++Ce){const it=tt[Ce];this._singleTransform2(z,V,$e,it,fe)}else for($e=0,Ce=0;$e<L;$e+=xe,++Ce){const it=tt[Ce];this._singleTransform4(z,V,$e,it,fe,q)}const Je=this.table;for(fe>>=2;fe>=2;fe>>=2){xe=L/fe<<1;const it=xe>>>2;for($e=0;$e<L;$e+=xe){const be=$e+it-1;for(let Q=$e,ae=0;Q<be;Q+=2,ae+=fe){const ye=Q,Pe=ye+it,Ze=Pe+it,me=Ze+it,Qe=V[ye],et=V[ye+1],Ie=V[Pe],rt=V[Pe+1],vt=V[Ze],nt=V[Ze+1],ce=V[me],ze=V[me+1],Ye=Je[ae],lt=q*Je[ae+1],We=Ie*Ye-rt*lt,Ge=Ie*lt+rt*Ye,ht=Je[2*ae],bt=q*Je[2*ae+1],Ot=vt*ht-nt*bt,Ct=vt*bt+nt*ht,U=Je[3*ae],se=q*Je[3*ae+1],J=ce*U-ze*se,ue=ce*se+ze*U,Me=Qe+Ot,dt=et+Ct,at=Qe-Ot,Wt=et-Ct,Tt=We+J,St=Ge+ue,Nt=q*(We-J),Dt=q*(Ge-ue);V[ye]=Me+Tt,V[ye+1]=dt+St,V[Pe]=at+Dt,V[Pe+1]=Wt-Nt,V[Ze]=Me-Tt,V[Ze+1]=dt-St,V[me]=at-Dt,V[me+1]=Wt+Nt}}}}_singleTransform2(V,z,q,L,pe){const fe=V[L],xe=V[L+1],$e=V[L+pe],Ce=V[L+pe+1];z[q]=fe+$e,z[q+1]=xe+Ce,z[q+2]=fe-$e,z[q+3]=xe-Ce}_singleTransform4(V,z,q,L,pe,fe){const xe=pe*2,$e=pe*3,Ce=V[L],tt=V[L+1],Je=V[L+pe],it=V[L+pe+1],be=V[L+xe],Q=V[L+xe+1],ae=V[L+$e],ye=V[L+$e+1],Pe=Ce+be,Ze=tt+Q,me=Ce-be,Qe=tt-Q,et=Je+ae,Ie=it+ye,rt=fe*(Je-ae),vt=fe*(it-ye);z[q]=Pe+et,z[q+1]=Ze+Ie,z[q+2]=me+vt,z[q+3]=Qe-rt,z[q+4]=Pe-et,z[q+5]=Ze-Ie,z[q+6]=me-vt,z[q+7]=Qe+rt}_realTransform4(V,z,q){const L=this._csize;let fe=1<<this._width,xe=L/fe<<1,$e,Ce;const tt=this._bitrev;if(xe===4)for($e=0,Ce=0;$e<L;$e+=xe,++Ce){const be=tt[Ce];this._singleRealTransform2(z,V,$e,be>>>1,fe>>>1)}else for($e=0,Ce=0;$e<L;$e+=xe,++Ce){const be=tt[Ce];this._singleRealTransform4(z,V,$e,be>>>1,fe>>>1,q)}const Je=this.table;for(fe>>=2;fe>=2;fe>>=2){xe=L/fe<<1;const be=xe>>>1,Q=be>>>1,ae=Q>>>1;for($e=0;$e<L;$e+=xe)for(let ye=0,Pe=0;ye<=ae;ye+=2,Pe+=fe){const Ze=$e+ye,me=Ze+Q,Qe=me+Q,et=Qe+Q,Ie=V[Ze],rt=V[Ze+1],vt=V[me],nt=V[me+1],ce=V[Qe],ze=V[Qe+1],Ye=V[et],lt=V[et+1],We=Ie,Ge=rt,ht=Je[Pe],bt=q*Je[Pe+1],Ot=vt*ht-nt*bt,Ct=vt*bt+nt*ht,U=Je[2*Pe],se=q*Je[2*Pe+1],J=ce*U-ze*se,ue=ce*se+ze*U,Me=Je[3*Pe],dt=q*Je[3*Pe+1],at=Ye*Me-lt*dt,Wt=Ye*dt+lt*Me,Tt=We+J,St=Ge+ue,Nt=We-J,Dt=Ge-ue,gn=Ot+at,An=Ct+Wt,pr=q*(Ot-at),Xn=q*(Ct-Wt);if(V[Ze]=Tt+gn,V[Ze+1]=St+An,V[me]=Nt+Xn,V[me+1]=Dt-pr,ye===0){V[Qe]=Tt-gn,V[Qe+1]=St-An;continue}if(ye===ae)continue;const mr=$e+Q-ye,Hr=$e+be-ye;V[mr]=Nt-q*Xn,V[mr+1]=-Dt-q*pr,V[Hr]=Tt-q*gn,V[Hr+1]=-St+q*An}}const it=L>>>1;for(let be=2;be<it;be+=2)V[L-be]=V[be],V[L-be+1]=-V[be+1]}_singleRealTransform2(V,z,q,L,pe){const fe=V[L],xe=V[L+pe];z[q]=fe+xe,z[q+1]=0,z[q+2]=fe-xe,z[q+3]=0}_singleRealTransform4(V,z,q,L,pe,fe){const xe=pe*2,$e=pe*3,Ce=V[L],tt=V[L+pe],Je=V[L+xe],it=V[L+$e],be=Ce+Je,Q=Ce-Je,ae=tt+it,ye=fe*(tt-it);z[q]=be+ae,z[q+1]=0,z[q+2]=Q,z[q+3]=-ye,z[q+4]=be-ae,z[q+5]=0,z[q+6]=Q,z[q+7]=ye}}class W{constructor(V){const z=2*(V-1),q=2*(2*V-1),L=2**Math.ceil(Math.log2(q));this.bufferSize=L,this._a=z;const pe=new Float64Array(q),fe=new Float64Array(L);this._chirpBuffer=new Float64Array(L),this._buffer1=new Float64Array(L),this._buffer2=new Float64Array(L),this._outBuffer1=new Float64Array(L),this._outBuffer2=new Float64Array(L);const xe=-2*Math.PI/V,$e=Math.cos(xe),Ce=Math.sin(xe);for(let tt=0;tt<q>>1;++tt){const Je=(tt+1-V)**2/2,it=Math.sqrt($e**2+Ce**2)**Je,be=Je*Math.atan2(Ce,$e),Q=2*tt;pe[Q]=it*Math.cos(be),pe[Q+1]=it*Math.sin(be),fe[Q]=pe[Q],fe[Q+1]=-pe[Q+1]}this._slicedChirpBuffer=pe.subarray(z,q),this._f=new H(L>>1),this._f.transform(this._chirpBuffer,fe)}_transform(V,z,q){const L=this._buffer1,pe=this._buffer2,fe=this._outBuffer1,xe=this._outBuffer2,$e=this._chirpBuffer,Ce=this._slicedChirpBuffer,tt=this._a;if(q)for(let Je=0;Je<Ce.length;Je+=2){const it=Je+1,be=Je>>1,Q=z[be];L[Je]=Q*Ce[Je],L[it]=Q*Ce[it]}else for(let Je=0;Je<Ce.length;Je+=2){const it=Je+1;L[Je]=z[Je]*Ce[Je]-z[it]*Ce[it],L[it]=z[Je]*Ce[it]+z[it]*Ce[Je]}this._f.transform(fe,L);for(let Je=0;Je<$e.length;Je+=2){const it=Je+1;pe[Je]=fe[Je]*$e[Je]-fe[it]*$e[it],pe[it]=fe[Je]*$e[it]+fe[it]*$e[Je]}this._f.inverseTransform(xe,pe);for(let Je=0;Je<xe.length;Je+=2){const it=xe[Je+tt],be=xe[Je+tt+1],Q=Ce[Je],ae=Ce[Je+1];V[Je]=it*Q-be*ae,V[Je+1]=it*ae+be*Q}}transform(V,z){this._transform(V,z,!1)}realTransform(V,z){this._transform(V,z,!0)}}class Y{constructor(V){this.fft_length=V,this.isPowerOfTwo=A(V),this.isPowerOfTwo?(this.fft=new H(V),this.outputBufferSize=2*V):(this.fft=new W(V),this.outputBufferSize=this.fft.bufferSize)}realTransform(V,z){this.fft.realTransform(V,z)}transform(V,z){this.fft.transform(V,z)}}function B(j,V){if(V%2===0||V<=0)throw new Error("Window size must be a positive odd number");const z=new j.constructor(j.length),q=new j.constructor(V),L=Math.floor(V/2);for(let pe=0;pe<j.length;++pe){let fe=0;for(let xe=-L;xe<=L;++xe){let $e=pe+xe;$e<0?$e=Math.abs($e):$e>=j.length&&($e=2*(j.length-1)-$e),q[fe++]=j[$e]}q.sort(),z[pe]=q[L]}return z}function F(j,V){const z=Math.pow(10,V);return Math.round(j*z)/z}function O(j){const V=Math.round(j);return Math.abs(j)%1===.5?V%2===0?V:V-1:V}function P(j){const V=j.length,z=j[0].length,q=[V+1,z+1],L=Array.from({length:q[0]},()=>Array(q[1]).fill(1/0));L[0][0]=0;const pe=Array.from({length:q[0]},()=>Array(q[1]).fill(-1));for(let tt=1;tt<q[1];++tt)for(let Je=1;Je<q[0];++Je){const it=L[Je-1][tt-1],be=L[Je-1][tt],Q=L[Je][tt-1];let ae,ye;it<be&&it<Q?(ae=it,ye=0):be<it&&be<Q?(ae=be,ye=1):(ae=Q,ye=2),L[Je][tt]=j[Je-1][tt-1]+ae,pe[Je][tt]=ye}for(let tt=0;tt<q[1];++tt)pe[0][tt]=2;for(let tt=0;tt<q[0];++tt)pe[tt][0]=1;let fe=V,xe=z,$e=[],Ce=[];for(;fe>0||xe>0;)switch($e.push(fe-1),Ce.push(xe-1),pe[fe][xe]){case 0:--fe,--xe;break;case 1:--fe;break;case 2:--xe;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${fe}, ${xe}]. Please file a bug report.`)}return $e.reverse(),Ce.reverse(),[$e,Ce]}},"./src/utils/tensor.js":(e,t,r)=>{r.r(t),r.d(t,{Tensor:()=>w,cat:()=>j,full:()=>fe,full_like:()=>xe,interpolate:()=>T,interpolate_4d:()=>E,layer_norm:()=>B,matmul:()=>A,mean:()=>q,mean_pooling:()=>Y,ones:()=>$e,ones_like:()=>Ce,permute:()=>y,quantize_embeddings:()=>it,rfft:()=>H,stack:()=>V,std_mean:()=>z,topk:()=>W,zeros:()=>tt,zeros_like:()=>Je});var o=r("./src/utils/maths.js"),a=r("./src/backends/onnx.js"),l=r("./src/ops/registry.js");const p=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class w{constructor(...Q){Ee(this,"ort_tensor");return(0,a.isONNXTensor)(Q[0])?this.ort_tensor=Q[0]:this.ort_tensor=new a.Tensor(Q[0],Q[1],Q[2]),new Proxy(this,{get:(ae,ye)=>{if(typeof ye=="string"){let Pe=Number(ye);if(Number.isInteger(Pe))return ae._getitem(Pe)}return ae[ye]},set:(ae,ye,Pe)=>ae[ye]=Pe})}get dims(){return this.ort_tensor.dims}set dims(Q){this.ort_tensor.dims=Q}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[Q,...ae]=this.dims;if(ae.length>0){const ye=ae.reduce((Pe,Ze)=>Pe*Ze);for(let Pe=0;Pe<Q;++Pe)yield this._subarray(Pe,ye,ae)}else yield*this.data}_getitem(Q){const[ae,...ye]=this.dims;if(Q=P(Q,ae),ye.length>0){const Pe=ye.reduce((Ze,me)=>Ze*me);return this._subarray(Q,Pe,ye)}else return new w(this.type,[this.data[Q]],ye)}indexOf(Q){const ae=this.data;for(let ye=0;ye<ae.length;++ye)if(ae[ye]==Q)return ye;return-1}_subarray(Q,ae,ye){const Pe=Q*ae,Ze=(Q+1)*ae,me="subarray"in this.data?this.data.subarray(Pe,Ze):this.data.slice(Pe,Ze);return new w(this.type,me,ye)}item(){const Q=this.data;if(Q.length!==1)throw new Error(`a Tensor with ${Q.length} elements cannot be converted to Scalar`);return Q[0]}tolist(){return _(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const Q=this.data;for(let ae=0;ae<Q.length;++ae)Q[ae]=1/(1+Math.exp(-Q[ae]));return this}map(Q){return this.clone().map_(Q)}map_(Q){const ae=this.data;for(let ye=0;ye<ae.length;++ye)ae[ye]=Q(ae[ye],ye,ae);return this}mul(Q){return this.clone().mul_(Q)}mul_(Q){const ae=this.data;for(let ye=0;ye<ae.length;++ye)ae[ye]*=Q;return this}div(Q){return this.clone().div_(Q)}div_(Q){const ae=this.data;for(let ye=0;ye<ae.length;++ye)ae[ye]/=Q;return this}add(Q){return this.clone().add_(Q)}add_(Q){const ae=this.data;for(let ye=0;ye<ae.length;++ye)ae[ye]+=Q;return this}sub(Q){return this.clone().sub_(Q)}sub_(Q){const ae=this.data;for(let ye=0;ye<ae.length;++ye)ae[ye]-=Q;return this}clone(){return new w(this.type,this.data.slice(),this.dims.slice())}slice(...Q){const ae=[],ye=[];for(let Ie=0;Ie<this.dims.length;++Ie){let rt=Q[Ie];if(rt==null)ye.push([0,this.dims[Ie]]),ae.push(this.dims[Ie]);else if(typeof rt=="number")rt=P(rt,this.dims[Ie],Ie),ye.push([rt,rt+1]);else if(Array.isArray(rt)&&rt.length===2){let[vt,nt]=rt;if(vt=vt===null?0:P(vt,this.dims[Ie],Ie,!1),nt=nt===null?this.dims[Ie]:P(nt,this.dims[Ie],Ie,!1),vt>nt)throw new Error(`Invalid slice: ${rt}`);const ce=[Math.max(vt,0),Math.min(nt,this.dims[Ie])];ye.push(ce),ae.push(ce[1]-ce[0])}else throw new Error(`Invalid slice: ${rt}`)}const Pe=ye.map(([Ie,rt])=>rt-Ie),Ze=Pe.reduce((Ie,rt)=>Ie*rt),me=this.data,Qe=new me.constructor(Ze),et=this.stride();for(let Ie=0;Ie<Ze;++Ie){let rt=0;for(let vt=Pe.length-1,nt=Ie;vt>=0;--vt){const ce=Pe[vt];rt+=(nt%ce+ye[vt][0])*et[vt],nt=Math.floor(nt/ce)}Qe[Ie]=me[rt]}return new w(this.type,Qe,ae)}permute(...Q){return y(this,Q)}transpose(...Q){return this.permute(...Q)}sum(Q=null,ae=!1){return this.norm(1,Q,ae)}norm(Q="fro",ae=null,ye=!1){if(Q==="fro")Q=2;else if(typeof Q=="string")throw Error(`Unsupported norm: ${Q}`);const Pe=this.data;if(ae===null){let Qe=Pe.reduce((et,Ie)=>et+Ie**Q,0)**(1/Q);return new w(this.type,[Qe],[])}ae=P(ae,this.dims.length);const Ze=this.dims.slice();Ze[ae]=1;const me=new Pe.constructor(Pe.length/this.dims[ae]);for(let Qe=0;Qe<Pe.length;++Qe){let et=0;for(let Ie=this.dims.length-1,rt=Qe,vt=1;Ie>=0;--Ie){const nt=this.dims[Ie];if(Ie!==ae){const ce=rt%nt;et+=ce*vt,vt*=Ze[Ie]}rt=Math.floor(rt/nt)}me[et]+=Pe[Qe]**Q}if(Q!==1)for(let Qe=0;Qe<me.length;++Qe)me[Qe]=me[Qe]**(1/Q);return ye||Ze.splice(ae,1),new w(this.type,me,Ze)}normalize_(Q=2,ae=1){ae=P(ae,this.dims.length);const ye=this.norm(Q,ae,!0),Pe=this.data,Ze=ye.data;for(let me=0;me<Pe.length;++me){let Qe=0;for(let et=this.dims.length-1,Ie=me,rt=1;et>=0;--et){const vt=this.dims[et];if(et!==ae){const nt=Ie%vt;Qe+=nt*rt,rt*=this.dims[et]}Ie=Math.floor(Ie/vt)}Pe[me]/=Ze[Qe]}return this}normalize(Q=2,ae=1){return this.clone().normalize_(Q,ae)}stride(){return L(this.dims)}squeeze(Q=null){return new w(this.type,this.data,F(this.dims,Q))}squeeze_(Q=null){return this.dims=F(this.dims,Q),this}unsqueeze(Q=null){return new w(this.type,this.data,O(this.dims,Q))}unsqueeze_(Q=null){return this.dims=O(this.dims,Q),this}flatten_(Q=0,ae=-1){ae=(ae+this.dims.length)%this.dims.length;let ye=this.dims.slice(0,Q),Pe=this.dims.slice(Q,ae+1),Ze=this.dims.slice(ae+1);return this.dims=[...ye,Pe.reduce((me,Qe)=>me*Qe,1),...Ze],this}flatten(Q=0,ae=-1){return this.clone().flatten_(Q,ae)}view(...Q){let ae=-1;for(let Pe=0;Pe<Q.length;++Pe)if(Q[Pe]===-1){if(ae!==-1)throw new Error("Only one dimension can be inferred");ae=Pe}const ye=this.data;if(ae!==-1){const Pe=Q.reduce((Ze,me,Qe)=>Qe!==ae?Ze*me:Ze,1);Q[ae]=ye.length/Pe}return new w(this.type,ye,Q)}neg_(){const Q=this.data;for(let ae=0;ae<Q.length;++ae)Q[ae]=-Q[ae];return this}neg(){return this.clone().neg_()}clamp_(Q,ae){const ye=this.data;for(let Pe=0;Pe<ye.length;++Pe)ye[Pe]=Math.min(Math.max(ye[Pe],Q),ae);return this}clamp(Q,ae){return this.clone().clamp_(Q,ae)}round_(){const Q=this.data;for(let ae=0;ae<Q.length;++ae)Q[ae]=Math.round(Q[ae]);return this}round(){return this.clone().round_()}mean(Q=null,ae=!1){return q(this,Q,ae)}to(Q){if(this.type===Q)return this;if(!p.hasOwnProperty(Q))throw new Error(`Unsupported type: ${Q}`);return new w(Q,p[Q].from(this.data),this.dims)}}function _(be,Q){const ae=be.length,ye=Q.reduce((Ze,me)=>Ze*me);if(ae!==ye)throw Error(`cannot reshape array of size ${ae} into shape (${Q})`);let Pe=be;for(let Ze=Q.length-1;Ze>=0;Ze--)Pe=Pe.reduce((me,Qe)=>{let et=me[me.length-1];return et.length<Q[Ze]?et.push(Qe):me.push([Qe]),me},[[]]);return Pe[0]}function y(be,Q){const[ae,ye]=(0,o.permute_data)(be.data,be.dims,Q);return new w(be.type,ae,ye)}function T(be,[Q,ae],ye="bilinear",Pe=!1){const Ze=be.dims.at(-3)??1,me=be.dims.at(-2),Qe=be.dims.at(-1);let et=(0,o.interpolate_data)(be.data,[Ze,me,Qe],[Q,ae],ye,Pe);return new w(be.type,et,[Ze,Q,ae])}async function E(be,{size:Q=null,mode:ae="bilinear"}={}){if(be.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!Q)throw new Error("`interpolate_4d` requires a `size` argument.");let ye;if(Q.length===2)ye=[...be.dims.slice(0,2),...Q];else if(Q.length===3)ye=[be.dims[0],...Q];else if(Q.length===4)ye=Q;else throw new Error("`size` must be of length 2, 3, or 4.");let Pe;if(ae==="bilinear")Pe=await l.TensorOpRegistry.bilinear_interpolate_4d;else if(ae==="bicubic")Pe=await l.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${ae}`);const Ze=new w("int64",new BigInt64Array(ye.map(BigInt)),[ye.length]);return await Pe({x:be,s:Ze})}async function A(be,Q){return await(await l.TensorOpRegistry.matmul)({a:be,b:Q})}async function H(be,Q){return await(await l.TensorOpRegistry.rfft)({x:be,a:Q})}async function W(be,Q){const ae=await l.TensorOpRegistry.top_k;return Q===null?Q=be.dims.at(-1):Q=Math.min(Q,be.dims.at(-1)),await ae({x:be,k:new w("int64",[BigInt(Q)],[1])})}function Y(be,Q){const ae=be.data,ye=Q.data,Pe=[be.dims[0],be.dims[2]],Ze=new ae.constructor(Pe[0]*Pe[1]),[me,Qe,et]=be.dims;let Ie=0;for(let rt=0;rt<me;++rt){const vt=rt*et*Qe;for(let nt=0;nt<et;++nt){let ce=0,ze=0;const Ye=rt*Qe,lt=vt+nt;for(let Ge=0;Ge<Qe;++Ge){const ht=Number(ye[Ye+Ge]);ze+=ht,ce+=ae[lt+Ge*et]*ht}const We=ce/ze;Ze[Ie++]=We}}return new w(be.type,Ze,Pe)}function B(be,Q,{eps:ae=1e-5}={}){if(be.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[ye,Pe]=be.dims;if(Q.length!==1&&Q[0]!==Pe)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[Ze,me]=z(be,1,0,!0),Qe=Ze.data,et=me.data,Ie=be.data,rt=new Ie.constructor(Ie.length);for(let vt=0;vt<ye;++vt){const nt=vt*Pe;for(let ce=0;ce<Pe;++ce){const ze=nt+ce;rt[ze]=(Ie[ze]-et[vt])/(Qe[vt]+ae)}}return new w(be.type,rt,be.dims)}function F(be,Q){return be=be.slice(),Q===null?be=be.filter(ae=>ae!==1):typeof Q=="number"?be[Q]===1&&be.splice(Q,1):Array.isArray(Q)&&(be=be.filter((ae,ye)=>ae!==1||!Q.includes(ye))),be}function O(be,Q){return Q=P(Q,be.length+1),be=be.slice(),be.splice(Q,0,1),be}function P(be,Q,ae=null,ye=!0){if(ye&&(be<-Q||be>=Q))throw new Error(`IndexError: index ${be} is out of bounds for dimension${ae===null?"":" "+ae} with size ${Q}`);return be<0&&(be=(be%Q+Q)%Q),be}function j(be,Q=0){Q=P(Q,be[0].dims.length);const ae=be[0].dims.slice();ae[Q]=be.reduce((me,Qe)=>me+Qe.dims[Q],0);const ye=ae.reduce((me,Qe)=>me*Qe,1),Pe=new be[0].data.constructor(ye),Ze=be[0].type;if(Q===0){let me=0;for(const Qe of be){const et=Qe.data;Pe.set(et,me),me+=et.length}}else{let me=0;for(let Qe=0;Qe<be.length;++Qe){const{data:et,dims:Ie}=be[Qe];for(let rt=0;rt<et.length;++rt){let vt=0;for(let nt=Ie.length-1,ce=rt,ze=1;nt>=0;--nt){const Ye=Ie[nt];let lt=ce%Ye;nt===Q&&(lt+=me),vt+=lt*ze,ze*=ae[nt],ce=Math.floor(ce/Ye)}Pe[vt]=et[rt]}me+=Ie[Q]}}return new w(Ze,Pe,ae)}function V(be,Q=0){return j(be.map(ae=>ae.unsqueeze(Q)),Q)}function z(be,Q=null,ae=1,ye=!1){const Pe=be.data,Ze=be.dims;if(Q===null){const nt=Pe.reduce((lt,We)=>lt+We,0)/Pe.length,ce=Math.sqrt(Pe.reduce((lt,We)=>lt+(We-nt)**2,0)/(Pe.length-ae)),ze=new w(be.type,[nt],[]);return[new w(be.type,[ce],[]),ze]}Q=P(Q,Ze.length);const me=q(be,Q,ye),Qe=me.data,et=Ze.slice();et[Q]=1;const Ie=new Pe.constructor(Pe.length/Ze[Q]);for(let vt=0;vt<Pe.length;++vt){let nt=0;for(let ce=Ze.length-1,ze=vt,Ye=1;ce>=0;--ce){const lt=Ze[ce];if(ce!==Q){const We=ze%lt;nt+=We*Ye,Ye*=et[ce]}ze=Math.floor(ze/lt)}Ie[nt]+=(Pe[vt]-Qe[nt])**2}for(let vt=0;vt<Ie.length;++vt)Ie[vt]=Math.sqrt(Ie[vt]/(Ze[Q]-ae));return ye||et.splice(Q,1),[new w(be.type,Ie,et),me]}function q(be,Q=null,ae=!1){const ye=be.data;if(Q===null){const Qe=ye.reduce((et,Ie)=>et+Ie,0);return new w(be.type,[Qe/ye.length],[])}const Pe=be.dims;Q=P(Q,Pe.length);const Ze=Pe.slice();Ze[Q]=1;const me=new ye.constructor(ye.length/Pe[Q]);for(let Qe=0;Qe<ye.length;++Qe){let et=0;for(let Ie=Pe.length-1,rt=Qe,vt=1;Ie>=0;--Ie){const nt=Pe[Ie];if(Ie!==Q){const ce=rt%nt;et+=ce*vt,vt*=Ze[Ie]}rt=Math.floor(rt/nt)}me[et]+=ye[Qe]}if(Pe[Q]!==1)for(let Qe=0;Qe<me.length;++Qe)me[Qe]=me[Qe]/Pe[Q];return ae||Ze.splice(Q,1),new w(be.type,me,Ze)}function L(be){const Q=new Array(be.length);for(let ae=be.length-1,ye=1;ae>=0;--ae)Q[ae]=ye,ye*=be[ae];return Q}function pe(be,Q,ae,ye){const Pe=be.reduce((Ze,me)=>Ze*me,1);return new w(ae,new ye(Pe).fill(Q),be)}function fe(be,Q){let ae,ye;if(typeof Q=="number")ae="float32",ye=Float32Array;else if(typeof Q=="bigint")ae="int64",ye=BigInt64Array;else throw new Error(`Unsupported data type: ${typeof Q}`);return pe(be,Q,ae,ye)}function xe(be,Q){return fe(be.dims,Q)}function $e(be){return pe(be,1n,"int64",BigInt64Array)}function Ce(be){return $e(be.dims)}function tt(be){return pe(be,0n,"int64",BigInt64Array)}function Je(be){return tt(be.dims)}function it(be,Q){if(be.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(be.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(Q))throw new Error("The precision must be either 'binary' or 'ubinary'");const ae=Q==="binary",ye=ae?"int8":"uint8",Pe=ae?Int8Array:Uint8Array,Ze=be.data,me=new Pe(Ze.length/8);for(let Qe=0;Qe<Ze.length;++Qe){const et=Ze[Qe]>0?1:0,Ie=Math.floor(Qe/8),rt=Qe%8;me[Ie]|=et<<7-rt,ae&&rt===0&&(me[Ie]-=128)}return new w(ye,me,[be.dims[0],be.dims[1]/8])}}},DM={};function ar(e){var t=DM[e];if(t!==void 0)return t.exports;var r=DM[e]={exports:{}};return I2[e](r,r.exports,ar),r.exports}ar.m=I2;(()=>{var e=Object.getPrototypeOf?r=>Object.getPrototypeOf(r):r=>r.__proto__,t;ar.t=function(r,o){if(o&1&&(r=this(r)),o&8||typeof r=="object"&&r&&(o&4&&r.__esModule||o&16&&typeof r.then=="function"))return r;var a=Object.create(null);ar.r(a);var l={};t=t||[null,e({}),e([]),e(e)];for(var p=o&2&&r;typeof p=="object"&&!~t.indexOf(p);p=e(p))Object.getOwnPropertyNames(p).forEach(w=>l[w]=()=>r[w]);return l.default=()=>r,ar.d(a,l),a}})();ar.d=(e,t)=>{for(var r in t)ar.o(t,r)&&!ar.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})};ar.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);ar.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};(()=>{var e;if(typeof import.meta.url=="string"&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),ar.p=e})();ar.b=new URL("./",import.meta.url);var M={};/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/ar.r(M);ar.d(M,{ASTFeatureExtractor:()=>on.ASTFeatureExtractor,ASTForAudioClassification:()=>D.ASTForAudioClassification,ASTModel:()=>D.ASTModel,ASTPreTrainedModel:()=>D.ASTPreTrainedModel,AlbertForMaskedLM:()=>D.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>D.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>D.AlbertForSequenceClassification,AlbertModel:()=>D.AlbertModel,AlbertPreTrainedModel:()=>D.AlbertPreTrainedModel,AlbertTokenizer:()=>mn.AlbertTokenizer,AudioClassificationPipeline:()=>or.AudioClassificationPipeline,AutoConfig:()=>Oy.AutoConfig,AutoModel:()=>D.AutoModel,AutoModelForAudioClassification:()=>D.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>D.AutoModelForAudioFrameClassification,AutoModelForCTC:()=>D.AutoModelForCTC,AutoModelForCausalLM:()=>D.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>D.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>D.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>D.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>D.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>D.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>D.AutoModelForImageSegmentation,AutoModelForImageToImage:()=>D.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>D.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>D.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>D.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>D.AutoModelForObjectDetection,AutoModelForQuestionAnswering:()=>D.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>D.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>D.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>D.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>D.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>D.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>D.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>D.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>D.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>D.AutoModelForVision2Seq,AutoModelForXVector:()=>D.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>D.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>on.AutoProcessor,AutoTokenizer:()=>mn.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>or.AutomaticSpeechRecognitionPipeline,BartForConditionalGeneration:()=>D.BartForConditionalGeneration,BartForSequenceClassification:()=>D.BartForSequenceClassification,BartModel:()=>D.BartModel,BartPretrainedModel:()=>D.BartPretrainedModel,BartTokenizer:()=>mn.BartTokenizer,BaseModelOutput:()=>D.BaseModelOutput,BaseStreamer:()=>Dy.BaseStreamer,BeitFeatureExtractor:()=>on.BeitFeatureExtractor,BeitForImageClassification:()=>D.BeitForImageClassification,BeitModel:()=>D.BeitModel,BeitPreTrainedModel:()=>D.BeitPreTrainedModel,BertForMaskedLM:()=>D.BertForMaskedLM,BertForQuestionAnswering:()=>D.BertForQuestionAnswering,BertForSequenceClassification:()=>D.BertForSequenceClassification,BertForTokenClassification:()=>D.BertForTokenClassification,BertModel:()=>D.BertModel,BertPreTrainedModel:()=>D.BertPreTrainedModel,BertTokenizer:()=>mn.BertTokenizer,BitImageProcessor:()=>on.BitImageProcessor,BlenderbotForConditionalGeneration:()=>D.BlenderbotForConditionalGeneration,BlenderbotModel:()=>D.BlenderbotModel,BlenderbotPreTrainedModel:()=>D.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>D.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>D.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>D.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>mn.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>mn.BlenderbotTokenizer,BloomForCausalLM:()=>D.BloomForCausalLM,BloomModel:()=>D.BloomModel,BloomPreTrainedModel:()=>D.BloomPreTrainedModel,BloomTokenizer:()=>mn.BloomTokenizer,CLIPFeatureExtractor:()=>on.CLIPFeatureExtractor,CLIPImageProcessor:()=>on.CLIPImageProcessor,CLIPModel:()=>D.CLIPModel,CLIPPreTrainedModel:()=>D.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>D.CLIPSegForImageSegmentation,CLIPSegModel:()=>D.CLIPSegModel,CLIPSegPreTrainedModel:()=>D.CLIPSegPreTrainedModel,CLIPTextModel:()=>D.CLIPTextModel,CLIPTextModelWithProjection:()=>D.CLIPTextModelWithProjection,CLIPTokenizer:()=>mn.CLIPTokenizer,CLIPVisionModel:()=>D.CLIPVisionModel,CLIPVisionModelWithProjection:()=>D.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>D.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>D.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>D.CamembertForSequenceClassification,CamembertForTokenClassification:()=>D.CamembertForTokenClassification,CamembertModel:()=>D.CamembertModel,CamembertPreTrainedModel:()=>D.CamembertPreTrainedModel,CamembertTokenizer:()=>mn.CamembertTokenizer,CausalLMOutput:()=>D.CausalLMOutput,CausalLMOutputWithPast:()=>D.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>on.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>D.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>D.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>D.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>on.ClapFeatureExtractor,ClapModel:()=>D.ClapModel,ClapPreTrainedModel:()=>D.ClapPreTrainedModel,ClapTextModelWithProjection:()=>D.ClapTextModelWithProjection,CodeGenForCausalLM:()=>D.CodeGenForCausalLM,CodeGenModel:()=>D.CodeGenModel,CodeGenPreTrainedModel:()=>D.CodeGenPreTrainedModel,CodeGenTokenizer:()=>mn.CodeGenTokenizer,CodeLlamaTokenizer:()=>mn.CodeLlamaTokenizer,CohereForCausalLM:()=>D.CohereForCausalLM,CohereModel:()=>D.CohereModel,CoherePreTrainedModel:()=>D.CoherePreTrainedModel,CohereTokenizer:()=>mn.CohereTokenizer,ConvBertForMaskedLM:()=>D.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>D.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>D.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>D.ConvBertForTokenClassification,ConvBertModel:()=>D.ConvBertModel,ConvBertPreTrainedModel:()=>D.ConvBertPreTrainedModel,ConvBertTokenizer:()=>mn.ConvBertTokenizer,ConvNextFeatureExtractor:()=>on.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>D.ConvNextForImageClassification,ConvNextImageProcessor:()=>on.ConvNextImageProcessor,ConvNextModel:()=>D.ConvNextModel,ConvNextPreTrainedModel:()=>D.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>D.ConvNextV2ForImageClassification,ConvNextV2Model:()=>D.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>D.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>on.DPTFeatureExtractor,DPTForDepthEstimation:()=>D.DPTForDepthEstimation,DPTImageProcessor:()=>on.DPTImageProcessor,DPTModel:()=>D.DPTModel,DPTPreTrainedModel:()=>D.DPTPreTrainedModel,DebertaForMaskedLM:()=>D.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>D.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>D.DebertaForSequenceClassification,DebertaForTokenClassification:()=>D.DebertaForTokenClassification,DebertaModel:()=>D.DebertaModel,DebertaPreTrainedModel:()=>D.DebertaPreTrainedModel,DebertaTokenizer:()=>mn.DebertaTokenizer,DebertaV2ForMaskedLM:()=>D.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>D.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>D.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>D.DebertaV2ForTokenClassification,DebertaV2Model:()=>D.DebertaV2Model,DebertaV2PreTrainedModel:()=>D.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>mn.DebertaV2Tokenizer,DecisionTransformerModel:()=>D.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>D.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>on.DeiTFeatureExtractor,DeiTForImageClassification:()=>D.DeiTForImageClassification,DeiTModel:()=>D.DeiTModel,DeiTPreTrainedModel:()=>D.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>D.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>D.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>or.DepthEstimationPipeline,DepthProForDepthEstimation:()=>D.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>D.DepthProPreTrainedModel,DetrFeatureExtractor:()=>on.DetrFeatureExtractor,DetrForObjectDetection:()=>D.DetrForObjectDetection,DetrForSegmentation:()=>D.DetrForSegmentation,DetrModel:()=>D.DetrModel,DetrObjectDetectionOutput:()=>D.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>D.DetrPreTrainedModel,DetrSegmentationOutput:()=>D.DetrSegmentationOutput,Dinov2ForImageClassification:()=>D.Dinov2ForImageClassification,Dinov2Model:()=>D.Dinov2Model,Dinov2PreTrainedModel:()=>D.Dinov2PreTrainedModel,DistilBertForMaskedLM:()=>D.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>D.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>D.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>D.DistilBertForTokenClassification,DistilBertModel:()=>D.DistilBertModel,DistilBertPreTrainedModel:()=>D.DistilBertPreTrainedModel,DistilBertTokenizer:()=>mn.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>or.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>on.DonutFeatureExtractor,DonutImageProcessor:()=>on.DonutImageProcessor,DonutSwinModel:()=>D.DonutSwinModel,DonutSwinPreTrainedModel:()=>D.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>D.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>on.EfficientNetImageProcessor,EfficientNetModel:()=>D.EfficientNetModel,EfficientNetPreTrainedModel:()=>D.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>D.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>D.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>D.ElectraForSequenceClassification,ElectraForTokenClassification:()=>D.ElectraForTokenClassification,ElectraModel:()=>D.ElectraModel,ElectraPreTrainedModel:()=>D.ElectraPreTrainedModel,ElectraTokenizer:()=>mn.ElectraTokenizer,EosTokenCriteria:()=>Df.EosTokenCriteria,EsmForMaskedLM:()=>D.EsmForMaskedLM,EsmForSequenceClassification:()=>D.EsmForSequenceClassification,EsmForTokenClassification:()=>D.EsmForTokenClassification,EsmModel:()=>D.EsmModel,EsmPreTrainedModel:()=>D.EsmPreTrainedModel,EsmTokenizer:()=>mn.EsmTokenizer,FFT:()=>vi.FFT,FalconForCausalLM:()=>D.FalconForCausalLM,FalconModel:()=>D.FalconModel,FalconPreTrainedModel:()=>D.FalconPreTrainedModel,FalconTokenizer:()=>mn.FalconTokenizer,FastViTForImageClassification:()=>D.FastViTForImageClassification,FastViTModel:()=>D.FastViTModel,FastViTPreTrainedModel:()=>D.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>or.FeatureExtractionPipeline,FeatureExtractor:()=>on.FeatureExtractor,FillMaskPipeline:()=>or.FillMaskPipeline,Florence2ForConditionalGeneration:()=>D.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>D.Florence2PreTrainedModel,Florence2Processor:()=>on.Florence2Processor,GLPNFeatureExtractor:()=>on.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>D.GLPNForDepthEstimation,GLPNModel:()=>D.GLPNModel,GLPNPreTrainedModel:()=>D.GLPNPreTrainedModel,GPT2LMHeadModel:()=>D.GPT2LMHeadModel,GPT2Model:()=>D.GPT2Model,GPT2PreTrainedModel:()=>D.GPT2PreTrainedModel,GPT2Tokenizer:()=>mn.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>D.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>D.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>D.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>D.GPTJForCausalLM,GPTJModel:()=>D.GPTJModel,GPTJPreTrainedModel:()=>D.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>D.GPTNeoForCausalLM,GPTNeoModel:()=>D.GPTNeoModel,GPTNeoPreTrainedModel:()=>D.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>D.GPTNeoXForCausalLM,GPTNeoXModel:()=>D.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>D.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>mn.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>D.Gemma2ForCausalLM,Gemma2Model:()=>D.Gemma2Model,Gemma2PreTrainedModel:()=>D.Gemma2PreTrainedModel,GemmaForCausalLM:()=>D.GemmaForCausalLM,GemmaModel:()=>D.GemmaModel,GemmaPreTrainedModel:()=>D.GemmaPreTrainedModel,GemmaTokenizer:()=>mn.GemmaTokenizer,GraniteForCausalLM:()=>D.GraniteForCausalLM,GraniteModel:()=>D.GraniteModel,GranitePreTrainedModel:()=>D.GranitePreTrainedModel,Grok1Tokenizer:()=>mn.Grok1Tokenizer,GroupViTModel:()=>D.GroupViTModel,GroupViTPreTrainedModel:()=>D.GroupViTPreTrainedModel,HerbertTokenizer:()=>mn.HerbertTokenizer,HieraForImageClassification:()=>D.HieraForImageClassification,HieraModel:()=>D.HieraModel,HieraPreTrainedModel:()=>D.HieraPreTrainedModel,HubertForCTC:()=>D.HubertForCTC,HubertForSequenceClassification:()=>D.HubertForSequenceClassification,HubertModel:()=>D.HubertModel,HubertPreTrainedModel:()=>D.HubertPreTrainedModel,ImageClassificationPipeline:()=>or.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>or.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>on.ImageFeatureExtractor,ImageMattingOutput:()=>D.ImageMattingOutput,ImageSegmentationPipeline:()=>or.ImageSegmentationPipeline,ImageToImagePipeline:()=>or.ImageToImagePipeline,ImageToTextPipeline:()=>or.ImageToTextPipeline,InterruptableStoppingCriteria:()=>Df.InterruptableStoppingCriteria,JAISLMHeadModel:()=>D.JAISLMHeadModel,JAISModel:()=>D.JAISModel,JAISPreTrainedModel:()=>D.JAISPreTrainedModel,LlamaForCausalLM:()=>D.LlamaForCausalLM,LlamaModel:()=>D.LlamaModel,LlamaPreTrainedModel:()=>D.LlamaPreTrainedModel,LlamaTokenizer:()=>mn.LlamaTokenizer,LlavaForConditionalGeneration:()=>D.LlavaForConditionalGeneration,LlavaPreTrainedModel:()=>D.LlavaPreTrainedModel,LongT5ForConditionalGeneration:()=>D.LongT5ForConditionalGeneration,LongT5Model:()=>D.LongT5Model,LongT5PreTrainedModel:()=>D.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>D.M2M100ForConditionalGeneration,M2M100Model:()=>D.M2M100Model,M2M100PreTrainedModel:()=>D.M2M100PreTrainedModel,M2M100Tokenizer:()=>mn.M2M100Tokenizer,MBart50Tokenizer:()=>mn.MBart50Tokenizer,MBartForCausalLM:()=>D.MBartForCausalLM,MBartForConditionalGeneration:()=>D.MBartForConditionalGeneration,MBartForSequenceClassification:()=>D.MBartForSequenceClassification,MBartModel:()=>D.MBartModel,MBartPreTrainedModel:()=>D.MBartPreTrainedModel,MBartTokenizer:()=>mn.MBartTokenizer,MPNetForMaskedLM:()=>D.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>D.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>D.MPNetForSequenceClassification,MPNetForTokenClassification:()=>D.MPNetForTokenClassification,MPNetModel:()=>D.MPNetModel,MPNetPreTrainedModel:()=>D.MPNetPreTrainedModel,MPNetTokenizer:()=>mn.MPNetTokenizer,MT5ForConditionalGeneration:()=>D.MT5ForConditionalGeneration,MT5Model:()=>D.MT5Model,MT5PreTrainedModel:()=>D.MT5PreTrainedModel,MarianMTModel:()=>D.MarianMTModel,MarianModel:()=>D.MarianModel,MarianPreTrainedModel:()=>D.MarianPreTrainedModel,MarianTokenizer:()=>mn.MarianTokenizer,MaskFormerFeatureExtractor:()=>on.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>D.MaskFormerForInstanceSegmentation,MaskFormerModel:()=>D.MaskFormerModel,MaskFormerPreTrainedModel:()=>D.MaskFormerPreTrainedModel,MaskedLMOutput:()=>D.MaskedLMOutput,MaxLengthCriteria:()=>Df.MaxLengthCriteria,MistralForCausalLM:()=>D.MistralForCausalLM,MistralModel:()=>D.MistralModel,MistralPreTrainedModel:()=>D.MistralPreTrainedModel,MobileBertForMaskedLM:()=>D.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>D.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>D.MobileBertForSequenceClassification,MobileBertModel:()=>D.MobileBertModel,MobileBertPreTrainedModel:()=>D.MobileBertPreTrainedModel,MobileBertTokenizer:()=>mn.MobileBertTokenizer,MobileNetV1FeatureExtractor:()=>on.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>D.MobileNetV1ForImageClassification,MobileNetV1Model:()=>D.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>D.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>on.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>D.MobileNetV2ForImageClassification,MobileNetV2Model:()=>D.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>D.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>on.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>D.MobileNetV3ForImageClassification,MobileNetV3Model:()=>D.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>D.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>on.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>D.MobileNetV4ForImageClassification,MobileNetV4Model:()=>D.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>D.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>on.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>D.MobileViTForImageClassification,MobileViTImageProcessor:()=>on.MobileViTImageProcessor,MobileViTModel:()=>D.MobileViTModel,MobileViTPreTrainedModel:()=>D.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>D.MobileViTV2ForImageClassification,MobileViTV2Model:()=>D.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>D.MobileViTV2PreTrainedModel,ModelOutput:()=>D.ModelOutput,Moondream1ForConditionalGeneration:()=>D.Moondream1ForConditionalGeneration,MptForCausalLM:()=>D.MptForCausalLM,MptModel:()=>D.MptModel,MptPreTrainedModel:()=>D.MptPreTrainedModel,MusicgenForCausalLM:()=>D.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>D.MusicgenForConditionalGeneration,MusicgenModel:()=>D.MusicgenModel,MusicgenPreTrainedModel:()=>D.MusicgenPreTrainedModel,NllbTokenizer:()=>mn.NllbTokenizer,NomicBertModel:()=>D.NomicBertModel,NomicBertPreTrainedModel:()=>D.NomicBertPreTrainedModel,NougatImageProcessor:()=>on.NougatImageProcessor,NougatTokenizer:()=>mn.NougatTokenizer,OPTForCausalLM:()=>D.OPTForCausalLM,OPTModel:()=>D.OPTModel,OPTPreTrainedModel:()=>D.OPTPreTrainedModel,ObjectDetectionPipeline:()=>or.ObjectDetectionPipeline,OpenELMForCausalLM:()=>D.OpenELMForCausalLM,OpenELMModel:()=>D.OpenELMModel,OpenELMPreTrainedModel:()=>D.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>on.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>D.OwlViTForObjectDetection,OwlViTModel:()=>D.OwlViTModel,OwlViTPreTrainedModel:()=>D.OwlViTPreTrainedModel,OwlViTProcessor:()=>on.OwlViTProcessor,Owlv2ForObjectDetection:()=>D.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>on.Owlv2ImageProcessor,Owlv2Model:()=>D.Owlv2Model,Owlv2PreTrainedModel:()=>D.Owlv2PreTrainedModel,Phi3ForCausalLM:()=>D.Phi3ForCausalLM,Phi3Model:()=>D.Phi3Model,Phi3PreTrainedModel:()=>D.Phi3PreTrainedModel,PhiForCausalLM:()=>D.PhiForCausalLM,PhiModel:()=>D.PhiModel,PhiPreTrainedModel:()=>D.PhiPreTrainedModel,Pipeline:()=>or.Pipeline,PreTrainedModel:()=>D.PreTrainedModel,PreTrainedTokenizer:()=>mn.PreTrainedTokenizer,PretrainedConfig:()=>Oy.PretrainedConfig,PretrainedMixin:()=>D.PretrainedMixin,Processor:()=>on.Processor,PvtForImageClassification:()=>D.PvtForImageClassification,PvtImageProcessor:()=>on.PvtImageProcessor,PvtModel:()=>D.PvtModel,PvtPreTrainedModel:()=>D.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>on.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>D.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>D.PyAnnoteModel,PyAnnotePreTrainedModel:()=>D.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>on.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>D.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>or.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>D.Qwen2ForCausalLM,Qwen2Model:()=>D.Qwen2Model,Qwen2PreTrainedModel:()=>D.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>mn.Qwen2Tokenizer,RTDetrForObjectDetection:()=>D.RTDetrForObjectDetection,RTDetrImageProcessor:()=>on.RTDetrImageProcessor,RTDetrModel:()=>D.RTDetrModel,RTDetrObjectDetectionOutput:()=>D.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>D.RTDetrPreTrainedModel,RawImage:()=>SF.RawImage,ResNetForImageClassification:()=>D.ResNetForImageClassification,ResNetModel:()=>D.ResNetModel,ResNetPreTrainedModel:()=>D.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>D.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>D.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>D.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>D.RoFormerForTokenClassification,RoFormerModel:()=>D.RoFormerModel,RoFormerPreTrainedModel:()=>D.RoFormerPreTrainedModel,RoFormerTokenizer:()=>mn.RoFormerTokenizer,RobertaForMaskedLM:()=>D.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>D.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>D.RobertaForSequenceClassification,RobertaForTokenClassification:()=>D.RobertaForTokenClassification,RobertaModel:()=>D.RobertaModel,RobertaPreTrainedModel:()=>D.RobertaPreTrainedModel,RobertaTokenizer:()=>mn.RobertaTokenizer,SamImageProcessor:()=>on.SamImageProcessor,SamImageSegmentationOutput:()=>D.SamImageSegmentationOutput,SamModel:()=>D.SamModel,SamPreTrainedModel:()=>D.SamPreTrainedModel,SamProcessor:()=>on.SamProcessor,SapiensFeatureExtractor:()=>on.SapiensFeatureExtractor,SapiensForDepthEstimation:()=>D.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>D.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>D.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>D.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>on.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>on.SegformerFeatureExtractor,SegformerForImageClassification:()=>D.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>D.SegformerForSemanticSegmentation,SegformerModel:()=>D.SegformerModel,SegformerPreTrainedModel:()=>D.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>D.Seq2SeqLMOutput,SequenceClassifierOutput:()=>D.SequenceClassifierOutput,SiglipImageProcessor:()=>on.SiglipImageProcessor,SiglipModel:()=>D.SiglipModel,SiglipPreTrainedModel:()=>D.SiglipPreTrainedModel,SiglipTextModel:()=>D.SiglipTextModel,SiglipTokenizer:()=>mn.SiglipTokenizer,SiglipVisionModel:()=>D.SiglipVisionModel,SpeechT5FeatureExtractor:()=>on.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>D.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>D.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>D.SpeechT5HifiGan,SpeechT5Model:()=>D.SpeechT5Model,SpeechT5PreTrainedModel:()=>D.SpeechT5PreTrainedModel,SpeechT5Processor:()=>on.SpeechT5Processor,SpeechT5Tokenizer:()=>mn.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>D.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>D.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>D.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>D.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>D.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>mn.SqueezeBertTokenizer,StableLmForCausalLM:()=>D.StableLmForCausalLM,StableLmModel:()=>D.StableLmModel,StableLmPreTrainedModel:()=>D.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>D.Starcoder2ForCausalLM,Starcoder2Model:()=>D.Starcoder2Model,Starcoder2PreTrainedModel:()=>D.Starcoder2PreTrainedModel,StoppingCriteria:()=>Df.StoppingCriteria,StoppingCriteriaList:()=>Df.StoppingCriteriaList,SummarizationPipeline:()=>or.SummarizationPipeline,Swin2SRForImageSuperResolution:()=>D.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>on.Swin2SRImageProcessor,Swin2SRModel:()=>D.Swin2SRModel,Swin2SRPreTrainedModel:()=>D.Swin2SRPreTrainedModel,SwinForImageClassification:()=>D.SwinForImageClassification,SwinModel:()=>D.SwinModel,SwinPreTrainedModel:()=>D.SwinPreTrainedModel,T5ForConditionalGeneration:()=>D.T5ForConditionalGeneration,T5Model:()=>D.T5Model,T5PreTrainedModel:()=>D.T5PreTrainedModel,T5Tokenizer:()=>mn.T5Tokenizer,TableTransformerForObjectDetection:()=>D.TableTransformerForObjectDetection,TableTransformerModel:()=>D.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>D.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>D.TableTransformerPreTrainedModel,Tensor:()=>Ar.Tensor,Text2TextGenerationPipeline:()=>or.Text2TextGenerationPipeline,TextClassificationPipeline:()=>or.TextClassificationPipeline,TextGenerationPipeline:()=>or.TextGenerationPipeline,TextStreamer:()=>Dy.TextStreamer,TextToAudioPipeline:()=>or.TextToAudioPipeline,TokenClassificationPipeline:()=>or.TokenClassificationPipeline,TokenClassifierOutput:()=>D.TokenClassifierOutput,TokenizerModel:()=>mn.TokenizerModel,TrOCRForCausalLM:()=>D.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>D.TrOCRPreTrainedModel,TranslationPipeline:()=>or.TranslationPipeline,UniSpeechForCTC:()=>D.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>D.UniSpeechForSequenceClassification,UniSpeechModel:()=>D.UniSpeechModel,UniSpeechPreTrainedModel:()=>D.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>D.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>D.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>D.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>D.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>D.UniSpeechSatPreTrainedModel,ViTFeatureExtractor:()=>on.ViTFeatureExtractor,ViTForImageClassification:()=>D.ViTForImageClassification,ViTImageProcessor:()=>on.ViTImageProcessor,ViTMAEModel:()=>D.ViTMAEModel,ViTMAEPreTrainedModel:()=>D.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>D.ViTMSNForImageClassification,ViTMSNModel:()=>D.ViTMSNModel,ViTMSNPreTrainedModel:()=>D.ViTMSNPreTrainedModel,ViTModel:()=>D.ViTModel,ViTPreTrainedModel:()=>D.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>D.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>D.VitMatteForImageMatting,VitMatteImageProcessor:()=>on.VitMatteImageProcessor,VitMattePreTrainedModel:()=>D.VitMattePreTrainedModel,VitsModel:()=>D.VitsModel,VitsModelOutput:()=>D.VitsModelOutput,VitsPreTrainedModel:()=>D.VitsPreTrainedModel,VitsTokenizer:()=>mn.VitsTokenizer,Wav2Vec2BertForCTC:()=>D.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>D.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>D.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>D.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>mn.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>on.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>D.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>D.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>D.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>D.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>D.Wav2Vec2PreTrainedModel,Wav2Vec2ProcessorWithLM:()=>on.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>D.WavLMForAudioFrameClassification,WavLMForCTC:()=>D.WavLMForCTC,WavLMForSequenceClassification:()=>D.WavLMForSequenceClassification,WavLMForXVector:()=>D.WavLMForXVector,WavLMModel:()=>D.WavLMModel,WavLMPreTrainedModel:()=>D.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>on.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>D.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>D.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>on.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>D.WhisperForConditionalGeneration,WhisperModel:()=>D.WhisperModel,WhisperPreTrainedModel:()=>D.WhisperPreTrainedModel,WhisperProcessor:()=>on.WhisperProcessor,WhisperTextStreamer:()=>Dy.WhisperTextStreamer,WhisperTokenizer:()=>mn.WhisperTokenizer,XLMForQuestionAnswering:()=>D.XLMForQuestionAnswering,XLMForSequenceClassification:()=>D.XLMForSequenceClassification,XLMForTokenClassification:()=>D.XLMForTokenClassification,XLMModel:()=>D.XLMModel,XLMPreTrainedModel:()=>D.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>D.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>D.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>D.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>D.XLMRobertaForTokenClassification,XLMRobertaModel:()=>D.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>D.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>mn.XLMRobertaTokenizer,XLMTokenizer:()=>mn.XLMTokenizer,XLMWithLMHeadModel:()=>D.XLMWithLMHeadModel,XVectorOutput:()=>D.XVectorOutput,YolosFeatureExtractor:()=>on.YolosFeatureExtractor,YolosForObjectDetection:()=>D.YolosForObjectDetection,YolosModel:()=>D.YolosModel,YolosObjectDetectionOutput:()=>D.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>D.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>or.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>or.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>or.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>or.ZeroShotObjectDetectionPipeline,bankers_round:()=>vi.bankers_round,cat:()=>Ar.cat,cos_sim:()=>vi.cos_sim,dot:()=>vi.dot,dynamic_time_warping:()=>vi.dynamic_time_warping,env:()=>TF.env,full:()=>Ar.full,full_like:()=>Ar.full_like,getKeyValueShapes:()=>Oy.getKeyValueShapes,hamming:()=>$u.hamming,hanning:()=>$u.hanning,interpolate:()=>Ar.interpolate,interpolate_4d:()=>Ar.interpolate_4d,interpolate_data:()=>vi.interpolate_data,is_chinese_char:()=>mn.is_chinese_char,layer_norm:()=>Ar.layer_norm,log_softmax:()=>vi.log_softmax,magnitude:()=>vi.magnitude,matmul:()=>Ar.matmul,max:()=>vi.max,mean:()=>Ar.mean,mean_pooling:()=>Ar.mean_pooling,medianFilter:()=>vi.medianFilter,mel_filter_bank:()=>$u.mel_filter_bank,min:()=>vi.min,ones:()=>Ar.ones,ones_like:()=>Ar.ones_like,permute:()=>Ar.permute,permute_data:()=>vi.permute_data,pipeline:()=>or.pipeline,quantize_embeddings:()=>Ar.quantize_embeddings,read_audio:()=>$u.read_audio,rfft:()=>Ar.rfft,round:()=>vi.round,softmax:()=>vi.softmax,spectrogram:()=>$u.spectrogram,stack:()=>Ar.stack,std_mean:()=>Ar.std_mean,topk:()=>Ar.topk,window_function:()=>$u.window_function,zeros:()=>Ar.zeros,zeros_like:()=>Ar.zeros_like});var TF=ar("./src/env.js"),or=ar("./src/pipelines.js"),D=ar("./src/models.js"),mn=ar("./src/tokenizers.js"),on=ar("./src/processors.js"),Oy=ar("./src/configs.js"),$u=ar("./src/utils/audio.js"),SF=ar("./src/utils/image.js"),Ar=ar("./src/utils/tensor.js"),vi=ar("./src/utils/maths.js"),Dy=ar("./src/generation/streamers.js"),Df=ar("./src/generation/stopping_criteria.js");M.ASTFeatureExtractor;M.ASTForAudioClassification;M.ASTModel;M.ASTPreTrainedModel;M.AlbertForMaskedLM;M.AlbertForQuestionAnswering;M.AlbertForSequenceClassification;M.AlbertModel;M.AlbertPreTrainedModel;M.AlbertTokenizer;M.AudioClassificationPipeline;M.AutoConfig;M.AutoModel;M.AutoModelForAudioClassification;M.AutoModelForAudioFrameClassification;M.AutoModelForCTC;M.AutoModelForCausalLM;M.AutoModelForDepthEstimation;M.AutoModelForDocumentQuestionAnswering;M.AutoModelForImageClassification;M.AutoModelForImageFeatureExtraction;M.AutoModelForImageMatting;M.AutoModelForImageSegmentation;M.AutoModelForImageToImage;M.AutoModelForMaskGeneration;M.AutoModelForMaskedLM;M.AutoModelForNormalEstimation;M.AutoModelForObjectDetection;M.AutoModelForQuestionAnswering;M.AutoModelForSemanticSegmentation;M.AutoModelForSeq2SeqLM;M.AutoModelForSequenceClassification;M.AutoModelForSpeechSeq2Seq;M.AutoModelForTextToSpectrogram;M.AutoModelForTextToWaveform;M.AutoModelForTokenClassification;M.AutoModelForUniversalSegmentation;M.AutoModelForVision2Seq;M.AutoModelForXVector;M.AutoModelForZeroShotObjectDetection;M.AutoProcessor;M.AutoTokenizer;M.AutomaticSpeechRecognitionPipeline;M.BartForConditionalGeneration;M.BartForSequenceClassification;M.BartModel;M.BartPretrainedModel;M.BartTokenizer;M.BaseModelOutput;M.BaseStreamer;M.BeitFeatureExtractor;M.BeitForImageClassification;M.BeitModel;M.BeitPreTrainedModel;M.BertForMaskedLM;M.BertForQuestionAnswering;M.BertForSequenceClassification;M.BertForTokenClassification;M.BertModel;M.BertPreTrainedModel;M.BertTokenizer;M.BitImageProcessor;M.BlenderbotForConditionalGeneration;M.BlenderbotModel;M.BlenderbotPreTrainedModel;M.BlenderbotSmallForConditionalGeneration;M.BlenderbotSmallModel;M.BlenderbotSmallPreTrainedModel;M.BlenderbotSmallTokenizer;M.BlenderbotTokenizer;M.BloomForCausalLM;M.BloomModel;M.BloomPreTrainedModel;M.BloomTokenizer;M.CLIPFeatureExtractor;M.CLIPImageProcessor;M.CLIPModel;M.CLIPPreTrainedModel;M.CLIPSegForImageSegmentation;M.CLIPSegModel;M.CLIPSegPreTrainedModel;M.CLIPTextModel;M.CLIPTextModelWithProjection;M.CLIPTokenizer;M.CLIPVisionModel;M.CLIPVisionModelWithProjection;M.CamembertForMaskedLM;M.CamembertForQuestionAnswering;M.CamembertForSequenceClassification;M.CamembertForTokenClassification;M.CamembertModel;M.CamembertPreTrainedModel;M.CamembertTokenizer;M.CausalLMOutput;M.CausalLMOutputWithPast;M.ChineseCLIPFeatureExtractor;M.ChineseCLIPModel;M.ChineseCLIPPreTrainedModel;M.ClapAudioModelWithProjection;M.ClapFeatureExtractor;M.ClapModel;M.ClapPreTrainedModel;M.ClapTextModelWithProjection;M.CodeGenForCausalLM;M.CodeGenModel;M.CodeGenPreTrainedModel;M.CodeGenTokenizer;M.CodeLlamaTokenizer;M.CohereForCausalLM;M.CohereModel;M.CoherePreTrainedModel;M.CohereTokenizer;M.ConvBertForMaskedLM;M.ConvBertForQuestionAnswering;M.ConvBertForSequenceClassification;M.ConvBertForTokenClassification;M.ConvBertModel;M.ConvBertPreTrainedModel;M.ConvBertTokenizer;M.ConvNextFeatureExtractor;M.ConvNextForImageClassification;M.ConvNextImageProcessor;M.ConvNextModel;M.ConvNextPreTrainedModel;M.ConvNextV2ForImageClassification;M.ConvNextV2Model;M.ConvNextV2PreTrainedModel;M.DPTFeatureExtractor;M.DPTForDepthEstimation;M.DPTImageProcessor;M.DPTModel;M.DPTPreTrainedModel;M.DebertaForMaskedLM;M.DebertaForQuestionAnswering;M.DebertaForSequenceClassification;M.DebertaForTokenClassification;M.DebertaModel;M.DebertaPreTrainedModel;M.DebertaTokenizer;M.DebertaV2ForMaskedLM;M.DebertaV2ForQuestionAnswering;M.DebertaV2ForSequenceClassification;M.DebertaV2ForTokenClassification;M.DebertaV2Model;M.DebertaV2PreTrainedModel;M.DebertaV2Tokenizer;M.DecisionTransformerModel;M.DecisionTransformerPreTrainedModel;M.DeiTFeatureExtractor;M.DeiTForImageClassification;M.DeiTModel;M.DeiTPreTrainedModel;M.DepthAnythingForDepthEstimation;M.DepthAnythingPreTrainedModel;M.DepthEstimationPipeline;M.DepthProForDepthEstimation;M.DepthProPreTrainedModel;M.DetrFeatureExtractor;M.DetrForObjectDetection;M.DetrForSegmentation;M.DetrModel;M.DetrObjectDetectionOutput;M.DetrPreTrainedModel;M.DetrSegmentationOutput;M.Dinov2ForImageClassification;M.Dinov2Model;M.Dinov2PreTrainedModel;M.DistilBertForMaskedLM;M.DistilBertForQuestionAnswering;M.DistilBertForSequenceClassification;M.DistilBertForTokenClassification;M.DistilBertModel;M.DistilBertPreTrainedModel;M.DistilBertTokenizer;M.DocumentQuestionAnsweringPipeline;M.DonutFeatureExtractor;M.DonutImageProcessor;M.DonutSwinModel;M.DonutSwinPreTrainedModel;M.EfficientNetForImageClassification;M.EfficientNetImageProcessor;M.EfficientNetModel;M.EfficientNetPreTrainedModel;M.ElectraForMaskedLM;M.ElectraForQuestionAnswering;M.ElectraForSequenceClassification;M.ElectraForTokenClassification;M.ElectraModel;M.ElectraPreTrainedModel;M.ElectraTokenizer;M.EosTokenCriteria;M.EsmForMaskedLM;M.EsmForSequenceClassification;M.EsmForTokenClassification;M.EsmModel;M.EsmPreTrainedModel;M.EsmTokenizer;M.FFT;M.FalconForCausalLM;M.FalconModel;M.FalconPreTrainedModel;M.FalconTokenizer;M.FastViTForImageClassification;M.FastViTModel;M.FastViTPreTrainedModel;M.FeatureExtractionPipeline;M.FeatureExtractor;M.FillMaskPipeline;M.Florence2ForConditionalGeneration;M.Florence2PreTrainedModel;M.Florence2Processor;M.GLPNFeatureExtractor;M.GLPNForDepthEstimation;M.GLPNModel;M.GLPNPreTrainedModel;M.GPT2LMHeadModel;M.GPT2Model;M.GPT2PreTrainedModel;M.GPT2Tokenizer;M.GPTBigCodeForCausalLM;M.GPTBigCodeModel;M.GPTBigCodePreTrainedModel;M.GPTJForCausalLM;M.GPTJModel;M.GPTJPreTrainedModel;M.GPTNeoForCausalLM;M.GPTNeoModel;M.GPTNeoPreTrainedModel;M.GPTNeoXForCausalLM;M.GPTNeoXModel;M.GPTNeoXPreTrainedModel;M.GPTNeoXTokenizer;M.Gemma2ForCausalLM;M.Gemma2Model;M.Gemma2PreTrainedModel;M.GemmaForCausalLM;M.GemmaModel;M.GemmaPreTrainedModel;M.GemmaTokenizer;M.GraniteForCausalLM;M.GraniteModel;M.GranitePreTrainedModel;M.Grok1Tokenizer;M.GroupViTModel;M.GroupViTPreTrainedModel;M.HerbertTokenizer;M.HieraForImageClassification;M.HieraModel;M.HieraPreTrainedModel;M.HubertForCTC;M.HubertForSequenceClassification;M.HubertModel;M.HubertPreTrainedModel;M.ImageClassificationPipeline;M.ImageFeatureExtractionPipeline;M.ImageFeatureExtractor;M.ImageMattingOutput;M.ImageSegmentationPipeline;M.ImageToImagePipeline;M.ImageToTextPipeline;M.InterruptableStoppingCriteria;M.JAISLMHeadModel;M.JAISModel;M.JAISPreTrainedModel;M.LlamaForCausalLM;M.LlamaModel;M.LlamaPreTrainedModel;M.LlamaTokenizer;M.LlavaForConditionalGeneration;M.LlavaPreTrainedModel;M.LongT5ForConditionalGeneration;M.LongT5Model;M.LongT5PreTrainedModel;M.M2M100ForConditionalGeneration;M.M2M100Model;M.M2M100PreTrainedModel;M.M2M100Tokenizer;M.MBart50Tokenizer;M.MBartForCausalLM;M.MBartForConditionalGeneration;M.MBartForSequenceClassification;M.MBartModel;M.MBartPreTrainedModel;M.MBartTokenizer;M.MPNetForMaskedLM;M.MPNetForQuestionAnswering;M.MPNetForSequenceClassification;M.MPNetForTokenClassification;M.MPNetModel;M.MPNetPreTrainedModel;M.MPNetTokenizer;M.MT5ForConditionalGeneration;M.MT5Model;M.MT5PreTrainedModel;M.MarianMTModel;M.MarianModel;M.MarianPreTrainedModel;M.MarianTokenizer;M.MaskFormerFeatureExtractor;M.MaskFormerForInstanceSegmentation;M.MaskFormerModel;M.MaskFormerPreTrainedModel;M.MaskedLMOutput;M.MaxLengthCriteria;M.MistralForCausalLM;M.MistralModel;M.MistralPreTrainedModel;M.MobileBertForMaskedLM;M.MobileBertForQuestionAnswering;M.MobileBertForSequenceClassification;M.MobileBertModel;M.MobileBertPreTrainedModel;M.MobileBertTokenizer;M.MobileNetV1FeatureExtractor;M.MobileNetV1ForImageClassification;M.MobileNetV1Model;M.MobileNetV1PreTrainedModel;M.MobileNetV2FeatureExtractor;M.MobileNetV2ForImageClassification;M.MobileNetV2Model;M.MobileNetV2PreTrainedModel;M.MobileNetV3FeatureExtractor;M.MobileNetV3ForImageClassification;M.MobileNetV3Model;M.MobileNetV3PreTrainedModel;M.MobileNetV4FeatureExtractor;M.MobileNetV4ForImageClassification;M.MobileNetV4Model;M.MobileNetV4PreTrainedModel;M.MobileViTFeatureExtractor;M.MobileViTForImageClassification;M.MobileViTImageProcessor;M.MobileViTModel;M.MobileViTPreTrainedModel;M.MobileViTV2ForImageClassification;M.MobileViTV2Model;M.MobileViTV2PreTrainedModel;M.ModelOutput;M.Moondream1ForConditionalGeneration;M.MptForCausalLM;M.MptModel;M.MptPreTrainedModel;M.MusicgenForCausalLM;M.MusicgenForConditionalGeneration;M.MusicgenModel;M.MusicgenPreTrainedModel;M.NllbTokenizer;M.NomicBertModel;M.NomicBertPreTrainedModel;M.NougatImageProcessor;M.NougatTokenizer;M.OPTForCausalLM;M.OPTModel;M.OPTPreTrainedModel;M.ObjectDetectionPipeline;M.OpenELMForCausalLM;M.OpenELMModel;M.OpenELMPreTrainedModel;M.OwlViTFeatureExtractor;M.OwlViTForObjectDetection;M.OwlViTModel;M.OwlViTPreTrainedModel;M.OwlViTProcessor;M.Owlv2ForObjectDetection;M.Owlv2ImageProcessor;M.Owlv2Model;M.Owlv2PreTrainedModel;M.Phi3ForCausalLM;M.Phi3Model;M.Phi3PreTrainedModel;M.PhiForCausalLM;M.PhiModel;M.PhiPreTrainedModel;M.Pipeline;M.PreTrainedModel;M.PreTrainedTokenizer;M.PretrainedConfig;M.PretrainedMixin;M.Processor;M.PvtForImageClassification;M.PvtImageProcessor;M.PvtModel;M.PvtPreTrainedModel;M.PyAnnoteFeatureExtractor;M.PyAnnoteForAudioFrameClassification;M.PyAnnoteModel;M.PyAnnotePreTrainedModel;M.PyAnnoteProcessor;M.QuestionAnsweringModelOutput;M.QuestionAnsweringPipeline;M.Qwen2ForCausalLM;M.Qwen2Model;M.Qwen2PreTrainedModel;M.Qwen2Tokenizer;M.RTDetrForObjectDetection;M.RTDetrImageProcessor;M.RTDetrModel;M.RTDetrObjectDetectionOutput;M.RTDetrPreTrainedModel;M.RawImage;M.ResNetForImageClassification;M.ResNetModel;M.ResNetPreTrainedModel;M.RoFormerForMaskedLM;M.RoFormerForQuestionAnswering;M.RoFormerForSequenceClassification;M.RoFormerForTokenClassification;M.RoFormerModel;M.RoFormerPreTrainedModel;M.RoFormerTokenizer;M.RobertaForMaskedLM;M.RobertaForQuestionAnswering;M.RobertaForSequenceClassification;M.RobertaForTokenClassification;M.RobertaModel;M.RobertaPreTrainedModel;M.RobertaTokenizer;M.SamImageProcessor;M.SamImageSegmentationOutput;M.SamModel;M.SamPreTrainedModel;M.SamProcessor;M.SapiensFeatureExtractor;M.SapiensForDepthEstimation;M.SapiensForNormalEstimation;M.SapiensForSemanticSegmentation;M.SapiensPreTrainedModel;M.SeamlessM4TFeatureExtractor;M.SegformerFeatureExtractor;M.SegformerForImageClassification;M.SegformerForSemanticSegmentation;M.SegformerModel;M.SegformerPreTrainedModel;M.Seq2SeqLMOutput;M.SequenceClassifierOutput;M.SiglipImageProcessor;M.SiglipModel;M.SiglipPreTrainedModel;M.SiglipTextModel;M.SiglipTokenizer;M.SiglipVisionModel;M.SpeechT5FeatureExtractor;M.SpeechT5ForSpeechToText;M.SpeechT5ForTextToSpeech;M.SpeechT5HifiGan;M.SpeechT5Model;M.SpeechT5PreTrainedModel;M.SpeechT5Processor;M.SpeechT5Tokenizer;M.SqueezeBertForMaskedLM;M.SqueezeBertForQuestionAnswering;M.SqueezeBertForSequenceClassification;M.SqueezeBertModel;M.SqueezeBertPreTrainedModel;M.SqueezeBertTokenizer;M.StableLmForCausalLM;M.StableLmModel;M.StableLmPreTrainedModel;M.Starcoder2ForCausalLM;M.Starcoder2Model;M.Starcoder2PreTrainedModel;M.StoppingCriteria;M.StoppingCriteriaList;M.SummarizationPipeline;M.Swin2SRForImageSuperResolution;M.Swin2SRImageProcessor;M.Swin2SRModel;M.Swin2SRPreTrainedModel;M.SwinForImageClassification;M.SwinModel;M.SwinPreTrainedModel;M.T5ForConditionalGeneration;M.T5Model;M.T5PreTrainedModel;M.T5Tokenizer;M.TableTransformerForObjectDetection;M.TableTransformerModel;M.TableTransformerObjectDetectionOutput;M.TableTransformerPreTrainedModel;M.Tensor;M.Text2TextGenerationPipeline;M.TextClassificationPipeline;M.TextGenerationPipeline;M.TextStreamer;M.TextToAudioPipeline;M.TokenClassificationPipeline;M.TokenClassifierOutput;M.TokenizerModel;M.TrOCRForCausalLM;M.TrOCRPreTrainedModel;M.TranslationPipeline;M.UniSpeechForCTC;M.UniSpeechForSequenceClassification;M.UniSpeechModel;M.UniSpeechPreTrainedModel;M.UniSpeechSatForAudioFrameClassification;M.UniSpeechSatForCTC;M.UniSpeechSatForSequenceClassification;M.UniSpeechSatModel;M.UniSpeechSatPreTrainedModel;M.ViTFeatureExtractor;M.ViTForImageClassification;M.ViTImageProcessor;M.ViTMAEModel;M.ViTMAEPreTrainedModel;M.ViTMSNForImageClassification;M.ViTMSNModel;M.ViTMSNPreTrainedModel;M.ViTModel;M.ViTPreTrainedModel;M.VisionEncoderDecoderModel;M.VitMatteForImageMatting;M.VitMatteImageProcessor;M.VitMattePreTrainedModel;M.VitsModel;M.VitsModelOutput;M.VitsPreTrainedModel;M.VitsTokenizer;M.Wav2Vec2BertForCTC;M.Wav2Vec2BertForSequenceClassification;M.Wav2Vec2BertModel;M.Wav2Vec2BertPreTrainedModel;M.Wav2Vec2CTCTokenizer;M.Wav2Vec2FeatureExtractor;M.Wav2Vec2ForAudioFrameClassification;M.Wav2Vec2ForCTC;M.Wav2Vec2ForSequenceClassification;M.Wav2Vec2Model;M.Wav2Vec2PreTrainedModel;M.Wav2Vec2ProcessorWithLM;M.WavLMForAudioFrameClassification;M.WavLMForCTC;M.WavLMForSequenceClassification;M.WavLMForXVector;M.WavLMModel;M.WavLMPreTrainedModel;M.WeSpeakerFeatureExtractor;M.WeSpeakerResNetModel;M.WeSpeakerResNetPreTrainedModel;M.WhisperFeatureExtractor;M.WhisperForConditionalGeneration;M.WhisperModel;M.WhisperPreTrainedModel;M.WhisperProcessor;M.WhisperTextStreamer;M.WhisperTokenizer;M.XLMForQuestionAnswering;M.XLMForSequenceClassification;M.XLMForTokenClassification;M.XLMModel;M.XLMPreTrainedModel;M.XLMRobertaForMaskedLM;M.XLMRobertaForQuestionAnswering;M.XLMRobertaForSequenceClassification;M.XLMRobertaForTokenClassification;M.XLMRobertaModel;M.XLMRobertaPreTrainedModel;M.XLMRobertaTokenizer;M.XLMTokenizer;M.XLMWithLMHeadModel;M.XVectorOutput;M.YolosFeatureExtractor;M.YolosForObjectDetection;M.YolosModel;M.YolosObjectDetectionOutput;M.YolosPreTrainedModel;M.ZeroShotAudioClassificationPipeline;M.ZeroShotClassificationPipeline;M.ZeroShotImageClassificationPipeline;M.ZeroShotObjectDetectionPipeline;M.bankers_round;M.cat;M.cos_sim;M.dot;M.dynamic_time_warping;var EF=M.env;M.full;M.full_like;M.getKeyValueShapes;M.hamming;M.hanning;M.interpolate;M.interpolate_4d;M.interpolate_data;M.is_chinese_char;M.layer_norm;M.log_softmax;M.magnitude;M.matmul;M.max;M.mean;M.mean_pooling;M.medianFilter;M.mel_filter_bank;M.min;M.ones;M.ones_like;M.permute;M.permute_data;M.pipeline;M.quantize_embeddings;M.read_audio;M.rfft;M.round;M.softmax;M.spectrogram;M.stack;M.std_mean;M.topk;M.window_function;M.zeros;M.zeros_like;console.log(EF);function kF(){const[e,t]=Le.useState(void 0),[r,o]=Le.useState(!1),[a,l]=Le.useState(!1),[p,w]=Le.useState([]),_=Le.useRef(),y=MF(pe=>{const fe=pe.data;switch(fe.status){case"progress":console.log("progress",fe),w(Ce=>Ce.map(tt=>tt.file===fe.file?{...tt,progress:fe.progress}:tt));break;case"update":console.log("update",fe);break;case"complete":const xe=fe,$e={isBusy:!1,text:xe.data.text,chunks:xe.data.chunks,latency:fe.latency};t($e),o(!1),console.log("complete",fe,$e),_.current&&(_.current($e),_.current=void 0);break;case"initiate":console.log("initiate",fe),l(!0),w(Ce=>[...Ce,fe]);break;case"ready":console.log("ready",fe),l(!1);break;case"error":o(!1),alert(`${fe.data.message} This is most likely because you are using Safari on an M1/M2 Mac. Please try again from Chrome, Firefox, or Edge.

If this is not the case, please file a bug report.`);break;case"done":console.log("done",fe),w(Ce=>Ce.filter(tt=>tt.file!==fe.file));break}}),[T,E]=Le.useState(fo.DEFAULT_MODEL),[A,H]=Le.useState(fo.DEFAULT_SUBTASK),[W,Y]=Le.useState(fo.DEFAULT_DTYPE),[B,F]=Le.useState(fo.DEFAULT_DTYPE),[O,P]=Le.useState(fo.DEFAULT_MULTILINGUAL),[j,V]=Le.useState(fo.DEFAULT_LANGUAGE),z=Le.useCallback(()=>{t(void 0)},[]),q=Le.useCallback(pe=>new Promise((fe,xe)=>{if(pe){t(void 0),o(!0),_.current=fe;let $e;if(pe.numberOfChannels===2){const Ce=Math.sqrt(2);let tt=pe.getChannelData(0),Je=pe.getChannelData(1);$e=new Float32Array(tt.length);for(let it=0;it<pe.length;++it)$e[it]=Ce*(tt[it]+Je[it])/2}else $e=pe.getChannelData(0);y.postMessage({audio:$e,model:T,multilingual:O,encoderDtype:W,decoderDtype:B,subtask:O?A:null,language:O&&j!=="auto"?j:null})}else xe(new Error("No audio data provided"))}),[y,T,O,W,B,A,j]);return Le.useMemo(()=>({onInputChange:z,isBusy:r,isModelLoading:a,progressItems:p,start:q,output:e,model:T,setModel:E,multilingual:O,setMultilingual:P,encoderDtype:W,setEncoderDtype:Y,decoderDtype:B,setDecoderDtype:F,subtask:A,setSubtask:H,language:j,setLanguage:V}),[r,a,p,q,e,T,O,W,B,A,j])}function CF(){const e=kF();return tr("div",{className:"flex justify-center items-center min-h-screen",children:[tr("div",{className:"container flex flex-col justify-center items-center",children:[wt("h1",{className:"text-5xl font-extrabold tracking-tight text-slate-900 sm:text-7xl text-center",children:"Whisper Web"}),wt("h2",{className:"mt-3 mb-5 px-4 text-center text-1xl font-semibold tracking-tight text-slate-900 sm:text-2xl",children:"ML-powered speech recognition directly in your browser"}),wt(aF,{transcriber:e})]}),tr("div",{className:"absolute bottom-4",children:["Made with"," ",wt("a",{className:"underline",href:"https://github.com/hugginface/transformers.js",children:"🤗 Transformers.js"})]})]})}Ly.createRoot(document.getElementById("root")).render(wt(qn.StrictMode,{children:wt(CF,{})}));
